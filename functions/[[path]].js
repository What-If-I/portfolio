var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module, copyDefault, desc) => {
  if (module && typeof module === "object" || typeof module === "function") {
    for (let key of __getOwnPropNames(module))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module[key], enumerable: !(desc = __getOwnPropDesc(module, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module != null ? __create(__getProtoOf(module)) : {}, "default", !isNodeMode && module && module.__esModule ? { get: () => module.default, enumerable: true } : { value: module, enumerable: true })), module);
};
var __toCommonJS = /* @__PURE__ */ ((cache2) => {
  return (module, temp) => {
    return cache2 && cache2.get(module) || (temp = __reExport(__markAsModule({}), module, 1), cache2 && cache2.set(module, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    init_react();
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from2;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from2 = Object(arguments[s]);
        for (var key in from2) {
          if (hasOwnProperty2.call(from2, key)) {
            to[key] = from2[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from2);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from2, symbols[i])) {
              to[symbols[i]] = from2[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports) {
    "use strict";
    init_react();
    if (true) {
      (function() {
        "use strict";
        var _assign = require_object_assign();
        var ReactVersion = "17.0.2";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        exports.Fragment = 60107;
        exports.StrictMode = 60108;
        exports.Profiler = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        exports.Suspense = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          exports.Fragment = symbolFor("react.fragment");
          exports.StrictMode = symbolFor("react.strict_mode");
          exports.Profiler = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          exports.Suspense = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactCurrentDispatcher = {
          current: null
        };
        var ReactCurrentBatchConfig = {
          transition: 0
        };
        var ReactCurrentOwner = {
          current: null
        };
        var ReactDebugCurrentFrame = {};
        var currentExtraStackFrame = null;
        function setExtraStackFrame(stack) {
          {
            currentExtraStackFrame = stack;
          }
        }
        {
          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
            {
              currentExtraStackFrame = stack;
            }
          };
          ReactDebugCurrentFrame.getCurrentStack = null;
          ReactDebugCurrentFrame.getStackAddendum = function() {
            var stack = "";
            if (currentExtraStackFrame) {
              stack += currentExtraStackFrame;
            }
            var impl = ReactDebugCurrentFrame.getCurrentStack;
            if (impl) {
              stack += impl() || "";
            }
            return stack;
          };
        }
        var IsSomeRendererActing = {
          current: false
        };
        var ReactSharedInternals = {
          ReactCurrentDispatcher,
          ReactCurrentBatchConfig,
          ReactCurrentOwner,
          IsSomeRendererActing,
          assign: _assign
        };
        {
          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        }
        function warn(format2) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format2, args);
          }
        }
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var didWarnStateUpdateForUnmountedComponent = {};
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
              return;
            }
            error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
            didWarnStateUpdateForUnmountedComponent[warningKey] = true;
          }
        }
        var ReactNoopUpdateQueue = {
          isMounted: function(publicInstance) {
            return false;
          },
          enqueueForceUpdate: function(publicInstance, callback, callerName) {
            warnNoop(publicInstance, "forceUpdate");
          },
          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
            warnNoop(publicInstance, "replaceState");
          },
          enqueueSetState: function(publicInstance, partialState, callback, callerName) {
            warnNoop(publicInstance, "setState");
          }
        };
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function Component2(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        Component2.prototype.isReactComponent = {};
        Component2.prototype.setState = function(partialState, callback) {
          if (!(typeof partialState === "object" || typeof partialState === "function" || partialState == null)) {
            {
              throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
          }
          this.updater.enqueueSetState(this, partialState, callback, "setState");
        };
        Component2.prototype.forceUpdate = function(callback) {
          this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
        };
        {
          var deprecatedAPIs = {
            isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
            replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
          };
          var defineDeprecationWarning = function(methodName, info) {
            Object.defineProperty(Component2.prototype, methodName, {
              get: function() {
                warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                return void 0;
              }
            });
          };
          for (var fnName in deprecatedAPIs) {
            if (deprecatedAPIs.hasOwnProperty(fnName)) {
              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
            }
          }
        }
        function ComponentDummy() {
        }
        ComponentDummy.prototype = Component2.prototype;
        function PureComponent(props, context, updater) {
          this.props = props;
          this.context = context;
          this.refs = emptyObject;
          this.updater = updater || ReactNoopUpdateQueue;
        }
        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
        pureComponentPrototype.constructor = PureComponent;
        _assign(pureComponentPrototype, Component2.prototype);
        pureComponentPrototype.isPureReactComponent = true;
        function createRef() {
          var refObject = {
            current: null
          };
          {
            Object.seal(refObject);
          }
          return refObject;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentName(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case exports.Fragment:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case exports.Profiler:
              return "Profiler";
            case exports.StrictMode:
              return "StrictMode";
            case exports.Suspense:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type2;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type2;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type2.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type2._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentName(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config3) {
          {
            if (hasOwnProperty2.call(config3, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config3, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config3.ref !== void 0;
        }
        function hasValidKey(config3) {
          {
            if (hasOwnProperty2.call(config3, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config3, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config3.key !== void 0;
        }
        function defineKeyPropWarningGetter(props, displayName) {
          var warnAboutAccessingKey = function() {
            {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
        function defineRefPropWarningGetter(props, displayName) {
          var warnAboutAccessingRef = function() {
            {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
        function warnIfStringRefCannotBeAutoConverted(config3) {
          {
            if (typeof config3.ref === "string" && ReactCurrentOwner.current && config3.__self && ReactCurrentOwner.current.stateNode !== config3.__self) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config3.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        var ReactElement = function(type2, key, ref, self2, source, owner, props) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type2,
            key,
            ref,
            props,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function createElement8(type2, config3, children) {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          var self2 = null;
          var source = null;
          if (config3 != null) {
            if (hasValidRef(config3)) {
              ref = config3.ref;
              {
                warnIfStringRefCannotBeAutoConverted(config3);
              }
            }
            if (hasValidKey(config3)) {
              key = "" + config3.key;
            }
            self2 = config3.__self === void 0 ? null : config3.__self;
            source = config3.__source === void 0 ? null : config3.__source;
            for (propName in config3) {
              if (hasOwnProperty2.call(config3, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config3[propName];
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            {
              if (Object.freeze) {
                Object.freeze(childArray);
              }
            }
            props.children = childArray;
          }
          if (type2 && type2.defaultProps) {
            var defaultProps2 = type2.defaultProps;
            for (propName in defaultProps2) {
              if (props[propName] === void 0) {
                props[propName] = defaultProps2[propName];
              }
            }
          }
          {
            if (key || ref) {
              var displayName = typeof type2 === "function" ? type2.displayName || type2.name || "Unknown" : type2;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
          }
          return ReactElement(type2, key, ref, self2, source, ReactCurrentOwner.current, props);
        }
        function cloneAndReplaceKey(oldElement, newKey) {
          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
          return newElement;
        }
        function cloneElement(element, config3, children) {
          if (!!(element === null || element === void 0)) {
            {
              throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
          }
          var propName;
          var props = _assign({}, element.props);
          var key = element.key;
          var ref = element.ref;
          var self2 = element._self;
          var source = element._source;
          var owner = element._owner;
          if (config3 != null) {
            if (hasValidRef(config3)) {
              ref = config3.ref;
              owner = ReactCurrentOwner.current;
            }
            if (hasValidKey(config3)) {
              key = "" + config3.key;
            }
            var defaultProps2;
            if (element.type && element.type.defaultProps) {
              defaultProps2 = element.type.defaultProps;
            }
            for (propName in config3) {
              if (hasOwnProperty2.call(config3, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                if (config3[propName] === void 0 && defaultProps2 !== void 0) {
                  props[propName] = defaultProps2[propName];
                } else {
                  props[propName] = config3[propName];
                }
              }
            }
          }
          var childrenLength = arguments.length - 2;
          if (childrenLength === 1) {
            props.children = children;
          } else if (childrenLength > 1) {
            var childArray = Array(childrenLength);
            for (var i = 0; i < childrenLength; i++) {
              childArray[i] = arguments[i + 2];
            }
            props.children = childArray;
          }
          return ReactElement(element.type, key, ref, self2, source, owner, props);
        }
        function isValidElement2(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        var SEPARATOR = ".";
        var SUBSEPARATOR = ":";
        function escape(key) {
          var escapeRegex = /[=:]/g;
          var escaperLookup = {
            "=": "=0",
            ":": "=2"
          };
          var escapedString = key.replace(escapeRegex, function(match) {
            return escaperLookup[match];
          });
          return "$" + escapedString;
        }
        var didWarnAboutMaps = false;
        var userProvidedKeyEscapeRegex = /\/+/g;
        function escapeUserProvidedKey(text) {
          return text.replace(userProvidedKeyEscapeRegex, "$&/");
        }
        function getElementKey(element, index2) {
          if (typeof element === "object" && element !== null && element.key != null) {
            return escape("" + element.key);
          }
          return index2.toString(36);
        }
        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
          var type2 = typeof children;
          if (type2 === "undefined" || type2 === "boolean") {
            children = null;
          }
          var invokeCallback = false;
          if (children === null) {
            invokeCallback = true;
          } else {
            switch (type2) {
              case "string":
              case "number":
                invokeCallback = true;
                break;
              case "object":
                switch (children.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    invokeCallback = true;
                }
            }
          }
          if (invokeCallback) {
            var _child = children;
            var mappedChild = callback(_child);
            var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
            if (Array.isArray(mappedChild)) {
              var escapedChildKey = "";
              if (childKey != null) {
                escapedChildKey = escapeUserProvidedKey(childKey) + "/";
              }
              mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
                return c;
              });
            } else if (mappedChild != null) {
              if (isValidElement2(mappedChild)) {
                mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
              }
              array.push(mappedChild);
            }
            return 1;
          }
          var child;
          var nextName;
          var subtreeCount = 0;
          var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
          if (Array.isArray(children)) {
            for (var i = 0; i < children.length; i++) {
              child = children[i];
              nextName = nextNamePrefix + getElementKey(child, i);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else {
            var iteratorFn = getIteratorFn(children);
            if (typeof iteratorFn === "function") {
              var iterableChildren = children;
              {
                if (iteratorFn === iterableChildren.entries) {
                  if (!didWarnAboutMaps) {
                    warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
              }
              var iterator = iteratorFn.call(iterableChildren);
              var step;
              var ii = 0;
              while (!(step = iterator.next()).done) {
                child = step.value;
                nextName = nextNamePrefix + getElementKey(child, ii++);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else if (type2 === "object") {
              var childrenString = "" + children;
              {
                {
                  throw Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
                }
              }
            }
          }
          return subtreeCount;
        }
        function mapChildren(children, func, context) {
          if (children == null) {
            return children;
          }
          var result = [];
          var count2 = 0;
          mapIntoArray(children, result, "", "", function(child) {
            return func.call(context, child, count2++);
          });
          return result;
        }
        function countChildren(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        }
        function forEachChildren(children, forEachFunc, forEachContext) {
          mapChildren(children, function() {
            forEachFunc.apply(this, arguments);
          }, forEachContext);
        }
        function toArray(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        }
        function onlyChild(children) {
          if (!isValidElement2(children)) {
            {
              throw Error("React.Children.only expected to receive a single React element child.");
            }
          }
          return children;
        }
        function createContext4(defaultValue, calculateChangedBits) {
          if (calculateChangedBits === void 0) {
            calculateChangedBits = null;
          } else {
            {
              if (calculateChangedBits !== null && typeof calculateChangedBits !== "function") {
                error("createContext: Expected the optional second argument to be a function. Instead received: %s", calculateChangedBits);
              }
            }
          }
          var context = {
            $$typeof: REACT_CONTEXT_TYPE,
            _calculateChangedBits: calculateChangedBits,
            _currentValue: defaultValue,
            _currentValue2: defaultValue,
            _threadCount: 0,
            Provider: null,
            Consumer: null
          };
          context.Provider = {
            $$typeof: REACT_PROVIDER_TYPE,
            _context: context
          };
          var hasWarnedAboutUsingNestedContextConsumers = false;
          var hasWarnedAboutUsingConsumerProvider = false;
          var hasWarnedAboutDisplayNameOnConsumer = false;
          {
            var Consumer2 = {
              $$typeof: REACT_CONTEXT_TYPE,
              _context: context,
              _calculateChangedBits: context._calculateChangedBits
            };
            Object.defineProperties(Consumer2, {
              Provider: {
                get: function() {
                  if (!hasWarnedAboutUsingConsumerProvider) {
                    hasWarnedAboutUsingConsumerProvider = true;
                    error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                  }
                  return context.Provider;
                },
                set: function(_Provider) {
                  context.Provider = _Provider;
                }
              },
              _currentValue: {
                get: function() {
                  return context._currentValue;
                },
                set: function(_currentValue) {
                  context._currentValue = _currentValue;
                }
              },
              _currentValue2: {
                get: function() {
                  return context._currentValue2;
                },
                set: function(_currentValue2) {
                  context._currentValue2 = _currentValue2;
                }
              },
              _threadCount: {
                get: function() {
                  return context._threadCount;
                },
                set: function(_threadCount) {
                  context._threadCount = _threadCount;
                }
              },
              Consumer: {
                get: function() {
                  if (!hasWarnedAboutUsingNestedContextConsumers) {
                    hasWarnedAboutUsingNestedContextConsumers = true;
                    error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                  return context.Consumer;
                }
              },
              displayName: {
                get: function() {
                  return context.displayName;
                },
                set: function(displayName) {
                  if (!hasWarnedAboutDisplayNameOnConsumer) {
                    warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                    hasWarnedAboutDisplayNameOnConsumer = true;
                  }
                }
              }
            });
            context.Consumer = Consumer2;
          }
          {
            context._currentRenderer = null;
            context._currentRenderer2 = null;
          }
          return context;
        }
        var Uninitialized = -1;
        var Pending = 0;
        var Resolved = 1;
        var Rejected = 2;
        function lazyInitializer(payload) {
          if (payload._status === Uninitialized) {
            var ctor = payload._result;
            var thenable = ctor();
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
            thenable.then(function(moduleObject) {
              if (payload._status === Pending) {
                var defaultExport = moduleObject.default;
                {
                  if (defaultExport === void 0) {
                    error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                  }
                }
                var resolved = payload;
                resolved._status = Resolved;
                resolved._result = defaultExport;
              }
            }, function(error2) {
              if (payload._status === Pending) {
                var rejected = payload;
                rejected._status = Rejected;
                rejected._result = error2;
              }
            });
          }
          if (payload._status === Resolved) {
            return payload._result;
          } else {
            throw payload._result;
          }
        }
        function lazy(ctor) {
          var payload = {
            _status: -1,
            _result: ctor
          };
          var lazyType = {
            $$typeof: REACT_LAZY_TYPE,
            _payload: payload,
            _init: lazyInitializer
          };
          {
            var defaultProps2;
            var propTypes;
            Object.defineProperties(lazyType, {
              defaultProps: {
                configurable: true,
                get: function() {
                  return defaultProps2;
                },
                set: function(newDefaultProps) {
                  error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  defaultProps2 = newDefaultProps;
                  Object.defineProperty(lazyType, "defaultProps", {
                    enumerable: true
                  });
                }
              },
              propTypes: {
                configurable: true,
                get: function() {
                  return propTypes;
                },
                set: function(newPropTypes) {
                  error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                  propTypes = newPropTypes;
                  Object.defineProperty(lazyType, "propTypes", {
                    enumerable: true
                  });
                }
              }
            });
          }
          return lazyType;
        }
        function forwardRef5(render2) {
          {
            if (render2 != null && render2.$$typeof === REACT_MEMO_TYPE) {
              error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
            } else if (typeof render2 !== "function") {
              error("forwardRef requires a render function but was given %s.", render2 === null ? "null" : typeof render2);
            } else {
              if (render2.length !== 0 && render2.length !== 2) {
                error("forwardRef render functions accept exactly two parameters: props and ref. %s", render2.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
              }
            }
            if (render2 != null) {
              if (render2.defaultProps != null || render2.propTypes != null) {
                error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
              }
            }
          }
          var elementType = {
            $$typeof: REACT_FORWARD_REF_TYPE,
            render: render2
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (render2.displayName == null) {
                  render2.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        var enableScopeAPI = false;
        function isValidElementType(type2) {
          if (typeof type2 === "string" || typeof type2 === "function") {
            return true;
          }
          if (type2 === exports.Fragment || type2 === exports.Profiler || type2 === REACT_DEBUG_TRACING_MODE_TYPE || type2 === exports.StrictMode || type2 === exports.Suspense || type2 === REACT_SUSPENSE_LIST_TYPE || type2 === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type2 === "object" && type2 !== null) {
            if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_BLOCK_TYPE || type2[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function memo2(type2, compare3) {
          {
            if (!isValidElementType(type2)) {
              error("memo: The first argument must be a component. Instead received: %s", type2 === null ? "null" : typeof type2);
            }
          }
          var elementType = {
            $$typeof: REACT_MEMO_TYPE,
            type: type2,
            compare: compare3 === void 0 ? null : compare3
          };
          {
            var ownName;
            Object.defineProperty(elementType, "displayName", {
              enumerable: false,
              configurable: true,
              get: function() {
                return ownName;
              },
              set: function(name) {
                ownName = name;
                if (type2.displayName == null) {
                  type2.displayName = name;
                }
              }
            });
          }
          return elementType;
        }
        function resolveDispatcher() {
          var dispatcher = ReactCurrentDispatcher.current;
          if (!(dispatcher !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          return dispatcher;
        }
        function useContext5(Context, unstable_observedBits) {
          var dispatcher = resolveDispatcher();
          {
            if (unstable_observedBits !== void 0) {
              error("useContext() second argument is reserved for future use in React. Passing it is not supported. You passed: %s.%s", unstable_observedBits, typeof unstable_observedBits === "number" && Array.isArray(arguments[2]) ? "\n\nDid you call array.map(useContext)? Calling Hooks inside a loop is not supported. Learn more at https://reactjs.org/link/rules-of-hooks" : "");
            }
            if (Context._context !== void 0) {
              var realContext = Context._context;
              if (realContext.Consumer === Context) {
                error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
              } else if (realContext.Provider === Context) {
                error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
              }
            }
          }
          return dispatcher.useContext(Context, unstable_observedBits);
        }
        function useState5(initialState) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useState(initialState);
        }
        function useReducer(reducer, initialArg, init2) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useReducer(reducer, initialArg, init2);
        }
        function useRef7(initialValue) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useRef(initialValue);
        }
        function useEffect6(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useEffect(create, deps);
        }
        function useLayoutEffect4(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useLayoutEffect(create, deps);
        }
        function useCallback6(callback, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useCallback(callback, deps);
        }
        function useMemo5(create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useMemo(create, deps);
        }
        function useImperativeHandle(ref, create, deps) {
          var dispatcher = resolveDispatcher();
          return dispatcher.useImperativeHandle(ref, create, deps);
        }
        function useDebugValue(value, formatterFn) {
          {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDebugValue(value, formatterFn);
          }
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher$1.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component3) {
          var prototype = Component3.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case exports.Suspense:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type2._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              setExtraStackFrame(stack);
            } else {
              setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function getDeclarationErrorAddendum() {
          if (ReactCurrentOwner.current) {
            var name = getComponentName(ReactCurrentOwner.current.type);
            if (name) {
              return "\n\nCheck the render method of `" + name + "`.";
            }
          }
          return "";
        }
        function getSourceInfoErrorAddendum(source) {
          if (source !== void 0) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
        function getSourceInfoErrorAddendumForProps(elementProps) {
          if (elementProps !== null && elementProps !== void 0) {
            return getSourceInfoErrorAddendum(elementProps.__source);
          }
          return "";
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = "\n\nCheck the top-level render call using <" + parentName + ">.";
            }
          }
          return info;
        }
        function validateExplicitKey(element, parentType) {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
            childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
          }
          {
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          if (typeof node !== "object") {
            return;
          }
          if (Array.isArray(node)) {
            for (var i = 0; i < node.length; i++) {
              var child = node[i];
              if (isValidElement2(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement2(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement2(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type2 = element.type;
            if (type2 === null || type2 === void 0 || typeof type2 === "string") {
              return;
            }
            var propTypes;
            if (typeof type2 === "function") {
              propTypes = type2.propTypes;
            } else if (typeof type2 === "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type2.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentName(type2);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentName(type2);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type2.getDefaultProps === "function" && !type2.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys2 = Object.keys(fragment.props);
            for (var i = 0; i < keys2.length; i++) {
              var key = keys2[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function createElementWithValidation(type2, props, children) {
          var validType = isValidElementType(type2);
          if (!validType) {
            var info = "";
            if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
              info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendumForProps(props);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type2 === null) {
              typeString = "null";
            } else if (Array.isArray(type2)) {
              typeString = "array";
            } else if (type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentName(type2.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type2;
            }
            {
              error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
          }
          var element = createElement8.apply(this, arguments);
          if (element == null) {
            return element;
          }
          if (validType) {
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], type2);
            }
          }
          if (type2 === exports.Fragment) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
        var didWarnAboutDeprecatedCreateFactory = false;
        function createFactoryWithValidation(type2) {
          var validatedFactory = createElementWithValidation.bind(null, type2);
          validatedFactory.type = type2;
          {
            if (!didWarnAboutDeprecatedCreateFactory) {
              didWarnAboutDeprecatedCreateFactory = true;
              warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
            }
            Object.defineProperty(validatedFactory, "type", {
              enumerable: false,
              get: function() {
                warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                Object.defineProperty(this, "type", {
                  value: type2
                });
                return type2;
              }
            });
          }
          return validatedFactory;
        }
        function cloneElementWithValidation(element, props, children) {
          var newElement = cloneElement.apply(this, arguments);
          for (var i = 2; i < arguments.length; i++) {
            validateChildKeys(arguments[i], newElement.type);
          }
          validatePropTypes(newElement);
          return newElement;
        }
        {
          try {
            var frozenObject = Object.freeze({});
            /* @__PURE__ */ new Map([[frozenObject, null]]);
            /* @__PURE__ */ new Set([frozenObject]);
          } catch (e) {
          }
        }
        var createElement$1 = createElementWithValidation;
        var cloneElement$1 = cloneElementWithValidation;
        var createFactory = createFactoryWithValidation;
        var Children2 = {
          map: mapChildren,
          forEach: forEachChildren,
          count: countChildren,
          toArray,
          only: onlyChild
        };
        exports.Children = Children2;
        exports.Component = Component2;
        exports.PureComponent = PureComponent;
        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
        exports.cloneElement = cloneElement$1;
        exports.createContext = createContext4;
        exports.createElement = createElement$1;
        exports.createFactory = createFactory;
        exports.createRef = createRef;
        exports.forwardRef = forwardRef5;
        exports.isValidElement = isValidElement2;
        exports.lazy = lazy;
        exports.memo = memo2;
        exports.useCallback = useCallback6;
        exports.useContext = useContext5;
        exports.useDebugValue = useDebugValue;
        exports.useEffect = useEffect6;
        exports.useImperativeHandle = useImperativeHandle;
        exports.useLayoutEffect = useLayoutEffect4;
        exports.useMemo = useMemo5;
        exports.useReducer = useReducer;
        exports.useRef = useRef7;
        exports.useState = useState5;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    "use strict";
    init_react();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/@remix-run/dev/compiler/shims/react.ts
var React;
var init_react = __esm({
  "node_modules/@remix-run/dev/compiler/shims/react.ts"() {
    React = __toESM(require_react());
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    "use strict";
    init_react();
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString(setCookieValue, options) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValue = parts.shift().split("=");
      var name = nameValue.shift();
      var value = nameValue.join("=");
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      try {
        value = options.decodeValues ? decodeURIComponent(value) : value;
      } catch (e) {
        console.error("set-cookie-parser encountered an error while decoding a cookie with value '" + value + "'. Set options.decodeValues to false to disable this feature.", e);
      }
      var cookie = {
        name,
        value
      };
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key = sides.shift().trimLeft().toLowerCase();
        var value2 = sides.join("=");
        if (key === "expires") {
          cookie.expires = new Date(value2);
        } else if (key === "max-age") {
          cookie.maxAge = parseInt(value2, 10);
        } else if (key === "secure") {
          cookie.secure = true;
        } else if (key === "httponly") {
          cookie.httpOnly = true;
        } else if (key === "samesite") {
          cookie.sameSite = value2;
        } else {
          cookie[key] = value2;
        }
      });
      return cookie;
    }
    function parse(input, options) {
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!input) {
        if (!options.map) {
          return [];
        } else {
          return {};
        }
      }
      if (input.headers && input.headers["set-cookie"]) {
        input = input.headers["set-cookie"];
      } else if (input.headers) {
        var sch = input.headers[Object.keys(input.headers).find(function(key) {
          return key.toLowerCase() === "set-cookie";
        })];
        if (!sch && input.headers.cookie && !options.silent) {
          console.warn("Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.");
        }
        input = sch;
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
      if (!options.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString(str, options);
        });
      } else {
        var cookies = {};
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString(str, options);
          cookies2[cookie.name] = cookie;
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module.exports = parse;
    module.exports.parse = parse;
    module.exports.parseString = parseString;
    module.exports.splitCookiesString = splitCookiesString2;
  }
});

// node_modules/@remix-run/server-runtime/node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "node_modules/@remix-run/server-runtime/node_modules/jsesc/jsesc.js"(exports, module) {
    "use strict";
    init_react();
    var object = {};
    var hasOwnProperty2 = object.hasOwnProperty;
    var forOwn = (object2, callback) => {
      for (const key in object2) {
        if (hasOwnProperty2.call(object2, key)) {
          callback(key, object2[key]);
        }
      }
    };
    var extend = (destination, source) => {
      if (!source) {
        return destination;
      }
      forOwn(source, (key, value) => {
        destination[key] = value;
      });
      return destination;
    };
    var forEach2 = (array, callback) => {
      const length = array.length;
      let index2 = -1;
      while (++index2 < length) {
        callback(array[index2]);
      }
    };
    var fourHexEscape = (hex) => {
      return "\\u" + ("0000" + hex).slice(-4);
    };
    var hexadecimal = (code, lowercase) => {
      let hexadecimal2 = code.toString(16);
      if (lowercase)
        return hexadecimal2;
      return hexadecimal2.toUpperCase();
    };
    var toString3 = object.toString;
    var isArray3 = Array.isArray;
    var isBuffer2 = (value) => {
      return typeof Buffer === "function" && Buffer.isBuffer(value);
    };
    var isObject2 = (value) => {
      return toString3.call(value) == "[object Object]";
    };
    var isString2 = (value) => {
      return typeof value == "string" || toString3.call(value) == "[object String]";
    };
    var isNumber2 = (value) => {
      return typeof value == "number" || toString3.call(value) == "[object Number]";
    };
    var isFunction2 = (value) => {
      return typeof value == "function";
    };
    var isMap = (value) => {
      return toString3.call(value) == "[object Map]";
    };
    var isSet = (value) => {
      return toString3.call(value) == "[object Set]";
    };
    var singleEscapes = {
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
    };
    var regexSingleEscape = /[\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
    var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
    var jsesc2 = (argument, options) => {
      const increaseIndentation = () => {
        oldIndent = indent;
        ++options.indentLevel;
        indent = options.indent.repeat(options.indentLevel);
      };
      const defaults2 = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json2 = options && options.json;
      if (json2) {
        defaults2.quotes = "double";
        defaults2.wrap = true;
      }
      options = extend(defaults2, options);
      if (options.quotes != "single" && options.quotes != "double" && options.quotes != "backtick") {
        options.quotes = "single";
      }
      const quote = options.quotes == "double" ? '"' : options.quotes == "backtick" ? "`" : "'";
      const compact = options.compact;
      const lowercaseHex = options.lowercaseHex;
      let indent = options.indent.repeat(options.indentLevel);
      let oldIndent = "";
      const inline1 = options.__inline1__;
      const inline2 = options.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty = true;
      const useBinNumbers = options.numbers == "binary";
      const useOctNumbers = options.numbers == "octal";
      const useDecNumbers = options.numbers == "decimal";
      const useHexNumbers = options.numbers == "hexadecimal";
      if (json2 && argument && isFunction2(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString2(argument)) {
        if (isMap(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options.__inline1__ = true;
            options.__inline2__ = false;
          }
          return "new Map(" + jsesc2(Array.from(argument), options) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc2(Array.from(argument), options) + ")";
        }
        if (isBuffer2(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc2(Array.from(argument), options) + ")";
        }
        if (isArray3(argument)) {
          result = [];
          options.wrap = true;
          if (inline1) {
            options.__inline1__ = false;
            options.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach2(argument, (value) => {
            isEmpty = false;
            if (inline2) {
              options.__inline2__ = false;
            }
            result.push((compact || inline2 ? "" : indent) + jsesc2(value, options));
          });
          if (isEmpty) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber2(argument)) {
          if (json2) {
            return JSON.stringify(argument);
          }
          if (useDecNumbers) {
            return String(argument);
          }
          if (useHexNumbers) {
            let hexadecimal2 = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal2 = hexadecimal2.toUpperCase();
            }
            return "0x" + hexadecimal2;
          }
          if (useBinNumbers) {
            return "0b" + argument.toString(2);
          }
          if (useOctNumbers) {
            return "0o" + argument.toString(8);
          }
        } else if (!isObject2(argument)) {
          if (json2) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options.wrap = true;
          increaseIndentation();
          forOwn(argument, (key, value) => {
            isEmpty = false;
            result.push((compact ? "" : indent) + jsesc2(key, options) + ":" + (compact ? "" : " ") + jsesc2(value, options));
          });
          if (isEmpty) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const regex2 = options.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
      result = argument.replace(regex2, (char, pair, lone, quoteChar, index2, string) => {
        if (pair) {
          if (options.minimal)
            return pair;
          const first = pair.charCodeAt(0);
          const second = pair.charCodeAt(1);
          if (options.es6) {
            const codePoint = (first - 55296) * 1024 + second - 56320 + 65536;
            const hex2 = hexadecimal(codePoint, lowercaseHex);
            return "\\u{" + hex2 + "}";
          }
          return fourHexEscape(hexadecimal(first, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
        }
        if (lone) {
          return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
        }
        if (char == "\0" && !json2 && !regexDigit.test(string.charAt(index2 + 1))) {
          return "\\0";
        }
        if (quoteChar) {
          if (quoteChar == quote || options.escapeEverything) {
            return "\\" + quoteChar;
          }
          return quoteChar;
        }
        if (regexSingleEscape.test(char)) {
          return singleEscapes[char];
        }
        if (options.minimal && !regexWhitespace.test(char)) {
          return char;
        }
        const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
        if (json2 || hex.length > 2) {
          return fourHexEscape(hex);
        }
        return "\\x" + ("00" + hex).slice(-2);
      });
      if (quote == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options.isScriptContext) {
        result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json2 ? "\\u003C!--" : "\\x3C!--");
      }
      if (options.wrap) {
        result = quote + result + quote;
      }
      return result;
    };
    jsesc2.version = "3.0.2";
    module.exports = jsesc2;
  }
});

// node-modules-polyfills:events
function EventHandlers() {
}
function EventEmitter() {
  EventEmitter.init.call(this);
}
function $getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
function emitNone(handler, isFn, self2) {
  if (isFn)
    handler.call(self2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2);
  }
}
function emitOne(handler, isFn, self2, arg1) {
  if (isFn)
    handler.call(self2, arg1);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1);
  }
}
function emitTwo(handler, isFn, self2, arg1, arg2) {
  if (isFn)
    handler.call(self2, arg1, arg2);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2);
  }
}
function emitThree(handler, isFn, self2, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self2, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].call(self2, arg1, arg2, arg3);
  }
}
function emitMany(handler, isFn, self2, args) {
  if (isFn)
    handler.apply(self2, args);
  else {
    var len = handler.length;
    var listeners2 = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners2[i].apply(self2, args);
  }
}
function _addListener(target, type2, listener, prepend) {
  var m;
  var events;
  var existing;
  if (typeof listener !== "function")
    throw new TypeError('"listener" argument must be a function');
  events = target._events;
  if (!events) {
    events = target._events = new EventHandlers();
    target._eventsCount = 0;
  } else {
    if (events.newListener) {
      target.emit("newListener", type2, listener.listener ? listener.listener : listener);
      events = target._events;
    }
    existing = events[type2];
  }
  if (!existing) {
    existing = events[type2] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events[type2] = prepend ? [listener, existing] : [existing, listener];
    } else {
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + type2 + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type2;
        w.count = existing.length;
        emitWarning(w);
      }
    }
  }
  return target;
}
function emitWarning(e) {
  typeof console.warn === "function" ? console.warn(e) : console.log(e);
}
function _onceWrap(target, type2, listener) {
  var fired = false;
  function g() {
    target.removeListener(type2, g);
    if (!fired) {
      fired = true;
      listener.apply(target, arguments);
    }
  }
  g.listener = listener;
  return g;
}
function listenerCount(type2) {
  var events = this._events;
  if (events) {
    var evlistener = events[type2];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }
  return 0;
}
function spliceOne(list, index2) {
  for (var i = index2, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}
function arrayClone(arr, i) {
  var copy2 = new Array(i);
  while (i--)
    copy2[i] = arr[i];
  return copy2;
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
var domain, events_default;
var init_events = __esm({
  "node-modules-polyfills:events"() {
    "use strict";
    init_react();
    EventHandlers.prototype = /* @__PURE__ */ Object.create(null);
    events_default = EventEmitter;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.usingDomains = false;
    EventEmitter.prototype.domain = void 0;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._maxListeners = void 0;
    EventEmitter.defaultMaxListeners = 10;
    EventEmitter.init = function() {
      this.domain = null;
      if (EventEmitter.usingDomains) {
        if (domain.active && !(this instanceof domain.Domain)) {
          this.domain = domain.active;
        }
      }
      if (!this._events || this._events === Object.getPrototypeOf(this)._events) {
        this._events = new EventHandlers();
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || isNaN(n))
        throw new TypeError('"n" argument must be a positive number');
      this._maxListeners = n;
      return this;
    };
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return $getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type2) {
      var er, handler, len, args, i, events, domain2;
      var needDomainExit = false;
      var doError = type2 === "error";
      events = this._events;
      if (events)
        doError = doError && events.error == null;
      else if (!doError)
        return false;
      domain2 = this.domain;
      if (doError) {
        er = arguments[1];
        if (domain2) {
          if (!er)
            er = new Error('Uncaught, unspecified "error" event');
          er.domainEmitter = this;
          er.domain = domain2;
          er.domainThrown = false;
          domain2.emit("error", er);
        } else if (er instanceof Error) {
          throw er;
        } else {
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
          err.context = er;
          throw err;
        }
        return false;
      }
      handler = events[type2];
      if (!handler)
        return false;
      var isFn = typeof handler === "function";
      len = arguments.length;
      switch (len) {
        case 1:
          emitNone(handler, isFn, this);
          break;
        case 2:
          emitOne(handler, isFn, this, arguments[1]);
          break;
        case 3:
          emitTwo(handler, isFn, this, arguments[1], arguments[2]);
          break;
        case 4:
          emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
          break;
        default:
          args = new Array(len - 1);
          for (i = 1; i < len; i++)
            args[i - 1] = arguments[i];
          emitMany(handler, isFn, this, args);
      }
      if (needDomainExit)
        domain2.exit();
      return true;
    };
    EventEmitter.prototype.addListener = function addListener(type2, listener) {
      return _addListener(this, type2, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
      return _addListener(this, type2, listener, true);
    };
    EventEmitter.prototype.once = function once(type2, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.on(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type2, _onceWrap(this, type2, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type2, listener) {
      var list, events, position, i, originalListener;
      if (typeof listener !== "function")
        throw new TypeError('"listener" argument must be a function');
      events = this._events;
      if (!events)
        return this;
      list = events[type2];
      if (!list)
        return this;
      if (list === listener || list.listener && list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = new EventHandlers();
        else {
          delete events[type2];
          if (events.removeListener)
            this.emit("removeListener", type2, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length; i-- > 0; ) {
          if (list[i] === listener || list[i].listener && list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (list.length === 1) {
          list[0] = void 0;
          if (--this._eventsCount === 0) {
            this._events = new EventHandlers();
            return this;
          } else {
            delete events[type2];
          }
        } else {
          spliceOne(list, position);
        }
        if (events.removeListener)
          this.emit("removeListener", type2, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
      var listeners2, events;
      events = this._events;
      if (!events)
        return this;
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = new EventHandlers();
          this._eventsCount = 0;
        } else if (events[type2]) {
          if (--this._eventsCount === 0)
            this._events = new EventHandlers();
          else
            delete events[type2];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys2 = Object.keys(events);
        for (var i = 0, key; i < keys2.length; ++i) {
          key = keys2[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = new EventHandlers();
        this._eventsCount = 0;
        return this;
      }
      listeners2 = events[type2];
      if (typeof listeners2 === "function") {
        this.removeListener(type2, listeners2);
      } else if (listeners2) {
        do {
          this.removeListener(type2, listeners2[listeners2.length - 1]);
        } while (listeners2[0]);
      }
      return this;
    };
    EventEmitter.prototype.listeners = function listeners(type2) {
      var evlistener;
      var ret;
      var events = this._events;
      if (!events)
        ret = [];
      else {
        evlistener = events[type2];
        if (!evlistener)
          ret = [];
        else if (typeof evlistener === "function")
          ret = [evlistener.listener || evlistener];
        else
          ret = unwrapListeners(evlistener);
      }
      return ret;
    };
    EventEmitter.listenerCount = function(emitter, type2) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type2);
      } else {
        return listenerCount.call(emitter, type2);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
    };
  }
});

// node-modules-polyfills:process
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
function noop() {
}
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds, nanoseconds];
}
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var cachedSetTimeout, cachedClearTimeout, queue, draining, currentQueue, queueIndex, title, platform, browser, env, argv, version, versions, release, config, on, addListener2, once2, off, removeListener2, removeAllListeners2, emit2, performance, performanceNow, startTime, browser$1, process_default;
var init_process = __esm({
  "node-modules-polyfills:process"() {
    init_react();
    cachedSetTimeout = defaultSetTimout;
    cachedClearTimeout = defaultClearTimeout;
    if (typeof globalThis.setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    }
    if (typeof globalThis.clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    }
    queue = [];
    draining = false;
    queueIndex = -1;
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    title = "browser";
    platform = "browser";
    browser = true;
    env = {};
    argv = [];
    version = "";
    versions = {};
    release = {};
    config = {};
    on = noop;
    addListener2 = noop;
    once2 = noop;
    off = noop;
    removeListener2 = noop;
    removeAllListeners2 = noop;
    emit2 = noop;
    performance = globalThis.performance || {};
    performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
      return new Date().getTime();
    };
    startTime = new Date();
    browser$1 = {
      nextTick,
      title,
      browser,
      env,
      argv,
      version,
      versions,
      on,
      addListener: addListener2,
      once: once2,
      off,
      removeListener: removeListener2,
      removeAllListeners: removeAllListeners2,
      emit: emit2,
      binding,
      cwd,
      chdir,
      umask,
      hrtime,
      platform,
      release,
      config,
      uptime
    };
    process_default = browser$1;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js
var inherits, inherits_default;
var init_inherits = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/inherits.js"() {
    init_react();
    if (typeof Object.create === "function") {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      inherits = function inherits2(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    inherits_default = inherits;
  }
});

// node-modules-polyfills:util
function format(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(" ");
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x2) {
    if (x2 === "%%")
      return "%";
    if (i >= len)
      return x2;
    switch (x2) {
      case "%s":
        return String(args[i++]);
      case "%d":
        return Number(args[i++]);
      case "%j":
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return "[Circular]";
        }
      default:
        return x2;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += " " + x;
    } else {
      str += " " + inspect(x);
    }
  }
  return str;
}
function deprecate(fn, msg) {
  if (isUndefined(globalThis.process)) {
    return function() {
      return deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process_default.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process_default.throwDeprecation) {
        throw new Error(msg);
      } else if (process_default.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}
function debuglog(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process_default.env.NODE_DEBUG || "";
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
      var pid = 0;
      debugs[set] = function() {
        var msg = format.apply(null, arguments);
        console.error("%s %d: %s", set, pid, msg);
      };
    } else {
      debugs[set] = function() {
      };
    }
  }
  return debugs[set];
}
function inspect(obj, opts) {
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  if (arguments.length >= 3)
    ctx.depth = arguments[2];
  if (arguments.length >= 4)
    ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    ctx.showHidden = opts;
  } else if (opts) {
    _extend(ctx, opts);
  }
  if (isUndefined(ctx.showHidden))
    ctx.showHidden = false;
  if (isUndefined(ctx.depth))
    ctx.depth = 2;
  if (isUndefined(ctx.colors))
    ctx.colors = false;
  if (isUndefined(ctx.customInspect))
    ctx.customInspect = true;
  if (ctx.colors)
    ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function(val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== inspect && !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }
  var keys2 = Object.keys(value);
  var visibleKeys = arrayToHash(keys2);
  if (ctx.showHidden) {
    keys2 = Object.getOwnPropertyNames(value);
  }
  if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
    return formatError(value);
  }
  if (keys2.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ": " + value.name : "";
      return ctx.stylize("[Function" + name + "]", "special");
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), "date");
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = "", array = false, braces = ["{", "}"];
  if (isArray(value)) {
    array = true;
    braces = ["[", "]"];
  }
  if (isFunction(value)) {
    var n = value.name ? ": " + value.name : "";
    base = " [Function" + n + "]";
  }
  if (isRegExp(value)) {
    base = " " + RegExp.prototype.toString.call(value);
  }
  if (isDate(value)) {
    base = " " + Date.prototype.toUTCString.call(value);
  }
  if (isError(value)) {
    base = " " + formatError(value);
  }
  if (keys2.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
    } else {
      return ctx.stylize("[Object]", "special");
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
  } else {
    output = keys2.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize("undefined", "undefined");
  if (isString(value)) {
    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
    return ctx.stylize(simple, "string");
  }
  if (isNumber(value))
    return ctx.stylize("" + value, "number");
  if (isBoolean(value))
    return ctx.stylize("" + value, "boolean");
  if (isNull(value))
    return ctx.stylize("null", "null");
}
function formatError(value) {
  return "[" + Error.prototype.toString.call(value) + "]";
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push("");
    }
  }
  keys2.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize("[Getter/Setter]", "special");
    } else {
      str = ctx.stylize("[Getter]", "special");
    }
  } else {
    if (desc.set) {
      str = ctx.stylize("[Setter]", "special");
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = "[" + key + "]";
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf("\n") > -1) {
        if (array) {
          str = str.split("\n").map(function(line) {
            return "  " + line;
          }).join("\n").substr(2);
        } else {
          str = "\n" + str.split("\n").map(function(line) {
            return "   " + line;
          }).join("\n");
        }
      }
    } else {
      str = ctx.stylize("[Circular]", "special");
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify("" + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, "name");
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, "string");
    }
  }
  return name + ": " + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf("\n") >= 0)
      numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
  }
  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
}
function isArray(ar) {
  return Array.isArray(ar);
}
function isBoolean(arg) {
  return typeof arg === "boolean";
}
function isNull(arg) {
  return arg === null;
}
function isNumber(arg) {
  return typeof arg === "number";
}
function isString(arg) {
  return typeof arg === "string";
}
function isUndefined(arg) {
  return arg === void 0;
}
function isRegExp(re) {
  return isObject(re) && objectToString(re) === "[object RegExp]";
}
function isObject(arg) {
  return typeof arg === "object" && arg !== null;
}
function isDate(d) {
  return isObject(d) && objectToString(d) === "[object Date]";
}
function isError(e) {
  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
}
function isFunction(arg) {
  return typeof arg === "function";
}
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function _extend(origin, add) {
  if (!add || !isObject(add))
    return origin;
  var keys2 = Object.keys(add);
  var i = keys2.length;
  while (i--) {
    origin[keys2[i]] = add[keys2[i]];
  }
  return origin;
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var formatRegExp, debugs, debugEnviron;
var init_util = __esm({
  "node-modules-polyfills:util"() {
    init_react();
    init_process();
    init_inherits();
    formatRegExp = /%[sdj%]/g;
    debugs = {};
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
  }
});

// node-modules-polyfills:buffer
function init() {
  inited = true;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
}
function toByteArray(b64) {
  if (!inited) {
    init();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  placeHolders = b64[len - 2] === "=" ? 2 : b64[len - 1] === "=" ? 1 : 0;
  arr = new Arr(len * 3 / 4 - placeHolders);
  l = placeHolders > 0 ? len - 4 : len;
  var L = 0;
  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = tmp >> 16 & 255;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  if (placeHolders === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[L++] = tmp & 255;
  } else if (placeHolders === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[L++] = tmp >> 8 & 255;
    arr[L++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  if (!inited) {
    init();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var output = "";
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[tmp << 4 & 63];
    output += "==";
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    output += lookup[tmp >> 10];
    output += lookup[tmp >> 4 & 63];
    output += lookup[tmp << 2 & 63];
    output += "=";
  }
  parts.push(output);
  return parts.join("");
}
function read(buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
function write(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer[offset + i - d] |= s * 128;
}
function kMaxLength() {
  return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError("Invalid typed array length");
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = new Uint8Array(length);
    that.__proto__ = Buffer2.prototype;
  } else {
    if (that === null) {
      that = new Buffer2(length);
    }
    that.length = length;
  }
  return that;
}
function Buffer2(arg, encodingOrOffset, length) {
  if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
    return new Buffer2(arg, encodingOrOffset, length);
  }
  if (typeof arg === "number") {
    if (typeof encodingOrOffset === "string") {
      throw new Error("If encoding is specified then the first argument must be a string");
    }
    return allocUnsafe(this, arg);
  }
  return from(this, arg, encodingOrOffset, length);
}
function from(that, value, encodingOrOffset, length) {
  if (typeof value === "number") {
    throw new TypeError('"value" argument must not be a number');
  }
  if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }
  if (typeof value === "string") {
    return fromString(that, value, encodingOrOffset);
  }
  return fromObject(that, value);
}
function assertSize(size) {
  if (typeof size !== "number") {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}
function alloc(that, size, fill2, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size);
  }
  if (fill2 !== void 0) {
    return typeof encoding === "string" ? createBuffer(that, size).fill(fill2, encoding) : createBuffer(that, size).fill(fill2);
  }
  return createBuffer(that, size);
}
function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer2.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that;
}
function fromString(that, string, encoding) {
  if (typeof encoding !== "string" || encoding === "") {
    encoding = "utf8";
  }
  if (!Buffer2.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }
  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);
  if (actual !== length) {
    that = that.slice(0, actual);
  }
  return that;
}
function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that;
}
function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength;
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError("'offset' is out of bounds");
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError("'length' is out of bounds");
  }
  if (byteOffset === void 0 && length === void 0) {
    array = new Uint8Array(array);
  } else if (length === void 0) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    that = array;
    that.__proto__ = Buffer2.prototype;
  } else {
    that = fromArrayLike(that, array);
  }
  return that;
}
function fromObject(that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);
    if (that.length === 0) {
      return that;
    }
    obj.copy(that, 0, 0, len);
    return that;
  }
  if (obj) {
    if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
      if (typeof obj.length !== "number" || isnan(obj.length)) {
        return createBuffer(that, 0);
      }
      return fromArrayLike(that, obj);
    }
    if (obj.type === "Buffer" && isArray2(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function checked(length) {
  if (length >= kMaxLength()) {
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
  }
  return length | 0;
}
function internalIsBuffer(b) {
  return !!(b != null && b._isBuffer);
}
function byteLength(string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length;
  }
  if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== "string") {
    string = "" + string;
  }
  var len = string.length;
  if (len === 0)
    return 0;
  var loweredCase = false;
  for (; ; ) {
    switch (encoding) {
      case "ascii":
      case "latin1":
      case "binary":
        return len;
      case "utf8":
      case "utf-8":
      case void 0:
        return utf8ToBytes(string).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return len * 2;
      case "hex":
        return len >>> 1;
      case "base64":
        return base64ToBytes(string).length;
      default:
        if (loweredCase)
          return utf8ToBytes(string).length;
        encoding = ("" + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
function slowToString(encoding, start, end) {
  var loweredCase = false;
  if (start === void 0 || start < 0) {
    start = 0;
  }
  if (start > this.length) {
    return "";
  }
  if (end === void 0 || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return "";
  }
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return "";
  }
  if (!encoding)
    encoding = "utf8";
  while (true) {
    switch (encoding) {
      case "hex":
        return hexSlice(this, start, end);
      case "utf8":
      case "utf-8":
        return utf8Slice(this, start, end);
      case "ascii":
        return asciiSlice(this, start, end);
      case "latin1":
      case "binary":
        return latin1Slice(this, start, end);
      case "base64":
        return base64Slice(this, start, end);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase)
          throw new TypeError("Unknown encoding: " + encoding);
        encoding = (encoding + "").toLowerCase();
        loweredCase = true;
    }
  }
}
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  if (buffer.length === 0)
    return -1;
  if (typeof byteOffset === "string") {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 2147483647) {
    byteOffset = 2147483647;
  } else if (byteOffset < -2147483648) {
    byteOffset = -2147483648;
  }
  byteOffset = +byteOffset;
  if (isNaN(byteOffset)) {
    byteOffset = dir ? 0 : buffer.length - 1;
  }
  if (byteOffset < 0)
    byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir)
      return -1;
    else
      byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir)
      byteOffset = 0;
    else
      return -1;
  }
  if (typeof val === "string") {
    val = Buffer2.from(val, encoding);
  }
  if (internalIsBuffer(val)) {
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === "number") {
    val = val & 255;
    if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError("val must be string, number or Buffer");
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== void 0) {
    encoding = String(encoding).toLowerCase();
    if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read2(buf, i2) {
    if (indexSize === 1) {
      return buf[i2];
    } else {
      return buf.readUInt16BE(i2 * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1)
          foundIndex = i;
        if (i - foundIndex + 1 === valLength)
          return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1)
          i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength)
      byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read2(arr, i + j) !== read2(val, j)) {
          found = false;
          break;
        }
      }
      if (found)
        return i;
    }
  }
  return -1;
}
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (strLen % 2 !== 0)
    throw new TypeError("Invalid hex string");
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed))
      return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf);
  } else {
    return fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  var res = "";
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 127);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = "";
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0)
    start = 0;
  if (!end || end < 0 || end > len)
    end = len;
  var out = "";
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = "";
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0)
    throw new RangeError("offset is not uint");
  if (offset + ext > length)
    throw new RangeError("Trying to access beyond buffer length");
}
function checkInt(buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min)
    throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
}
function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 65535 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}
function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0)
    value = 4294967295 + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
  }
}
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length)
    throw new RangeError("Index out of range");
  if (offset < 0)
    throw new RangeError("Index out of range");
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
function base64clean(str) {
  str = stringtrim(str).replace(INVALID_BASE64_RE, "");
  if (str.length < 2)
    return "";
  while (str.length % 4 !== 0) {
    str = str + "=";
  }
  return str;
}
function stringtrim(str) {
  if (str.trim)
    return str.trim();
  return str.replace(/^\s+|\s+$/g, "");
}
function toHex(n) {
  if (n < 16)
    return "0" + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        } else if (i + 1 === length) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    byteArray.push(str.charCodeAt(i) & 255);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0)
      break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length)
      break;
    dst[i + offset] = src[i];
  }
  return i;
}
function isnan(val) {
  return val !== val;
}
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
}
function isFastBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
}
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isFastBuffer(obj.slice(0, 0));
}
var lookup, revLookup, Arr, inited, toString, isArray2, INSPECT_MAX_BYTES, _kMaxLength, MAX_ARGUMENTS_LENGTH, INVALID_BASE64_RE;
var init_buffer = __esm({
  "node-modules-polyfills:buffer"() {
    init_react();
    lookup = [];
    revLookup = [];
    Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    inited = false;
    toString = {}.toString;
    isArray2 = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
    INSPECT_MAX_BYTES = 50;
    Buffer2.TYPED_ARRAY_SUPPORT = globalThis.TYPED_ARRAY_SUPPORT !== void 0 ? globalThis.TYPED_ARRAY_SUPPORT : true;
    _kMaxLength = kMaxLength();
    Buffer2.poolSize = 8192;
    Buffer2._augment = function(arr) {
      arr.__proto__ = Buffer2.prototype;
      return arr;
    };
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length);
    };
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      Buffer2.prototype.__proto__ = Uint8Array.prototype;
      Buffer2.__proto__ = Uint8Array;
    }
    Buffer2.alloc = function(size, fill2, encoding) {
      return alloc(null, size, fill2, encoding);
    };
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(null, size);
    };
    Buffer2.isBuffer = isBuffer;
    Buffer2.compare = function compare(a, b) {
      if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (a === b)
        return 0;
      var x = a.length;
      var y = b.length;
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!isArray2(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      var i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      var buffer = Buffer2.allocUnsafe(length);
      var pos = 0;
      for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (!internalIsBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        buf.copy(buffer, pos);
        pos += buf.length;
      }
      return buffer;
    };
    Buffer2.byteLength = byteLength;
    Buffer2.prototype._isBuffer = true;
    Buffer2.prototype.swap16 = function swap16() {
      var len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      var len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      var len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString2() {
      var length = this.length | 0;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.equals = function equals(b) {
      if (!internalIsBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect2() {
      var str = "";
      var max = INSPECT_MAX_BYTES;
      if (this.length > 0) {
        str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
        if (this.length > max)
          str += " ... ";
      }
      return "<Buffer " + str + ">";
    };
    Buffer2.prototype.compare = function compare2(target, start, end, thisStart, thisEnd) {
      if (!internalIsBuffer(target)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    Buffer2.prototype.write = function write2(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset | 0;
        if (isFinite(length)) {
          length = length | 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      var remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      var loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
            return asciiWrite(this, string, offset, length);
          case "latin1":
          case "binary":
            return latin1Write(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    MAX_ARGUMENTS_LENGTH = 4096;
    Buffer2.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      var newBuf;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end);
        newBuf.__proto__ = Buffer2.prototype;
      } else {
        var sliceLen = end - start;
        newBuf = new Buffer2(sliceLen, void 0);
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      var val = this[offset + --byteLength2];
      var mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      var i = byteLength2;
      var mul = 1;
      var val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return read(this, offset, false, 52, 8);
    };
    Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var mul = 1;
      var i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      byteLength2 = byteLength2 | 0;
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      var i = byteLength2 - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (!Buffer2.TYPED_ARRAY_SUPPORT)
        value = Math.floor(value);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
      } else {
        objectWriteUInt16(this, value, offset, true);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
      } else {
        objectWriteUInt16(this, value, offset, false);
      }
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
      } else {
        objectWriteUInt32(this, value, offset, true);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset | 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      if (Buffer2.TYPED_ARRAY_SUPPORT) {
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
      } else {
        objectWriteUInt32(this, value, offset, false);
      }
      return offset + 4;
    };
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("sourceStart out of bounds");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      var len = end - start;
      var i;
      if (this === target && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0);
          if (code < 256) {
            val = code;
          }
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else if (typeof val === "number") {
        val = val & 255;
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      var i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
        var len = bytes.length;
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js
function BufferList() {
  this.head = null;
  this.tail = null;
  this.length = 0;
}
var buffer_list_default;
var init_buffer_list = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/buffer-list.js"() {
    init_react();
    init_buffer();
    buffer_list_default = BufferList;
    BufferList.prototype.push = function(v) {
      var entry2 = { data: v, next: null };
      if (this.length > 0)
        this.tail.next = entry2;
      else
        this.head = entry2;
      this.tail = entry2;
      ++this.length;
    };
    BufferList.prototype.unshift = function(v) {
      var entry2 = { data: v, next: this.head };
      if (this.length === 0)
        this.tail = entry2;
      this.head = entry2;
      ++this.length;
    };
    BufferList.prototype.shift = function() {
      if (this.length === 0)
        return;
      var ret = this.head.data;
      if (this.length === 1)
        this.head = this.tail = null;
      else
        this.head = this.head.next;
      --this.length;
      return ret;
    };
    BufferList.prototype.clear = function() {
      this.head = this.tail = null;
      this.length = 0;
    };
    BufferList.prototype.join = function(s) {
      if (this.length === 0)
        return "";
      var p = this.head;
      var ret = "" + p.data;
      while (p = p.next) {
        ret += s + p.data;
      }
      return ret;
    };
    BufferList.prototype.concat = function(n) {
      if (this.length === 0)
        return Buffer2.alloc(0);
      if (this.length === 1)
        return this.head.data;
      var ret = Buffer2.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        p.data.copy(ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    };
  }
});

// node-modules-polyfills:string_decoder
function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error("Unknown encoding: " + encoding);
  }
}
function StringDecoder(encoding) {
  this.encoding = (encoding || "utf8").toLowerCase().replace(/[-_]/, "");
  assertEncoding(encoding);
  switch (this.encoding) {
    case "utf8":
      this.surrogateSize = 3;
      break;
    case "ucs2":
    case "utf16le":
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case "base64":
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }
  this.charBuffer = new Buffer2(6);
  this.charReceived = 0;
  this.charLength = 0;
}
function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}
function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}
function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}
var isBufferEncoding;
var init_string_decoder = __esm({
  "node-modules-polyfills:string_decoder"() {
    init_react();
    init_buffer();
    isBufferEncoding = Buffer2.isEncoding || function(encoding) {
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    StringDecoder.prototype.write = function(buffer) {
      var charStr = "";
      while (this.charLength) {
        var available = buffer.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : buffer.length;
        buffer.copy(this.charBuffer, this.charReceived, 0, available);
        this.charReceived += available;
        if (this.charReceived < this.charLength) {
          return "";
        }
        buffer = buffer.slice(available, buffer.length);
        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
        var charCode = charStr.charCodeAt(charStr.length - 1);
        if (charCode >= 55296 && charCode <= 56319) {
          this.charLength += this.surrogateSize;
          charStr = "";
          continue;
        }
        this.charReceived = this.charLength = 0;
        if (buffer.length === 0) {
          return charStr;
        }
        break;
      }
      this.detectIncompleteChar(buffer);
      var end = buffer.length;
      if (this.charLength) {
        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
        end -= this.charReceived;
      }
      charStr += buffer.toString(this.encoding, 0, end);
      var end = charStr.length - 1;
      var charCode = charStr.charCodeAt(end);
      if (charCode >= 55296 && charCode <= 56319) {
        var size = this.surrogateSize;
        this.charLength += size;
        this.charReceived += size;
        this.charBuffer.copy(this.charBuffer, size, 0, size);
        buffer.copy(this.charBuffer, 0, 0, size);
        return charStr.substring(0, end);
      }
      return charStr;
    };
    StringDecoder.prototype.detectIncompleteChar = function(buffer) {
      var i = buffer.length >= 3 ? 3 : buffer.length;
      for (; i > 0; i--) {
        var c = buffer[buffer.length - i];
        if (i == 1 && c >> 5 == 6) {
          this.charLength = 2;
          break;
        }
        if (i <= 2 && c >> 4 == 14) {
          this.charLength = 3;
          break;
        }
        if (i <= 3 && c >> 3 == 30) {
          this.charLength = 4;
          break;
        }
      }
      this.charReceived = i;
    };
    StringDecoder.prototype.end = function(buffer) {
      var res = "";
      if (buffer && buffer.length)
        res = this.write(buffer);
      if (this.charReceived) {
        var cr = this.charReceived;
        var buf = this.charBuffer;
        var enc = this.encoding;
        res += buf.slice(0, cr).toString(enc);
      }
      return res;
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js
function prependListener2(emitter, event, fn) {
  if (typeof emitter.prependListener === "function") {
    return emitter.prependListener(event, fn);
  } else {
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
}
function listenerCount2(emitter, type2) {
  return emitter.listeners(type2).length;
}
function ReadableState(options, stream) {
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.buffer = new buffer_list_default();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;
  this.sync = true;
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.ranOut = false;
  this.awaitDrain = 0;
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);
  this._readableState = new ReadableState(options, this);
  this.readable = true;
  if (options && typeof options.read === "function")
    this._read = options.read;
  events_default.call(this);
}
function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit("error", er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error("stream.push() after EOF");
      stream.emit("error", e);
    } else if (state.endEmitted && addToFront) {
      var _e = new Error("stream.unshift() after end event");
      stream.emit("error", _e);
    } else {
      var skipAdd;
      if (state.decoder && !addToFront && !encoding) {
        chunk = state.decoder.write(chunk);
        skipAdd = !state.objectMode && chunk.length === 0;
      }
      if (!addToFront)
        state.reading = false;
      if (!skipAdd) {
        if (state.flowing && state.length === 0 && !state.sync) {
          stream.emit("data", chunk);
          stream.read(0);
        } else {
          state.length += state.objectMode ? 1 : chunk.length;
          if (addToFront)
            state.buffer.unshift(chunk);
          else
            state.buffer.push(chunk);
          if (state.needReadable)
            emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }
  return needMoreData(state);
}
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended)
    return 0;
  if (state.objectMode)
    return 1;
  if (n !== n) {
    if (state.flowing && state.length)
      return state.buffer.head.data.length;
    else
      return state.length;
  }
  if (n > state.highWaterMark)
    state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length)
    return n;
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}
function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) && typeof chunk !== "string" && chunk !== null && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  return er;
}
function onEofChunk(stream, state) {
  if (state.ended)
    return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  emitReadable(stream);
}
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug("emitReadable", state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      nextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug("emit readable");
  stream.emit("readable");
  flow(stream);
}
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug("maybeReadMore read 0");
    stream.read(0);
    if (len === state.length)
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}
function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug("pipeOnDrain", state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && src.listeners("data").length) {
      state.flowing = true;
      flow(src);
    }
  };
}
function nReadingNextTick(self2) {
  debug("readable nexttick read 0");
  self2.read(0);
}
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug("resume read 0");
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit("resume");
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}
function flow(stream) {
  var state = stream._readableState;
  debug("flow", state.flowing);
  while (state.flowing && stream.read() !== null) {
  }
}
function fromList(n, state) {
  if (state.length === 0)
    return null;
  var ret;
  if (state.objectMode)
    ret = state.buffer.shift();
  else if (!n || n >= state.length) {
    if (state.decoder)
      ret = state.buffer.join("");
    else if (state.buffer.length === 1)
      ret = state.buffer.head.data;
    else
      ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
}
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    ret = list.shift();
  } else {
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length)
      ret += str;
    else
      ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next)
          list.head = p.next;
        else
          list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  if (state.length > 0)
    throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit("end");
  }
}
function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
function indexOf2(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x)
      return i;
  }
  return -1;
}
var debug, MAX_HWM;
var init_readable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/readable.js"() {
    "use strict";
    init_react();
    init_events();
    init_util();
    init_buffer_list();
    init_string_decoder();
    init_duplex();
    init_process();
    Readable.ReadableState = ReadableState;
    debug = debuglog("stream");
    inherits_default(Readable, events_default);
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      if (!state.objectMode && typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = "";
        }
      }
      return readableAddChunk(this, state, chunk, encoding, false);
    };
    Readable.prototype.unshift = function(chunk) {
      var state = this._readableState;
      return readableAddChunk(this, state, chunk, "", true);
    };
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    MAX_HWM = 8388608;
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = !pipeOpts || pipeOpts.end !== false;
      var endFn = doEnd ? onend2 : cleanup;
      if (state.endEmitted)
        nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable) {
        debug("onunpipe");
        if (readable === src) {
          cleanup();
        }
      }
      function onend2() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend2);
        src.removeListener("end", cleanup);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf2(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (listenerCount2(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener2(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var _i = 0; _i < len; _i++) {
          dests[_i].emit("unpipe", this);
        }
        return this;
      }
      var i = indexOf2(state.pipes, dest);
      if (i === -1)
        return this;
      state.pipes.splice(i, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = events_default.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this, state);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    Readable.prototype.wrap = function(stream) {
      var state = this._readableState;
      var paused = false;
      var self2 = this;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            self2.push(chunk);
        }
        self2.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = self2.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      var events = ["error", "close", "destroy", "pause", "resume"];
      forEach(events, function(ev) {
        stream.on(ev, self2.emit.bind(self2, ev));
      });
      self2._read = function(n) {
        debug("wrapped _read", n);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return self2;
    };
    Readable._fromList = fromList;
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js
function nop() {
}
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}
function WritableState(options, stream) {
  Object.defineProperty(this, "buffer", {
    get: deprecate(function() {
      return this.getBuffer();
    }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.")
  });
  options = options || {};
  this.objectMode = !!options.objectMode;
  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
  this.highWaterMark = ~~this.highWaterMark;
  this.needDrain = false;
  this.ending = false;
  this.ended = false;
  this.finished = false;
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;
  this.defaultEncoding = options.defaultEncoding || "utf8";
  this.length = 0;
  this.writing = false;
  this.corked = 0;
  this.sync = true;
  this.bufferProcessing = false;
  this.onwrite = function(er) {
    onwrite(stream, er);
  };
  this.writecb = null;
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;
  this.pendingcb = 0;
  this.prefinished = false;
  this.errorEmitted = false;
  this.bufferedRequestCount = 0;
  this.corkedRequestsFree = new CorkedRequest(this);
}
function Writable(options) {
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);
  this._writableState = new WritableState(options, this);
  this.writable = true;
  if (options) {
    if (typeof options.write === "function")
      this._write = options.write;
    if (typeof options.writev === "function")
      this._writev = options.writev;
  }
  EventEmitter.call(this);
}
function writeAfterEnd(stream, cb) {
  var er = new Error("write after end");
  stream.emit("error", er);
  nextTick(cb, er);
}
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError("May not write null values to stream");
  } else if (!Buffer2.isBuffer(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
    er = new TypeError("Invalid non-string/buffer chunk");
  }
  if (er) {
    stream.emit("error", er);
    nextTick(cb, er);
    valid = false;
  }
  return valid;
}
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
    chunk = Buffer2.from(chunk, encoding);
  }
  return chunk;
}
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer2.isBuffer(chunk))
    encoding = "buffer";
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  if (!ret)
    state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    nextTick(cb, er);
  else
    cb(er);
  stream._writableState.errorEmitted = true;
  stream.emit("error", er);
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit("drain");
  }
}
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry2 = state.bufferedRequest;
  if (stream._writev && entry2 && entry2.next) {
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry2;
    var count2 = 0;
    while (entry2) {
      buffer[count2] = entry2;
      entry2 = entry2.next;
      count2 += 1;
    }
    doWrite(stream, state, true, state.length, buffer, "", holder.finish);
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    while (entry2) {
      var chunk = entry2.chunk;
      var encoding = entry2.encoding;
      var cb = entry2.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry2 = entry2.next;
      if (state.writing) {
        break;
      }
    }
    if (entry2 === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry2;
  state.bufferProcessing = false;
}
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit("prefinish");
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit("finish");
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      nextTick(cb);
    else
      stream.once("finish", cb);
  }
  state.ended = true;
  stream.writable = false;
}
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function(err) {
    var entry2 = _this.entry;
    _this.entry = null;
    while (entry2) {
      var cb = entry2.callback;
      state.pendingcb--;
      cb(err);
      entry2 = entry2.next;
    }
    if (state.corkedRequestsFree) {
      state.corkedRequestsFree.next = _this;
    } else {
      state.corkedRequestsFree = _this;
    }
  };
}
var init_writable = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/writable.js"() {
    init_react();
    init_util();
    init_buffer();
    init_events();
    init_duplex();
    init_process();
    Writable.WritableState = WritableState;
    inherits_default(Writable, EventEmitter);
    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (Buffer2.isBuffer(chunk))
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js
function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false)
    this.readable = false;
  if (options && options.writable === false)
    this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;
  this.once("end", onend);
}
function onend() {
  if (this.allowHalfOpen || this._writableState.ended)
    return;
  nextTick(onEndNT, this);
}
function onEndNT(self2) {
  self2.end();
}
var keys, method, v;
var init_duplex = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/duplex.js"() {
    init_react();
    init_util();
    init_process();
    init_readable();
    init_writable();
    inherits_default(Duplex, Readable);
    keys = Object.keys(Writable.prototype);
    for (v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js
function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };
  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}
function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb)
    return stream.emit("error", new Error("no writecb in Transform class"));
  ts.writechunk = null;
  ts.writecb = null;
  if (data !== null && data !== void 0)
    stream.push(data);
  cb(er);
  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);
  Duplex.call(this, options);
  this._transformState = new TransformState(this);
  var stream = this;
  this._readableState.needReadable = true;
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === "function")
      this._transform = options.transform;
    if (typeof options.flush === "function")
      this._flush = options.flush;
  }
  this.once("prefinish", function() {
    if (typeof this._flush === "function")
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}
function done(stream, er) {
  if (er)
    return stream.emit("error", er);
  var ws = stream._writableState;
  var ts = stream._transformState;
  if (ws.length)
    throw new Error("Calling transform done when ws.length != 0");
  if (ts.transforming)
    throw new Error("Calling transform done when still transforming");
  return stream.push(null);
}
var init_transform = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/transform.js"() {
    init_react();
    init_duplex();
    init_util();
    inherits_default(Transform, Duplex);
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("Not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
  }
});

// node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js
function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);
  Transform.call(this, options);
}
var init_passthrough = __esm({
  "node_modules/rollup-plugin-node-polyfills/polyfills/readable-stream/passthrough.js"() {
    init_react();
    init_transform();
    init_util();
    inherits_default(PassThrough, Transform);
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node-modules-polyfills:stream
var stream_exports = {};
__export(stream_exports, {
  Duplex: () => Duplex,
  PassThrough: () => PassThrough,
  Readable: () => Readable,
  Stream: () => Stream,
  Transform: () => Transform,
  Writable: () => Writable,
  default: () => stream_default
});
function Stream() {
  events_default.call(this);
}
var stream_default;
var init_stream = __esm({
  "node-modules-polyfills:stream"() {
    init_react();
    init_events();
    init_util();
    init_duplex();
    init_readable();
    init_writable();
    init_transform();
    init_passthrough();
    inherits_default(Stream, events_default);
    Stream.Readable = Readable;
    Stream.Writable = Writable;
    Stream.Duplex = Duplex;
    Stream.Transform = Transform;
    Stream.PassThrough = PassThrough;
    Stream.Stream = Stream;
    stream_default = Stream;
    Stream.prototype.pipe = function(dest, options) {
      var source = this;
      function ondata(chunk) {
        if (dest.writable) {
          if (dest.write(chunk) === false && source.pause) {
            source.pause();
          }
        }
      }
      source.on("data", ondata);
      function ondrain() {
        if (source.readable && source.resume) {
          source.resume();
        }
      }
      dest.on("drain", ondrain);
      if (!dest._isStdio && (!options || options.end !== false)) {
        source.on("end", onend2);
        source.on("close", onclose);
      }
      var didOnEnd = false;
      function onend2() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        dest.end();
      }
      function onclose() {
        if (didOnEnd)
          return;
        didOnEnd = true;
        if (typeof dest.destroy === "function")
          dest.destroy();
      }
      function onerror(er) {
        cleanup();
        if (events_default.listenerCount(this, "error") === 0) {
          throw er;
        }
      }
      source.on("error", onerror);
      dest.on("error", onerror);
      function cleanup() {
        source.removeListener("data", ondata);
        dest.removeListener("drain", ondrain);
        source.removeListener("end", onend2);
        source.removeListener("close", onclose);
        source.removeListener("error", onerror);
        dest.removeListener("error", onerror);
        source.removeListener("end", cleanup);
        source.removeListener("close", cleanup);
        dest.removeListener("close", cleanup);
      }
      source.on("end", cleanup);
      source.on("close", cleanup);
      dest.on("close", cleanup);
      dest.emit("pipe", source);
      return dest;
    };
  }
});

// node-modules-polyfills-commonjs:stream
var require_stream = __commonJS({
  "node-modules-polyfills-commonjs:stream"(exports, module) {
    init_react();
    var polyfill = (init_stream(), __toCommonJS(stream_exports));
    if (polyfill && polyfill.default) {
      module.exports = polyfill.default;
      for (let k in polyfill) {
        module.exports[k] = polyfill[k];
      }
    } else if (polyfill) {
      module.exports = polyfill;
    }
  }
});

// node_modules/react-dom/cjs/react-dom-server.node.development.js
var require_react_dom_server_node_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.node.development.js"(exports) {
    "use strict";
    init_react();
    if (true) {
      (function() {
        "use strict";
        var React11 = require_react();
        var _assign = require_object_assign();
        var stream = require_stream();
        var ReactVersion = "17.0.2";
        function formatProdErrorMessage(code) {
          var url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code;
          for (var i2 = 1; i2 < arguments.length; i2++) {
            url += "&args[]=" + encodeURIComponent(arguments[i2]);
          }
          return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        var ReactSharedInternals = React11.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn(format2) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format2, args);
          }
        }
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentName(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type2;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type2;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type2.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type2._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentName(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var enableSuspenseServerRenderer = false;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type2._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        }
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function maskContext(type2, context) {
          var contextTypes = type2.contextTypes;
          if (!contextTypes) {
            return emptyObject;
          }
          var maskedContext = {};
          for (var contextName in contextTypes) {
            maskedContext[contextName] = context[contextName];
          }
          return maskedContext;
        }
        function checkContextTypes(typeSpecs, values, location2) {
          {
            checkPropTypes(typeSpecs, values, location2, "Component");
          }
        }
        function validateContextBounds(context, threadID) {
          for (var i2 = context._threadCount | 0; i2 <= threadID; i2++) {
            context[i2] = context._currentValue2;
            context._threadCount = i2 + 1;
          }
        }
        function processContext(type2, context, threadID, isClass) {
          if (isClass) {
            var contextType = type2.contextType;
            {
              if ("contextType" in type2) {
                var isValid = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid && !didWarnAboutInvalidateContextType.has(type2)) {
                  didWarnAboutInvalidateContextType.add(type2);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(type2) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              validateContextBounds(contextType, threadID);
              return contextType[threadID];
            }
            {
              var maskedContext = maskContext(type2, context);
              {
                if (type2.contextTypes) {
                  checkContextTypes(type2.contextTypes, maskedContext, "context");
                }
              }
              return maskedContext;
            }
          } else {
            {
              var _maskedContext = maskContext(type2, context);
              {
                if (type2.contextTypes) {
                  checkContextTypes(type2.contextTypes, _maskedContext, "context");
                }
              }
              return _maskedContext;
            }
          }
        }
        var nextAvailableThreadIDs = new Uint16Array(16);
        for (var i = 0; i < 15; i++) {
          nextAvailableThreadIDs[i] = i + 1;
        }
        nextAvailableThreadIDs[15] = 0;
        function growThreadCountAndReturnNextAvailable() {
          var oldArray = nextAvailableThreadIDs;
          var oldSize = oldArray.length;
          var newSize = oldSize * 2;
          if (!(newSize <= 65536)) {
            {
              throw Error("Maximum number of concurrent React renderers exceeded. This can happen if you are not properly destroying the Readable provided by React. Ensure that you call .destroy() on it if you no longer want to read from it, and did not read to the end. If you use .pipe() this should be automatic.");
            }
          }
          var newArray = new Uint16Array(newSize);
          newArray.set(oldArray);
          nextAvailableThreadIDs = newArray;
          nextAvailableThreadIDs[0] = oldSize + 1;
          for (var _i = oldSize; _i < newSize - 1; _i++) {
            nextAvailableThreadIDs[_i] = _i + 1;
          }
          nextAvailableThreadIDs[newSize - 1] = 0;
          return oldSize;
        }
        function allocThreadID() {
          var nextID = nextAvailableThreadIDs[0];
          if (nextID === 0) {
            return growThreadCountAndReturnNextAvailable();
          }
          nextAvailableThreadIDs[0] = nextAvailableThreadIDs[nextID];
          return nextID;
        }
        function freeThreadID(id) {
          nextAvailableThreadIDs[id] = nextAvailableThreadIDs[0];
          nextAvailableThreadIDs[0] = id;
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var ROOT_ATTRIBUTE_NAME = "data-reactroot";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix2 = name.toLowerCase().slice(0, 5);
                return prefix2 !== "data-" && prefix2 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name) {
          return properties.hasOwnProperty(name) ? properties[name] : null;
        }
        function PropertyInfoRecord(name, type2, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type2 === BOOLEANISH_STRING || type2 === BOOLEAN || type2 === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name;
          this.type = type2;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name = _ref[0], attributeName = _ref[1];
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
        });
        [
          "allowFullScreen",
          "async",
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          "itemScope"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
        });
        [
          "checked",
          "multiple",
          "muted",
          "selected"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
        });
        [
          "capture",
          "download"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
        });
        [
          "cols",
          "rows",
          "size",
          "span"
        ].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
        });
        ["rowSpan", "start"].forEach(function(name) {
          properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize = function(token) {
          return token[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
        ].forEach(function(attributeName) {
          var name = attributeName.replace(CAMELIZE, capitalize);
          properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml(string) {
          var str = "" + string;
          var match = matchHtmlRegExp.exec(str);
          if (!match) {
            return str;
          }
          var escape;
          var html = "";
          var index2;
          var lastIndex = 0;
          for (index2 = match.index; index2 < str.length; index2++) {
            switch (str.charCodeAt(index2)) {
              case 34:
                escape = "&quot;";
                break;
              case 38:
                escape = "&amp;";
                break;
              case 39:
                escape = "&#x27;";
                break;
              case 60:
                escape = "&lt;";
                break;
              case 62:
                escape = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index2) {
              html += str.substring(lastIndex, index2);
            }
            lastIndex = index2 + 1;
            html += escape;
          }
          return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
        }
        function escapeTextForBrowser(text) {
          if (typeof text === "boolean" || typeof text === "number") {
            return "" + text;
          }
          return escapeHtml(text);
        }
        function quoteAttributeValueForBrowser(value) {
          return '"' + escapeTextForBrowser(value) + '"';
        }
        function createMarkupForRoot() {
          return ROOT_ATTRIBUTE_NAME + '=""';
        }
        function createMarkupForProperty(name, value) {
          var propertyInfo = getPropertyInfo(name);
          if (name !== "style" && shouldIgnoreAttribute(name, propertyInfo, false)) {
            return "";
          }
          if (shouldRemoveAttribute(name, value, propertyInfo, false)) {
            return "";
          }
          if (propertyInfo !== null) {
            var attributeName = propertyInfo.attributeName;
            var type2 = propertyInfo.type;
            if (type2 === BOOLEAN || type2 === OVERLOADED_BOOLEAN && value === true) {
              return attributeName + '=""';
            } else {
              if (propertyInfo.sanitizeURL) {
                value = "" + value;
                sanitizeURL(value);
              }
              return attributeName + "=" + quoteAttributeValueForBrowser(value);
            }
          } else if (isAttributeNameSafe(name)) {
            return name + "=" + quoteAttributeValueForBrowser(value);
          }
          return "";
        }
        function createMarkupForCustomAttribute(name, value) {
          if (!isAttributeNameSafe(name) || value == null) {
            return "";
          }
          return name + "=" + quoteAttributeValueForBrowser(value);
        }
        function is(x, y) {
          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is;
        var currentlyRenderingComponent = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (!(currentlyRenderingComponent !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          {
            if (isInHookUserCodeInDev) {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i2 = 0; i2 < prevDeps.length && i2 < nextDeps.length; i2++) {
            if (objectIs(nextDeps[i2], prevDeps[i2])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            {
              {
                throw Error("Rendered more hooks than during the previous render");
              }
            }
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          {
            isInHookUserCodeInDev = false;
          }
        }
        function finishHooks(Component2, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component2(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext(context, observedBits) {
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          {
            if (isInHookUserCodeInDev) {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return context[threadID];
        }
        function useContext5(context, observedBits) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          return context[threadID];
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState5(initialState) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer(basicStateReducer, initialState);
        }
        function useReducer(reducer, initialArg, init2) {
          {
            if (reducer !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue2 = workInProgressHook.queue;
            var dispatch = queue2.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue2);
                var newState = workInProgressHook.memoizedState;
                var update = firstRenderPhaseUpdate;
                do {
                  var action = update.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update = update.next;
                } while (update !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState;
            if (reducer === basicStateReducer) {
              initialState = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState = init2 !== void 0 ? init2(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo5(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef7(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref = {
              current: initialValue
            };
            {
              Object.seal(ref);
            }
            workInProgressHook.memoizedState = ref;
            return ref;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect4(create, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue2, action) {
          if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
            {
              throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = /* @__PURE__ */ new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue2);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue2, update);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update;
            }
          }
        }
        function useCallback6(callback, deps) {
          return useMemo5(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function useTransition2() {
          resolveCurrentlyRenderingComponent();
          var startTransition = function(callback) {
            callback();
          };
          return [startTransition, false];
        }
        function useOpaqueIdentifier() {
          return (currentPartialRenderer.identifierPrefix || "") + "R:" + (currentPartialRenderer.uniqueID++).toString(36);
        }
        function noop2() {
        }
        var currentPartialRenderer = null;
        function setCurrentPartialRenderer(renderer) {
          currentPartialRenderer = renderer;
        }
        var Dispatcher = {
          readContext,
          useContext: useContext5,
          useMemo: useMemo5,
          useReducer,
          useRef: useRef7,
          useState: useState5,
          useLayoutEffect: useLayoutEffect4,
          useCallback: useCallback6,
          useImperativeHandle: noop2,
          useEffect: noop2,
          useDebugValue: noop2,
          useDeferredValue,
          useTransition: useTransition2,
          useOpaqueIdentifier,
          useMutableSource
        };
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        var Namespaces = {
          html: HTML_NAMESPACE,
          mathml: MATH_NAMESPACE,
          svg: SVG_NAMESPACE
        };
        function getIntrinsicNamespace(type2) {
          switch (type2) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type2) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type2);
          }
          if (parentNamespace === SVG_NAMESPACE && type2 === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
        };
        var voidElementTags = _assign({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props) {
          if (!props) {
            return;
          }
          if (voidElementTags[tag]) {
            if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
              {
                throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
          }
          if (props.dangerouslySetInnerHTML != null) {
            if (!(props.children == null)) {
              {
                throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
            }
            if (!(typeof props.dangerouslySetInnerHTML === "object" && HTML in props.dangerouslySetInnerHTML)) {
              {
                throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
          }
          {
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (!(props.style == null || typeof props.style === "object")) {
            {
              throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
        }
        var isUnitlessNumber = {
          animationIterationCount: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix2, key) {
          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes.forEach(function(prefix2) {
            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name, value, isCustomProperty) {
          var isEmpty = value == null || typeof value === "boolean" || value === "";
          if (isEmpty) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
            return value + "px";
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name) {
          return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string) {
            return string.replace(hyphenPattern, function(_, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern$1, "ms-")));
          };
          var warnBadVendoredStyleName = function(name) {
            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
              return;
            }
            warnedStyleNames[name] = true;
            error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error("`NaN` is an invalid value for the `%s` css style property.", name);
          };
          var warnStyleValueIsInfinity = function(name, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error("`Infinity` is an invalid value for the `%s` css style property.", name);
          };
          warnValidStyle = function(name, value) {
            if (name.indexOf("-") > -1) {
              warnHyphenatedStyleName(name);
            } else if (badVendoredStyleNamePattern.test(name)) {
              warnBadVendoredStyleName(name);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var ariaProperties = {
          "aria-current": 0,
          "aria-details": 0,
          "aria-disabled": 0,
          "aria-hidden": 0,
          "aria-invalid": 0,
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
        function validateProperty(tagName, name) {
          {
            if (hasOwnProperty$1.call(warnedProperties, name) && warnedProperties[name]) {
              return true;
            }
            if (rARIACamel.test(name)) {
              var ariaName = "aria-" + name.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
                warnedProperties[name] = true;
                return true;
              }
              if (name !== correctName) {
                error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
                warnedProperties[name] = true;
                return true;
              }
            }
            if (rARIA.test(name)) {
              var lowerCasedName = name.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name] = true;
                return false;
              }
              if (name !== standardName) {
                error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties[name] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type2, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid = validateProperty(type2, key);
              if (!isValid) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
            } else if (invalidProps.length > 1) {
              error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type2);
            }
          }
        }
        function validateProperties(type2, props) {
          if (isCustomComponent(type2, props)) {
            return;
          }
          warnInvalidARIAProps(type2, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type2, props) {
          {
            if (type2 !== "input" && type2 !== "textarea" && type2 !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type2 === "select" && props.multiple) {
                error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type2);
              } else {
                error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type2);
              }
            }
          }
        }
        var possibleStandardNames = {
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name, value, eventRegistry) {
            if (_hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
              return true;
            }
            var lowerCasedName = name.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
                warnedProperties$1[name] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name)) {
                error("Unknown event handler property `%s`. It will be ignored.", name);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name)) {
              if (INVALID_EVENT_NAME_REGEX.test(name)) {
                error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name);
              warnedProperties$1[name] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name) {
                error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
                warnedProperties$1[name] = true;
                return true;
              }
            } else if (!isReserved && name !== lowerCasedName) {
              error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name, lowerCasedName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              if (value) {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name, name, value, name);
              } else {
                error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);
              }
              warnedProperties$1[name] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
              warnedProperties$1[name] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
              warnedProperties$1[name] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type2, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid = validateProperty$1(type2, key, props[key], eventRegistry);
              if (!isValid) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
            } else if (unknownProps.length > 1) {
              error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type2);
            }
          }
        };
        function validateProperties$2(type2, props, eventRegistry) {
          if (isCustomComponent(type2, props)) {
            return;
          }
          warnUnknownProperties(type2, props, eventRegistry);
        }
        var toArray = React11.Children.toArray;
        var currentDebugStacks = [];
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1;
        var prevGetCurrentStackImpl = null;
        var getCurrentServerStackImpl = function() {
          return "";
        };
        var describeStackFrame = function(element) {
          return "";
        };
        var validatePropertiesInDevelopment = function(type2, props) {
        };
        var pushCurrentDebugStack = function(stack) {
        };
        var pushElementToDebugStack = function(element) {
        };
        var popCurrentDebugStack = function() {
        };
        var hasWarnedAboutUsingContextAsConsumer = false;
        {
          ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          validatePropertiesInDevelopment = function(type2, props) {
            validateProperties(type2, props);
            validateProperties$1(type2, props);
            validateProperties$2(type2, props, null);
          };
          describeStackFrame = function(element) {
            return describeUnknownElementTypeFrameInDEV(element.type, element._source, null);
          };
          pushCurrentDebugStack = function(stack) {
            currentDebugStacks.push(stack);
            if (currentDebugStacks.length === 1) {
              prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
              ReactDebugCurrentFrame$1.getCurrentStack = getCurrentServerStackImpl;
            }
          };
          pushElementToDebugStack = function(element) {
            var stack = currentDebugStacks[currentDebugStacks.length - 1];
            var frame = stack[stack.length - 1];
            frame.debugElementStack.push(element);
          };
          popCurrentDebugStack = function() {
            currentDebugStacks.pop();
            if (currentDebugStacks.length === 0) {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
              prevGetCurrentStackImpl = null;
            }
          };
          getCurrentServerStackImpl = function() {
            if (currentDebugStacks.length === 0) {
              return "";
            }
            var frames = currentDebugStacks[currentDebugStacks.length - 1];
            var stack = "";
            for (var i2 = frames.length - 1; i2 >= 0; i2--) {
              var frame = frames[i2];
              var debugElementStack = frame.debugElementStack;
              for (var ii = debugElementStack.length - 1; ii >= 0; ii--) {
                stack += describeStackFrame(debugElementStack[ii]);
              }
            }
            return stack;
          };
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUndefinedDerivedState = {};
        var didWarnAboutUninitializedState = {};
        var valuePropNames = ["value", "defaultValue"];
        var newlineEatingTags = {
          listing: true,
          pre: true,
          textarea: true
        };
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = {};
        function validateDangerousTag(tag) {
          if (!validatedTagCache.hasOwnProperty(tag)) {
            if (!VALID_TAG_REGEX.test(tag)) {
              {
                throw Error("Invalid tag: " + tag);
              }
            }
            validatedTagCache[tag] = true;
          }
        }
        var styleNameCache = {};
        var processStyleName = function(styleName) {
          if (styleNameCache.hasOwnProperty(styleName)) {
            return styleNameCache[styleName];
          }
          var result = hyphenateStyleName(styleName);
          styleNameCache[styleName] = result;
          return result;
        };
        function createMarkupForStyles(styles2) {
          var serialized = "";
          var delimiter = "";
          for (var styleName in styles2) {
            if (!styles2.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            var styleValue = styles2[styleName];
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styleValue);
              }
            }
            if (styleValue != null) {
              serialized += delimiter + (isCustomProperty ? styleName : processStyleName(styleName)) + ":";
              serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
              delimiter = ";";
            }
          }
          return serialized || null;
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentName(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        function shouldConstruct$1(Component2) {
          return Component2.prototype && Component2.prototype.isReactComponent;
        }
        function getNonChildrenInnerMarkup(props) {
          var innerHTML = props.dangerouslySetInnerHTML;
          if (innerHTML != null) {
            if (innerHTML.__html != null) {
              return innerHTML.__html;
            }
          } else {
            var content = props.children;
            if (typeof content === "string" || typeof content === "number") {
              return escapeTextForBrowser(content);
            }
          }
          return null;
        }
        function flattenTopLevelChildren(children) {
          if (!React11.isValidElement(children)) {
            return toArray(children);
          }
          var element = children;
          if (element.type !== REACT_FRAGMENT_TYPE) {
            return [element];
          }
          var fragmentChildren = element.props.children;
          if (!React11.isValidElement(fragmentChildren)) {
            return toArray(fragmentChildren);
          }
          var fragmentChildElement = fragmentChildren;
          return [fragmentChildElement];
        }
        function flattenOptionChildren(children) {
          if (children === void 0 || children === null) {
            return children;
          }
          var content = "";
          React11.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error("Only strings and numbers are supported as <option> children.");
              }
            }
          });
          return content;
        }
        var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
        var STYLE = "style";
        var RESERVED_PROPS = {
          children: null,
          dangerouslySetInnerHTML: null,
          suppressContentEditableWarning: null,
          suppressHydrationWarning: null
        };
        function createOpenTagMarkup(tagVerbatim, tagLowercase, props, namespace, makeStaticMarkup, isRootElement) {
          var ret = "<" + tagVerbatim;
          var isCustomComponent$1 = isCustomComponent(tagLowercase, props);
          for (var propKey in props) {
            if (!hasOwnProperty$2.call(props, propKey)) {
              continue;
            }
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            if (propKey === STYLE) {
              propValue = createMarkupForStyles(propValue);
            }
            var markup = null;
            if (isCustomComponent$1) {
              if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                markup = createMarkupForCustomAttribute(propKey, propValue);
              }
            } else {
              markup = createMarkupForProperty(propKey, propValue);
            }
            if (markup) {
              ret += " " + markup;
            }
          }
          if (makeStaticMarkup) {
            return ret;
          }
          if (isRootElement) {
            ret += " " + createMarkupForRoot();
          }
          return ret;
        }
        function validateRenderResult(child, type2) {
          if (child === void 0) {
            {
              {
                throw Error((getComponentName(type2) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
              }
            }
          }
        }
        function resolve(child, context, threadID) {
          while (React11.isValidElement(child)) {
            var element = child;
            var Component2 = element.type;
            {
              pushElementToDebugStack(element);
            }
            if (typeof Component2 !== "function") {
              break;
            }
            processChild(element, Component2);
          }
          function processChild(element2, Component3) {
            var isClass = shouldConstruct$1(Component3);
            var publicContext = processContext(Component3, context, threadID, isClass);
            var queue2 = [];
            var replace = false;
            var updater = {
              isMounted: function(publicInstance) {
                return false;
              },
              enqueueForceUpdate: function(publicInstance) {
                if (queue2 === null) {
                  warnNoop(publicInstance, "forceUpdate");
                  return null;
                }
              },
              enqueueReplaceState: function(publicInstance, completeState) {
                replace = true;
                queue2 = [completeState];
              },
              enqueueSetState: function(publicInstance, currentPartialState) {
                if (queue2 === null) {
                  warnNoop(publicInstance, "setState");
                  return null;
                }
                queue2.push(currentPartialState);
              }
            };
            var inst;
            if (isClass) {
              inst = new Component3(element2.props, publicContext, updater);
              if (typeof Component3.getDerivedStateFromProps === "function") {
                {
                  if (inst.state === null || inst.state === void 0) {
                    var componentName = getComponentName(Component3) || "Unknown";
                    if (!didWarnAboutUninitializedState[componentName]) {
                      error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, inst.state === null ? "null" : "undefined", componentName);
                      didWarnAboutUninitializedState[componentName] = true;
                    }
                  }
                }
                var partialState = Component3.getDerivedStateFromProps.call(null, element2.props, inst.state);
                {
                  if (partialState === void 0) {
                    var _componentName = getComponentName(Component3) || "Unknown";
                    if (!didWarnAboutUndefinedDerivedState[_componentName]) {
                      error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", _componentName);
                      didWarnAboutUndefinedDerivedState[_componentName] = true;
                    }
                  }
                }
                if (partialState != null) {
                  inst.state = _assign({}, inst.state, partialState);
                }
              }
            } else {
              {
                if (Component3.prototype && typeof Component3.prototype.render === "function") {
                  var _componentName2 = getComponentName(Component3) || "Unknown";
                  if (!didWarnAboutBadClass[_componentName2]) {
                    error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", _componentName2, _componentName2);
                    didWarnAboutBadClass[_componentName2] = true;
                  }
                }
              }
              var componentIdentity = {};
              prepareToUseHooks(componentIdentity);
              inst = Component3(element2.props, publicContext, updater);
              inst = finishHooks(Component3, element2.props, inst, publicContext);
              {
                if (inst != null && inst.render != null) {
                  var _componentName3 = getComponentName(Component3) || "Unknown";
                  if (!didWarnAboutModulePatternComponent[_componentName3]) {
                    error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName3, _componentName3, _componentName3);
                    didWarnAboutModulePatternComponent[_componentName3] = true;
                  }
                }
              }
              if (inst == null || inst.render == null) {
                child = inst;
                validateRenderResult(child, Component3);
                return;
              }
            }
            inst.props = element2.props;
            inst.context = publicContext;
            inst.updater = updater;
            var initialState = inst.state;
            if (initialState === void 0) {
              inst.state = initialState = null;
            }
            if (typeof inst.UNSAFE_componentWillMount === "function" || typeof inst.componentWillMount === "function") {
              if (typeof inst.componentWillMount === "function") {
                {
                  if (inst.componentWillMount.__suppressDeprecationWarning !== true) {
                    var _componentName4 = getComponentName(Component3) || "Unknown";
                    if (!didWarnAboutDeprecatedWillMount[_componentName4]) {
                      warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s", _componentName4);
                      didWarnAboutDeprecatedWillMount[_componentName4] = true;
                    }
                  }
                }
                if (typeof Component3.getDerivedStateFromProps !== "function") {
                  inst.componentWillMount();
                }
              }
              if (typeof inst.UNSAFE_componentWillMount === "function" && typeof Component3.getDerivedStateFromProps !== "function") {
                inst.UNSAFE_componentWillMount();
              }
              if (queue2.length) {
                var oldQueue = queue2;
                var oldReplace = replace;
                queue2 = null;
                replace = false;
                if (oldReplace && oldQueue.length === 1) {
                  inst.state = oldQueue[0];
                } else {
                  var nextState = oldReplace ? oldQueue[0] : inst.state;
                  var dontMutate = true;
                  for (var i2 = oldReplace ? 1 : 0; i2 < oldQueue.length; i2++) {
                    var partial = oldQueue[i2];
                    var _partialState = typeof partial === "function" ? partial.call(inst, nextState, element2.props, publicContext) : partial;
                    if (_partialState != null) {
                      if (dontMutate) {
                        dontMutate = false;
                        nextState = _assign({}, nextState, _partialState);
                      } else {
                        _assign(nextState, _partialState);
                      }
                    }
                  }
                  inst.state = nextState;
                }
              } else {
                queue2 = null;
              }
            }
            child = inst.render();
            {
              if (child === void 0 && inst.render._isMockFunction) {
                child = null;
              }
            }
            validateRenderResult(child, Component3);
            var childContext;
            {
              if (typeof inst.getChildContext === "function") {
                var _childContextTypes = Component3.childContextTypes;
                if (typeof _childContextTypes === "object") {
                  childContext = inst.getChildContext();
                  for (var contextKey in childContext) {
                    if (!(contextKey in _childContextTypes)) {
                      {
                        throw Error((getComponentName(Component3) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                      }
                    }
                  }
                } else {
                  {
                    error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", getComponentName(Component3) || "Unknown");
                  }
                }
              }
              if (childContext) {
                context = _assign({}, context, childContext);
              }
            }
          }
          return {
            child,
            context
          };
        }
        var ReactDOMServerRenderer = /* @__PURE__ */ function() {
          function ReactDOMServerRenderer2(children, makeStaticMarkup, options) {
            var flatChildren = flattenTopLevelChildren(children);
            var topFrame = {
              type: null,
              domNamespace: Namespaces.html,
              children: flatChildren,
              childIndex: 0,
              context: emptyObject,
              footer: ""
            };
            {
              topFrame.debugElementStack = [];
            }
            this.threadID = allocThreadID();
            this.stack = [topFrame];
            this.exhausted = false;
            this.currentSelectValue = null;
            this.previousWasTextNode = false;
            this.makeStaticMarkup = makeStaticMarkup;
            this.suspenseDepth = 0;
            this.contextIndex = -1;
            this.contextStack = [];
            this.contextValueStack = [];
            this.uniqueID = 0;
            this.identifierPrefix = options && options.identifierPrefix || "";
            {
              this.contextProviderStack = [];
            }
          }
          var _proto = ReactDOMServerRenderer2.prototype;
          _proto.destroy = function destroy() {
            if (!this.exhausted) {
              this.exhausted = true;
              this.clearProviders();
              freeThreadID(this.threadID);
            }
          };
          _proto.pushProvider = function pushProvider(provider) {
            var index2 = ++this.contextIndex;
            var context = provider.type._context;
            var threadID = this.threadID;
            validateContextBounds(context, threadID);
            var previousValue = context[threadID];
            this.contextStack[index2] = context;
            this.contextValueStack[index2] = previousValue;
            {
              this.contextProviderStack[index2] = provider;
            }
            context[threadID] = provider.props.value;
          };
          _proto.popProvider = function popProvider(provider) {
            var index2 = this.contextIndex;
            {
              if (index2 < 0 || provider !== this.contextProviderStack[index2]) {
                error("Unexpected pop.");
              }
            }
            var context = this.contextStack[index2];
            var previousValue = this.contextValueStack[index2];
            this.contextStack[index2] = null;
            this.contextValueStack[index2] = null;
            {
              this.contextProviderStack[index2] = null;
            }
            this.contextIndex--;
            context[this.threadID] = previousValue;
          };
          _proto.clearProviders = function clearProviders() {
            for (var index2 = this.contextIndex; index2 >= 0; index2--) {
              var context = this.contextStack[index2];
              var previousValue = this.contextValueStack[index2];
              context[this.threadID] = previousValue;
            }
          };
          _proto.read = function read2(bytes) {
            if (this.exhausted) {
              return null;
            }
            var prevPartialRenderer = currentPartialRenderer;
            setCurrentPartialRenderer(this);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = Dispatcher;
            try {
              var out = [""];
              var suspended = false;
              while (out[0].length < bytes) {
                if (this.stack.length === 0) {
                  this.exhausted = true;
                  freeThreadID(this.threadID);
                  break;
                }
                var frame = this.stack[this.stack.length - 1];
                if (suspended || frame.childIndex >= frame.children.length) {
                  var footer = frame.footer;
                  if (footer !== "") {
                    this.previousWasTextNode = false;
                  }
                  this.stack.pop();
                  if (frame.type === "select") {
                    this.currentSelectValue = null;
                  } else if (frame.type != null && frame.type.type != null && frame.type.type.$$typeof === REACT_PROVIDER_TYPE) {
                    var provider = frame.type;
                    this.popProvider(provider);
                  } else if (frame.type === REACT_SUSPENSE_TYPE) {
                    this.suspenseDepth--;
                    var buffered = out.pop();
                    if (suspended) {
                      suspended = false;
                      var fallbackFrame = frame.fallbackFrame;
                      if (!fallbackFrame) {
                        {
                          throw Error(true ? "ReactDOMServer did not find an internal fallback frame for Suspense. This is a bug in React. Please file an issue." : formatProdErrorMessage(303));
                        }
                      }
                      this.stack.push(fallbackFrame);
                      out[this.suspenseDepth] += "<!--$!-->";
                      continue;
                    } else {
                      out[this.suspenseDepth] += buffered;
                    }
                  }
                  out[this.suspenseDepth] += footer;
                  continue;
                }
                var child = frame.children[frame.childIndex++];
                var outBuffer = "";
                if (true) {
                  pushCurrentDebugStack(this.stack);
                  frame.debugElementStack.length = 0;
                }
                try {
                  outBuffer += this.render(child, frame.context, frame.domNamespace);
                } catch (err) {
                  if (err != null && typeof err.then === "function") {
                    if (enableSuspenseServerRenderer) {
                      if (!(this.suspenseDepth > 0)) {
                        {
                          throw Error(true ? "A React component suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." : formatProdErrorMessage(342));
                        }
                      }
                      suspended = true;
                    } else {
                      if (true) {
                        {
                          throw Error(true ? "ReactDOMServer does not yet support Suspense." : formatProdErrorMessage(294));
                        }
                      }
                    }
                  } else {
                    throw err;
                  }
                } finally {
                  if (true) {
                    popCurrentDebugStack();
                  }
                }
                if (out.length <= this.suspenseDepth) {
                  out.push("");
                }
                out[this.suspenseDepth] += outBuffer;
              }
              return out[0];
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
              setCurrentPartialRenderer(prevPartialRenderer);
              resetHooksState();
            }
          };
          _proto.render = function render2(child, context, parentNamespace) {
            if (typeof child === "string" || typeof child === "number") {
              var text = "" + child;
              if (text === "") {
                return "";
              }
              if (this.makeStaticMarkup) {
                return escapeTextForBrowser(text);
              }
              if (this.previousWasTextNode) {
                return "<!-- -->" + escapeTextForBrowser(text);
              }
              this.previousWasTextNode = true;
              return escapeTextForBrowser(text);
            } else {
              var nextChild;
              var _resolve = resolve(child, context, this.threadID);
              nextChild = _resolve.child;
              context = _resolve.context;
              if (nextChild === null || nextChild === false) {
                return "";
              } else if (!React11.isValidElement(nextChild)) {
                if (nextChild != null && nextChild.$$typeof != null) {
                  var $$typeof = nextChild.$$typeof;
                  if (!($$typeof !== REACT_PORTAL_TYPE)) {
                    {
                      throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                    }
                  }
                  {
                    {
                      throw Error("Unknown element-like object type: " + $$typeof.toString() + ". This is likely a bug in React. Please file an issue.");
                    }
                  }
                }
                var nextChildren = toArray(nextChild);
                var frame = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: nextChildren,
                  childIndex: 0,
                  context,
                  footer: ""
                };
                {
                  frame.debugElementStack = [];
                }
                this.stack.push(frame);
                return "";
              }
              var nextElement = nextChild;
              var elementType = nextElement.type;
              if (typeof elementType === "string") {
                return this.renderDOM(nextElement, context, parentNamespace);
              }
              switch (elementType) {
                case REACT_LEGACY_HIDDEN_TYPE:
                case REACT_DEBUG_TRACING_MODE_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_FRAGMENT_TYPE: {
                  var _nextChildren = toArray(nextChild.props.children);
                  var _frame = {
                    type: null,
                    domNamespace: parentNamespace,
                    children: _nextChildren,
                    childIndex: 0,
                    context,
                    footer: ""
                  };
                  {
                    _frame.debugElementStack = [];
                  }
                  this.stack.push(_frame);
                  return "";
                }
                case REACT_SUSPENSE_TYPE: {
                  {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support Suspense.");
                      }
                    }
                  }
                }
                case REACT_SCOPE_TYPE: {
                  {
                    {
                      throw Error("ReactDOMServer does not yet support scope components.");
                    }
                  }
                }
              }
              if (typeof elementType === "object" && elementType !== null) {
                switch (elementType.$$typeof) {
                  case REACT_FORWARD_REF_TYPE: {
                    var element = nextChild;
                    var _nextChildren5;
                    var componentIdentity = {};
                    prepareToUseHooks(componentIdentity);
                    _nextChildren5 = elementType.render(element.props, element.ref);
                    _nextChildren5 = finishHooks(elementType.render, element.props, _nextChildren5, element.ref);
                    _nextChildren5 = toArray(_nextChildren5);
                    var _frame5 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren5,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame5.debugElementStack = [];
                    }
                    this.stack.push(_frame5);
                    return "";
                  }
                  case REACT_MEMO_TYPE: {
                    var _element = nextChild;
                    var _nextChildren6 = [React11.createElement(elementType.type, _assign({
                      ref: _element.ref
                    }, _element.props))];
                    var _frame6 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren6,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame6.debugElementStack = [];
                    }
                    this.stack.push(_frame6);
                    return "";
                  }
                  case REACT_PROVIDER_TYPE: {
                    var provider = nextChild;
                    var nextProps = provider.props;
                    var _nextChildren7 = toArray(nextProps.children);
                    var _frame7 = {
                      type: provider,
                      domNamespace: parentNamespace,
                      children: _nextChildren7,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame7.debugElementStack = [];
                    }
                    this.pushProvider(provider);
                    this.stack.push(_frame7);
                    return "";
                  }
                  case REACT_CONTEXT_TYPE: {
                    var reactContext = nextChild.type;
                    {
                      if (reactContext._context === void 0) {
                        if (reactContext !== reactContext.Consumer) {
                          if (!hasWarnedAboutUsingContextAsConsumer) {
                            hasWarnedAboutUsingContextAsConsumer = true;
                            error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                          }
                        }
                      } else {
                        reactContext = reactContext._context;
                      }
                    }
                    var _nextProps = nextChild.props;
                    var threadID = this.threadID;
                    validateContextBounds(reactContext, threadID);
                    var nextValue = reactContext[threadID];
                    var _nextChildren8 = toArray(_nextProps.children(nextValue));
                    var _frame8 = {
                      type: nextChild,
                      domNamespace: parentNamespace,
                      children: _nextChildren8,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame8.debugElementStack = [];
                    }
                    this.stack.push(_frame8);
                    return "";
                  }
                  case REACT_FUNDAMENTAL_TYPE: {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support the fundamental API.");
                      }
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var _element2 = nextChild;
                    var lazyComponent = nextChild.type;
                    var payload = lazyComponent._payload;
                    var init2 = lazyComponent._init;
                    var result = init2(payload);
                    var _nextChildren10 = [React11.createElement(result, _assign({
                      ref: _element2.ref
                    }, _element2.props))];
                    var _frame10 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren10,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame10.debugElementStack = [];
                    }
                    this.stack.push(_frame10);
                    return "";
                  }
                }
              }
              var info = "";
              {
                var owner = nextElement._owner;
                if (elementType === void 0 || typeof elementType === "object" && elementType !== null && Object.keys(elementType).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var ownerName = owner ? getComponentName(owner) : null;
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
              }
              {
                {
                  throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (elementType == null ? elementType : typeof elementType) + "." + info);
                }
              }
            }
          };
          _proto.renderDOM = function renderDOM(element, context, parentNamespace) {
            var tag = element.type.toLowerCase();
            var namespace = parentNamespace;
            if (parentNamespace === Namespaces.html) {
              namespace = getIntrinsicNamespace(tag);
            }
            {
              if (namespace === Namespaces.html) {
                if (tag !== element.type) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", element.type);
                }
              }
            }
            validateDangerousTag(tag);
            var props = element.props;
            if (tag === "input") {
              {
                checkControlledValueProps("input", props);
                if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
                  error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultChecked = true;
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
                  error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultInputValue = true;
                }
              }
              props = _assign({
                type: void 0
              }, props, {
                defaultChecked: void 0,
                defaultValue: void 0,
                value: props.value != null ? props.value : props.defaultValue,
                checked: props.checked != null ? props.checked : props.defaultChecked
              });
            } else if (tag === "textarea") {
              {
                checkControlledValueProps("textarea", props);
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
                  error("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultTextareaValue = true;
                }
              }
              var initialValue = props.value;
              if (initialValue == null) {
                var defaultValue = props.defaultValue;
                var textareaChildren = props.children;
                if (textareaChildren != null) {
                  {
                    error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                  }
                  if (!(defaultValue == null)) {
                    {
                      throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                    }
                  }
                  if (Array.isArray(textareaChildren)) {
                    if (!(textareaChildren.length <= 1)) {
                      {
                        throw Error("<textarea> can only have at most one child.");
                      }
                    }
                    textareaChildren = textareaChildren[0];
                  }
                  defaultValue = "" + textareaChildren;
                }
                if (defaultValue == null) {
                  defaultValue = "";
                }
                initialValue = defaultValue;
              }
              props = _assign({}, props, {
                value: void 0,
                children: "" + initialValue
              });
            } else if (tag === "select") {
              {
                checkControlledValueProps("select", props);
                for (var i2 = 0; i2 < valuePropNames.length; i2++) {
                  var propName = valuePropNames[i2];
                  if (props[propName] == null) {
                    continue;
                  }
                  var isArray3 = Array.isArray(props[propName]);
                  if (props.multiple && !isArray3) {
                    error("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
                  } else if (!props.multiple && isArray3) {
                    error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
                  }
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
                  error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultSelectValue = true;
                }
              }
              this.currentSelectValue = props.value != null ? props.value : props.defaultValue;
              props = _assign({}, props, {
                value: void 0
              });
            } else if (tag === "option") {
              var selected = null;
              var selectValue = this.currentSelectValue;
              var optionChildren = flattenOptionChildren(props.children);
              if (selectValue != null) {
                var value;
                if (props.value != null) {
                  value = props.value + "";
                } else {
                  value = optionChildren;
                }
                selected = false;
                if (Array.isArray(selectValue)) {
                  for (var j = 0; j < selectValue.length; j++) {
                    if ("" + selectValue[j] === value) {
                      selected = true;
                      break;
                    }
                  }
                } else {
                  selected = "" + selectValue === value;
                }
                props = _assign({
                  selected: void 0,
                  children: void 0
                }, props, {
                  selected,
                  children: optionChildren
                });
              }
            }
            {
              validatePropertiesInDevelopment(tag, props);
            }
            assertValidProps(tag, props);
            var out = createOpenTagMarkup(element.type, tag, props, namespace, this.makeStaticMarkup, this.stack.length === 1);
            var footer = "";
            if (omittedCloseTags.hasOwnProperty(tag)) {
              out += "/>";
            } else {
              out += ">";
              footer = "</" + element.type + ">";
            }
            var children;
            var innerMarkup = getNonChildrenInnerMarkup(props);
            if (innerMarkup != null) {
              children = [];
              if (newlineEatingTags.hasOwnProperty(tag) && innerMarkup.charAt(0) === "\n") {
                out += "\n";
              }
              out += innerMarkup;
            } else {
              children = toArray(props.children);
            }
            var frame = {
              domNamespace: getChildNamespace(parentNamespace, element.type),
              type: tag,
              children,
              childIndex: 0,
              context,
              footer
            };
            {
              frame.debugElementStack = [];
            }
            this.stack.push(frame);
            this.previousWasTextNode = false;
            return out;
          };
          return ReactDOMServerRenderer2;
        }();
        function renderToString2(element, options) {
          var renderer = new ReactDOMServerRenderer(element, false, options);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function renderToStaticMarkup(element, options) {
          var renderer = new ReactDOMServerRenderer(element, true, options);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function _inheritsLoose2(subClass, superClass) {
          subClass.prototype = Object.create(superClass.prototype);
          subClass.prototype.constructor = subClass;
          subClass.__proto__ = superClass;
        }
        var ReactMarkupReadableStream = /* @__PURE__ */ function(_Readable) {
          _inheritsLoose2(ReactMarkupReadableStream2, _Readable);
          function ReactMarkupReadableStream2(element, makeStaticMarkup, options) {
            var _this;
            _this = _Readable.call(this, {}) || this;
            _this.partialRenderer = new ReactDOMServerRenderer(element, makeStaticMarkup, options);
            return _this;
          }
          var _proto = ReactMarkupReadableStream2.prototype;
          _proto._destroy = function _destroy(err, callback) {
            this.partialRenderer.destroy();
            callback(err);
          };
          _proto._read = function _read(size) {
            try {
              this.push(this.partialRenderer.read(size));
            } catch (err) {
              this.destroy(err);
            }
          };
          return ReactMarkupReadableStream2;
        }(stream.Readable);
        function renderToNodeStream(element, options) {
          return new ReactMarkupReadableStream(element, false, options);
        }
        function renderToStaticNodeStream(element, options) {
          return new ReactMarkupReadableStream(element, true, options);
        }
        exports.renderToNodeStream = renderToNodeStream;
        exports.renderToStaticMarkup = renderToStaticMarkup;
        exports.renderToStaticNodeStream = renderToStaticNodeStream;
        exports.renderToString = renderToString2;
        exports.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/server.node.js
var require_server_node = __commonJS({
  "node_modules/react-dom/server.node.js"(exports, module) {
    "use strict";
    init_react();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_dom_server_node_development();
    }
  }
});

// node_modules/react-dom/server.js
var require_server = __commonJS({
  "node_modules/react-dom/server.js"(exports, module) {
    "use strict";
    init_react();
    module.exports = require_server_node();
  }
});

// node_modules/@iconify/icons-fa6-brands/golang.js
var require_golang = __commonJS({
  "node_modules/@iconify/icons-fa6-brands/golang.js"(exports) {
    init_react();
    var data = {
      "body": '<path fill="currentColor" d="M400.1 194.8c-10.9 2.8-19.9 4.3-29.1 7.6c-7.3 1.9-14.7 3.9-23.2 6.1l-.6.1c-4.2 1.2-4.6 1.3-8.5-3.2c-4.7-5.3-8.1-8.7-14.6-11.9c-19.7-9.6-38.7-6.8-56.4 4.7c-21.2 13.7-32.1 34-31.8 59.2c.3 25 17.4 45.5 41.2 48.9c22 2.8 39.8-4.6 53.8-20.5c2.1-2.6 4-5.3 6.1-8.3c.8-1 1.5-2.1 2.3-3.3h-60.1c-6.5 0-8.1-4-5.9-9.3c4-9.7 11.5-25.9 15.9-34c.9-1.8 3.1-5.8 6.9-5.8h101.1c4.5-13.4 11.8-26.9 21.6-39.7c22.7-29.9 49.3-45.5 87.2-52c31.8-5.6 61.7-2.5 88.9 15.9c24.6 16.8 39.8 39.6 43.9 69.5c5.3 42.1-6.9 76.3-36.7 105.6c-19.7 20.9-44.9 34-73.9 39.9c-5.6 1-11.1 1.5-16.5 2c-2.9.2-5.7.5-8.5.8c-28.3-.6-54.2-8.7-76-27.4c-15.3-13.3-25.9-29.6-31.1-48.5c-3.7 7.3-8 14.4-14 21.1c-21.6 29.6-50.9 48-87.9 52.9c-30.6 4.1-58.9-1.8-83.9-20.5c-23-17.5-36.1-40.5-39.5-69.2c-4.1-34 5.9-65.4 26.4-91.3c22.2-29 51.5-47.4 87.3-53.9c29.3-6.2 57.3-1.9 82.6 15.3c16.5 10.9 28.3 25.8 36.1 43.9c1.9 2.8.6 4.4-3.1 5.3zm-351.8 5.6c-1.25 0-1.56-.6-.94-1.6l6.55-8.4c.62-.9 2.18-1.5 3.43-1.5H168.6c1.2 0 1.5.9.9 1.8l-5.3 8.1c-.6 1-2.2 1.9-3.1 1.9l-112.8-.3zM1.246 229.1c-1.246 0-1.558-.7-.934-1.6l6.543-8.4c.624-.9 2.182-1.6 3.425-1.6H152.4c1.2 0 1.8 1 1.5 1.9l-2.5 7.5c-.3 1.2-1.5 1.9-2.8 1.9l-147.354.3zm74.474 26.8c-.62.9-.31 1.8.93 1.8l67.95.3c.9 0 2.2-.9 2.2-2.1l.6-7.5c0-1.3-.6-2.2-1.9-2.2H83.2c-1.25 0-2.49.9-3.12 1.9l-4.36 7.8zm501.48-18c-.2-2.6-.3-4.8-.7-7c-5.6-30.8-34-48.3-63.6-41.4c-29 6.5-47.7 24.9-54.5 54.2c-5.6 24.3 6.2 48.9 28.6 58.9c17.2 7.5 34.3 6.6 50.8-1.9c24.6-13.6 38-32.7 39.6-59.5c-.1-1.2-.1-2.3-.2-3.3z"/>',
      "width": 640,
      "height": 512
    };
    exports.__esModule = true;
    exports.default = data;
  }
});

// node_modules/@iconify/icons-logos/kubernetes.js
var require_kubernetes = __commonJS({
  "node_modules/@iconify/icons-logos/kubernetes.js"(exports) {
    init_react();
    var data = {
      "body": '<path fill="#326DE6" d="M82.085 244.934c-5.946 0-11.561-2.642-15.36-7.432L8.92 165.657c-3.799-4.79-5.285-10.9-3.799-16.847l20.645-89.682c1.321-5.946 5.285-10.736 10.736-13.378l83.571-39.97c2.643-1.32 5.616-1.981 8.589-1.981c2.973 0 5.945.66 8.588 1.982l83.572 39.804c5.45 2.642 9.414 7.432 10.735 13.378l20.645 89.682c1.322 5.946 0 12.057-3.798 16.847l-57.807 71.845c-3.799 4.624-9.414 7.432-15.36 7.432l-93.15.165Z"/><path fill="#FFF" d="M128.495 7.928c2.313 0 4.625.495 6.772 1.486l83.572 39.804c4.294 2.147 7.597 6.111 8.588 10.736l20.645 89.682c1.156 4.79 0 9.745-3.138 13.543l-57.806 71.846c-2.973 3.798-7.598 5.945-12.387 5.945H82.085c-4.79 0-9.414-2.147-12.387-5.945l-57.806-71.846c-2.973-3.798-4.13-8.753-3.138-13.543l20.645-89.682c1.156-4.79 4.294-8.754 8.588-10.736L121.56 9.25c2.147-.826 4.624-1.321 6.936-1.321Zm0-7.763c-3.468 0-6.936.826-10.24 2.312l-83.571 39.97c-6.607 3.138-11.231 8.918-12.883 16.02L1.156 148.15c-1.651 7.102 0 14.369 4.625 20.15l57.806 71.845c4.46 5.615 11.231 8.753 18.333 8.753h92.655c7.102 0 13.874-3.138 18.333-8.753l57.807-71.846c4.624-5.615 6.276-13.047 4.624-20.15l-20.645-89.682c-1.651-7.102-6.276-12.882-12.882-16.02L138.57 2.476C135.432.991 131.964.165 128.495.165Z"/><path fill="#FFF" d="M212.232 142.534c-.165 0-.165 0 0 0h-.165c-.165 0-.33 0-.33-.165c-.33 0-.66-.165-.991-.165c-1.156-.165-2.147-.33-3.138-.33c-.496 0-.991 0-1.652-.166h-.165c-3.468-.33-6.276-.66-8.919-1.486c-1.156-.496-1.486-1.156-1.817-1.817c0-.165-.165-.165-.165-.33l-2.147-.66a65.33 65.33 0 0 0-1.156-23.289a68.054 68.054 0 0 0-9.249-21.636l1.652-1.486v-.33c0-.826.165-1.652.825-2.478c1.982-1.817 4.46-3.303 7.433-5.12c.495-.33.99-.495 1.486-.826c.991-.495 1.817-.99 2.808-1.651c.165-.165.495-.33.826-.66c.165-.166.33-.166.33-.331c2.312-1.982 2.808-5.285 1.156-7.433c-.826-1.156-2.312-1.816-3.799-1.816c-1.32 0-2.477.495-3.633 1.321l-.33.33c-.33.165-.496.496-.826.661c-.826.826-1.487 1.486-2.147 2.312c-.33.33-.66.826-1.156 1.156c-2.313 2.478-4.46 4.46-6.607 5.946c-.495.33-.99.496-1.486.496c-.33 0-.661 0-.991-.166h-.33l-1.983 1.322c-2.147-2.312-4.459-4.294-6.771-6.276a65.958 65.958 0 0 0-34.519-13.709l-.165-2.147l-.33-.33c-.496-.496-1.156-.991-1.322-2.147c-.165-2.643.166-5.616.496-8.919v-.165c0-.496.165-1.156.33-1.652c.165-.99.33-1.982.496-3.138v-1.486c0-2.973-2.313-5.45-5.12-5.45c-1.322 0-2.643.66-3.634 1.651c-.99.991-1.486 2.312-1.486 3.799v1.321c0 1.156.165 2.147.495 3.138c.165.496.165.991.33 1.652v.165c.33 3.303.826 6.276.496 8.919c-.165 1.156-.826 1.651-1.321 2.147l-.33.33l-.166 2.147c-2.973.33-5.946.66-8.919 1.321c-12.717 2.808-23.948 9.25-32.701 18.498l-1.652-1.156h-.33c-.33 0-.661.165-.991.165c-.496 0-.991-.165-1.487-.495c-2.147-1.486-4.294-3.634-6.606-6.111c-.33-.33-.66-.826-1.156-1.156c-.661-.826-1.322-1.487-2.148-2.312c-.165-.166-.495-.33-.825-.661c-.165-.165-.33-.165-.33-.33a5.772 5.772 0 0 0-3.634-1.322c-1.487 0-2.973.661-3.799 1.817c-1.652 2.147-1.156 5.45 1.156 7.432c.165 0 .165.166.33.166c.33.165.496.495.826.66c.991.66 1.817 1.156 2.808 1.652c.496.165.991.495 1.487.826c2.972 1.816 5.45 3.303 7.432 5.12c.826.825.826 1.651.826 2.477v.33l1.651 1.487c-.33.495-.66.826-.826 1.321c-8.258 13.048-11.396 28.408-9.249 43.603l-2.147.66c0 .166-.165.166-.165.33c-.33.661-.826 1.322-1.817 1.817c-2.477.826-5.45 1.157-8.918 1.487h-.166c-.495 0-1.156 0-1.651.165c-.991 0-1.982.165-3.138.33c-.33 0-.66.166-.991.166c-.165 0-.33 0-.496.165c-2.973.66-4.79 3.468-4.294 6.11c.496 2.313 2.643 3.8 5.285 3.8c.496 0 .826 0 1.322-.166c.165 0 .33 0 .33-.165c.33 0 .66-.165.99-.165c1.157-.33 1.983-.66 2.974-1.156c.495-.165.99-.496 1.486-.66h.165c3.138-1.157 5.946-2.148 8.589-2.478h.33c.991 0 1.652.495 2.147.826c.165 0 .165.165.33.165l2.313-.33c3.964 12.221 11.561 23.122 21.636 31.05c2.312 1.816 4.624 3.303 7.102 4.79l-.991 2.146c0 .166.165.166.165.33c.33.661.66 1.487.33 2.643c-.99 2.478-2.477 4.955-4.294 7.763v.165c-.33.496-.66.826-.99 1.321c-.661.826-1.157 1.652-1.818 2.643c-.165.165-.33.495-.495.826c0 .165-.165.33-.165.33c-1.321 2.808-.33 5.946 2.147 7.102c.66.33 1.321.496 1.982.496c1.982 0 3.964-1.322 4.955-3.139c0-.165.165-.33.165-.33c.165-.33.33-.66.495-.826c.496-1.156.661-1.982.991-2.973l.496-1.486c1.156-3.303 1.982-5.946 3.468-8.258c.66-.991 1.487-1.156 2.147-1.487c.165 0 .165 0 .33-.165l1.157-2.147c7.267 2.808 15.195 4.294 23.122 4.294c4.79 0 9.745-.495 14.37-1.651a73.402 73.402 0 0 0 8.588-2.478l.99 1.817c.166 0 .166 0 .331.165c.826.165 1.486.496 2.147 1.487c1.321 2.312 2.312 5.12 3.468 8.258v.165l.496 1.486c.33.991.495 1.982.99 2.973c.166.33.331.496.496.826c0 .165.166.33.166.33c.99 1.982 2.972 3.139 4.954 3.139c.661 0 1.322-.166 1.982-.496c1.156-.66 2.147-1.652 2.478-2.973c.33-1.321.33-2.808-.33-4.129c0-.165-.166-.165-.166-.33c-.165-.33-.33-.66-.495-.826c-.496-.991-1.156-1.817-1.817-2.643c-.33-.495-.66-.825-.99-1.32v-.166c-1.818-2.808-3.47-5.285-4.295-7.763c-.33-1.156 0-1.816.165-2.642c0-.165.165-.165.165-.33l-.826-1.982c8.754-5.12 16.186-12.388 21.802-21.306c2.973-4.625 5.285-9.745 6.936-14.865l1.982.33c.166 0 .166-.165.33-.165c.661-.33 1.157-.825 2.148-.825h.33c2.643.33 5.45 1.32 8.589 2.477h.165c.495.165.99.495 1.486.66c.991.496 1.817.826 2.973 1.157c.33 0 .66.165.991.165c.165 0 .33 0 .495.165c.496.165.826.165 1.322.165c2.477 0 4.624-1.651 5.285-3.798c0-1.982-1.817-4.625-4.79-5.45Zm-76.47-8.093l-7.267 3.469l-7.267-3.469l-1.816-7.762l4.954-6.276h8.093l4.955 6.276l-1.651 7.762Zm43.108-17.176a52.078 52.078 0 0 1 1.156 16.68l-25.27-7.266c-2.312-.66-3.633-2.973-3.138-5.285c.165-.661.496-1.322.991-1.817l19.985-18.003c2.807 4.625 4.954 9.91 6.276 15.69Zm-14.204-25.6l-21.636 15.36c-1.817 1.156-4.295.825-5.781-.991c-.495-.496-.66-1.157-.826-1.817l-1.486-26.922a50.13 50.13 0 0 1 29.729 14.37ZM116.769 78.12c1.817-.33 3.468-.66 5.285-.99l-1.486 26.425c-.165 2.312-1.982 4.294-4.46 4.294c-.66 0-1.486-.165-1.982-.495L92.16 91.665c6.772-6.772 15.195-11.397 24.609-13.544Zm-32.537 23.453l19.654 17.507c1.817 1.487 1.982 4.294.496 6.111c-.496.66-1.156 1.156-1.982 1.322l-25.6 7.432c-.991-11.231 1.486-22.627 7.432-32.372Zm-4.46 44.759l26.262-4.46c2.147-.165 4.129 1.322 4.624 3.469c.165.99.165 1.817-.165 2.643l-10.075 24.278c-9.249-5.946-16.681-15.03-20.645-25.93Zm60.285 32.867c-3.799.826-7.598 1.321-11.562 1.321c-5.78 0-11.396-.99-16.68-2.642l13.047-23.618c1.321-1.487 3.468-2.147 5.285-1.156a7.04 7.04 0 0 1 1.982 1.816l12.717 22.958c-1.486.495-3.138.826-4.79 1.321Zm32.206-22.957c-4.129 6.606-9.58 11.891-15.855 16.02l-10.405-24.94c-.496-1.981.33-4.128 2.312-5.12c.66-.33 1.486-.495 2.312-.495l26.426 4.46c-.991 3.633-2.643 6.937-4.79 10.075Z"/>',
      "width": 256,
      "height": 249
    };
    exports.__esModule = true;
    exports.default = data;
  }
});

// node_modules/@iconify/icons-logos/python.js
var require_python = __commonJS({
  "node_modules/@iconify/icons-logos/python.js"(exports) {
    init_react();
    var data = {
      "body": '<defs><linearGradient id="svgIDa" x1="12.959%" x2="79.639%" y1="12.039%" y2="78.201%"><stop offset="0%" stop-color="#387EB8"/><stop offset="100%" stop-color="#366994"/></linearGradient><linearGradient id="svgIDb" x1="19.128%" x2="90.742%" y1="20.579%" y2="88.429%"><stop offset="0%" stop-color="#FFE052"/><stop offset="100%" stop-color="#FFC331"/></linearGradient></defs><path fill="url(#svgIDa)" d="M126.916.072c-64.832 0-60.784 28.115-60.784 28.115l.072 29.128h61.868v8.745H41.631S.145 61.355.145 126.77c0 65.417 36.21 63.097 36.21 63.097h21.61v-30.356s-1.165-36.21 35.632-36.21h61.362s34.475.557 34.475-33.319V33.97S194.67.072 126.916.072ZM92.802 19.66a11.12 11.12 0 0 1 11.13 11.13a11.12 11.12 0 0 1-11.13 11.13a11.12 11.12 0 0 1-11.13-11.13a11.12 11.12 0 0 1 11.13-11.13Z"/><path fill="url(#svgIDb)" d="M128.757 254.126c64.832 0 60.784-28.115 60.784-28.115l-.072-29.127H127.6v-8.745h86.441s41.486 4.705 41.486-60.712c0-65.416-36.21-63.096-36.21-63.096h-21.61v30.355s1.165 36.21-35.632 36.21h-61.362s-34.475-.557-34.475 33.32v56.013s-5.235 33.897 62.518 33.897Zm34.114-19.586a11.12 11.12 0 0 1-11.13-11.13a11.12 11.12 0 0 1 11.13-11.131a11.12 11.12 0 0 1 11.13 11.13a11.12 11.12 0 0 1-11.13 11.13Z"/>',
      "width": 256,
      "height": 255
    };
    exports.__esModule = true;
    exports.default = data;
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    init_react();
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames2() {
        var classes = [];
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames2.apply(null, arg);
              if (inner) {
                classes.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString === Object.prototype.toString) {
              for (var key in arg) {
                if (hasOwn.call(arg, key) && arg[key]) {
                  classes.push(key);
                }
              }
            } else {
              classes.push(arg.toString());
            }
          }
        }
        return classes.join(" ");
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames2.default = classNames2;
        module.exports = classNames2;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames2;
        });
      } else {
        window.classNames = classNames2;
      }
    })();
  }
});

// node_modules/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    init_react();
    if (true) {
      (function() {
        "use strict";
        var React11 = require_react();
        var _assign = require_object_assign();
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        exports.Fragment = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          exports.Fragment = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var MAYBE_ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          if (maybeIterable === null || typeof maybeIterable !== "object") {
            return null;
          }
          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
          if (typeof maybeIterator === "function") {
            return maybeIterator;
          }
          return null;
        }
        var ReactSharedInternals = React11.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function error(format2) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format2, args);
          }
        }
        function printWarning(level, format2, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format2 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format2);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var enableScopeAPI = false;
        function isValidElementType(type2) {
          if (typeof type2 === "string" || typeof type2 === "function") {
            return true;
          }
          if (type2 === exports.Fragment || type2 === REACT_PROFILER_TYPE || type2 === REACT_DEBUG_TRACING_MODE_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || type2 === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type2 === "object" && type2 !== null) {
            if (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_BLOCK_TYPE || type2[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type2) {
          return type2.displayName || "Context";
        }
        function getComponentName(type2) {
          if (type2 == null) {
            return null;
          }
          {
            if (typeof type2.tag === "number") {
              error("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type2 === "function") {
            return type2.displayName || type2.name || null;
          }
          if (typeof type2 === "string") {
            return type2;
          }
          switch (type2) {
            case exports.Fragment:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type2;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type2;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type2, type2.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type2.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type2._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return getComponentName(init2(payload));
                } catch (x) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix;
        function describeBuiltInComponentFrame(name, source, ownerFn) {
          {
            if (prefix === void 0) {
              try {
                throw Error();
              } catch (x) {
                var match = x.stack.trim().match(/\n( *(at )?)/);
                prefix = match && match[1] || "";
              }
            }
            return "\n" + prefix + name;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn, construct) {
          if (!fn || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x) {
                  control = x;
                }
                Reflect.construct(fn, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x) {
                  control = x;
                }
                fn.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x) {
                control = x;
              }
              fn();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s = sampleLines.length - 1;
              var c = controlLines.length - 1;
              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                c--;
              }
              for (; s >= 1 && c >= 0; s--, c--) {
                if (sampleLines[s] !== controlLines[c]) {
                  if (s !== 1 || c !== 1) {
                    do {
                      s--;
                      c--;
                      if (c < 0 || sampleLines[s] !== controlLines[c]) {
                        var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                        {
                          if (typeof fn === "function") {
                            componentFrameCache.set(fn, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s >= 1 && c >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name = fn ? fn.displayName || fn.name : "";
          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
          {
            if (typeof fn === "function") {
              componentFrameCache.set(fn, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn, false);
          }
        }
        function shouldConstruct(Component2) {
          var prototype = Component2.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type2, source, ownerFn) {
          if (type2 == null) {
            return "";
          }
          if (typeof type2 === "function") {
            {
              return describeNativeComponentFrame(type2, shouldConstruct(type2));
            }
          }
          if (typeof type2 === "string") {
            return describeBuiltInComponentFrame(type2);
          }
          switch (type2) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type2 === "object") {
            switch (type2.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type2.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type2.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type2._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type2;
                var payload = lazyComponent._payload;
                var init2 = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                } catch (x) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values, location2, componentName, element) {
          {
            var has = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error("Failed %s type: %s", location2, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
        var hasOwnProperty2 = Object.prototype.hasOwnProperty;
        var RESERVED_PROPS = {
          key: true,
          ref: true,
          __self: true,
          __source: true
        };
        var specialPropKeyWarningShown;
        var specialPropRefWarningShown;
        var didWarnAboutStringRefs;
        {
          didWarnAboutStringRefs = {};
        }
        function hasValidRef(config3) {
          {
            if (hasOwnProperty2.call(config3, "ref")) {
              var getter = Object.getOwnPropertyDescriptor(config3, "ref").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config3.ref !== void 0;
        }
        function hasValidKey(config3) {
          {
            if (hasOwnProperty2.call(config3, "key")) {
              var getter = Object.getOwnPropertyDescriptor(config3, "key").get;
              if (getter && getter.isReactWarning) {
                return false;
              }
            }
          }
          return config3.key !== void 0;
        }
        function warnIfStringRefCannotBeAutoConverted(config3, self2) {
          {
            if (typeof config3.ref === "string" && ReactCurrentOwner.current && self2 && ReactCurrentOwner.current.stateNode !== self2) {
              var componentName = getComponentName(ReactCurrentOwner.current.type);
              if (!didWarnAboutStringRefs[componentName]) {
                error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config3.ref);
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
        }
        function defineKeyPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingKey = function() {
              if (!specialPropKeyWarningShown) {
                specialPropKeyWarningShown = true;
                error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
        }
        function defineRefPropWarningGetter(props, displayName) {
          {
            var warnAboutAccessingRef = function() {
              if (!specialPropRefWarningShown) {
                specialPropRefWarningShown = true;
                error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
        }
        var ReactElement = function(type2, key, ref, self2, source, owner, props) {
          var element = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type2,
            key,
            ref,
            props,
            _owner: owner
          };
          {
            element._store = {};
            Object.defineProperty(element._store, "validated", {
              configurable: false,
              enumerable: false,
              writable: true,
              value: false
            });
            Object.defineProperty(element, "_self", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: self2
            });
            Object.defineProperty(element, "_source", {
              configurable: false,
              enumerable: false,
              writable: false,
              value: source
            });
            if (Object.freeze) {
              Object.freeze(element.props);
              Object.freeze(element);
            }
          }
          return element;
        };
        function jsxDEV(type2, config3, maybeKey, source, self2) {
          {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            if (maybeKey !== void 0) {
              key = "" + maybeKey;
            }
            if (hasValidKey(config3)) {
              key = "" + config3.key;
            }
            if (hasValidRef(config3)) {
              ref = config3.ref;
              warnIfStringRefCannotBeAutoConverted(config3, self2);
            }
            for (propName in config3) {
              if (hasOwnProperty2.call(config3, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                props[propName] = config3[propName];
              }
            }
            if (type2 && type2.defaultProps) {
              var defaultProps2 = type2.defaultProps;
              for (propName in defaultProps2) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps2[propName];
                }
              }
            }
            if (key || ref) {
              var displayName = typeof type2 === "function" ? type2.displayName || type2.name || "Unknown" : type2;
              if (key) {
                defineKeyPropWarningGetter(props, displayName);
              }
              if (ref) {
                defineRefPropWarningGetter(props, displayName);
              }
            }
            return ReactElement(type2, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
        }
        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement$1(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame$1.setExtraStackFrame(null);
            }
          }
        }
        var propTypesMisspellWarningShown;
        {
          propTypesMisspellWarningShown = false;
        }
        function isValidElement2(object) {
          {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
        }
        function getDeclarationErrorAddendum() {
          {
            if (ReactCurrentOwner$1.current) {
              var name = getComponentName(ReactCurrentOwner$1.current.type);
              if (name) {
                return "\n\nCheck the render method of `" + name + "`.";
              }
            }
            return "";
          }
        }
        function getSourceInfoErrorAddendum(source) {
          {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
        }
        var ownerHasKeyUseWarning = {};
        function getCurrentComponentErrorInfo(parentType) {
          {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
        }
        function validateExplicitKey(element, parentType) {
          {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
              childOwner = " It was passed a child from " + getComponentName(element._owner.type) + ".";
            }
            setCurrentlyValidatingElement$1(element);
            error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
            setCurrentlyValidatingElement$1(null);
          }
        }
        function validateChildKeys(node, parentType) {
          {
            if (typeof node !== "object") {
              return;
            }
            if (Array.isArray(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement2(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement2(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement2(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
        }
        function validatePropTypes(element) {
          {
            var type2 = element.type;
            if (type2 === null || type2 === void 0 || typeof type2 === "string") {
              return;
            }
            var propTypes;
            if (typeof type2 === "function") {
              propTypes = type2.propTypes;
            } else if (typeof type2 === "object" && (type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_MEMO_TYPE)) {
              propTypes = type2.propTypes;
            } else {
              return;
            }
            if (propTypes) {
              var name = getComponentName(type2);
              checkPropTypes(propTypes, element.props, "prop", name, element);
            } else if (type2.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
              propTypesMisspellWarningShown = true;
              var _name = getComponentName(type2);
              error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
            }
            if (typeof type2.getDefaultProps === "function" && !type2.getDefaultProps.isReactClassApproved) {
              error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
            }
          }
        }
        function validateFragmentProps(fragment) {
          {
            var keys2 = Object.keys(fragment.props);
            for (var i = 0; i < keys2.length; i++) {
              var key = keys2[i];
              if (key !== "children" && key !== "key") {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                setCurrentlyValidatingElement$1(null);
                break;
              }
            }
            if (fragment.ref !== null) {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid attribute `ref` supplied to `React.Fragment`.");
              setCurrentlyValidatingElement$1(null);
            }
          }
        }
        function jsxWithValidation(type2, props, key, isStaticChildren, source, self2) {
          {
            var validType = isValidElementType(type2);
            if (!validType) {
              var info = "";
              if (type2 === void 0 || typeof type2 === "object" && type2 !== null && Object.keys(type2).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendum(source);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type2 === null) {
                typeString = "null";
              } else if (Array.isArray(type2)) {
                typeString = "array";
              } else if (type2 !== void 0 && type2.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentName(type2.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type2;
              }
              error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
            }
            var element = jsxDEV(type2, props, key, source, self2);
            if (element == null) {
              return element;
            }
            if (validType) {
              var children = props.children;
              if (children !== void 0) {
                if (isStaticChildren) {
                  if (Array.isArray(children)) {
                    for (var i = 0; i < children.length; i++) {
                      validateChildKeys(children[i], type2);
                    }
                    if (Object.freeze) {
                      Object.freeze(children);
                    }
                  } else {
                    error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
                  }
                } else {
                  validateChildKeys(children, type2);
                }
              }
            }
            if (type2 === exports.Fragment) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
        }
        function jsxWithValidationStatic(type2, props, key) {
          {
            return jsxWithValidation(type2, props, key, true);
          }
        }
        function jsxWithValidationDynamic(type2, props, key) {
          {
            return jsxWithValidation(type2, props, key, false);
          }
        }
        var jsx = jsxWithValidationDynamic;
        var jsxs = jsxWithValidationStatic;
        exports.jsx = jsx;
        exports.jsxs = jsxs;
      })();
    }
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    init_react();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    init_react();
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type2) {
          return typeof type2 === "string" || typeof type2 === "function" || type2 === REACT_FRAGMENT_TYPE || type2 === REACT_CONCURRENT_MODE_TYPE || type2 === REACT_PROFILER_TYPE || type2 === REACT_STRICT_MODE_TYPE || type2 === REACT_SUSPENSE_TYPE || type2 === REACT_SUSPENSE_LIST_TYPE || typeof type2 === "object" && type2 !== null && (type2.$$typeof === REACT_LAZY_TYPE || type2.$$typeof === REACT_MEMO_TYPE || type2.$$typeof === REACT_PROVIDER_TYPE || type2.$$typeof === REACT_CONTEXT_TYPE || type2.$$typeof === REACT_FORWARD_REF_TYPE || type2.$$typeof === REACT_FUNDAMENTAL_TYPE || type2.$$typeof === REACT_RESPONDER_TYPE || type2.$$typeof === REACT_SCOPE_TYPE || type2.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type2 = object.type;
                switch (type2) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type2;
                  default:
                    var $$typeofType = type2 && type2.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment3 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment3;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/prop-types/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/prop-types/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    init_react();
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    init_react();
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    init_react();
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    init_react();
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location2, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning((componentName || "React class") + ": type specification of " + location2 + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).");
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning("Failed " + location2 + " type: " + error.message + (stack != null ? stack : ""));
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    init_react();
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement2, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location2, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types");
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                printWarning("You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.");
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location2, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location2, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."), { expectedType });
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location2, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location2, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          if (!isValidElement2(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location2, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning("Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).");
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type2 = getPreciseType(value);
            if (type2 === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location2, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning("Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + ".");
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location2, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location2, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location2, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location2, propFullName, key, type2) {
        return new PropTypeError((componentName || "React class") + ": " + location2 + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type2 + "`.");
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location2, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  "));
            }
            var error = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement2(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry2 = step.value;
                  if (entry2) {
                    if (!isNode(entry2[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type2 = getPreciseType(value);
        switch (type2) {
          case "array":
          case "object":
            return "an " + type2;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type2;
          default:
            return type2;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    init_react();
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/react-vertical-timeline-component/dist-es6/VerticalTimeline.js
var require_VerticalTimeline = __commonJS({
  "node_modules/react-vertical-timeline-component/dist-es6/VerticalTimeline.js"(exports) {
    "use strict";
    init_react();
    exports.__esModule = true;
    exports.default = void 0;
    var _react = _interopRequireDefault(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _classnames = _interopRequireDefault(require_classnames());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var VerticalTimeline2 = ({
      animate,
      className,
      layout,
      lineColor,
      children
    }) => {
      if (typeof window === "object") {
        document.documentElement.style.setProperty("--line-color", lineColor);
      }
      return /* @__PURE__ */ _react.default.createElement("div", {
        className: (0, _classnames.default)(className, "vertical-timeline", {
          "vertical-timeline--animate": animate,
          "vertical-timeline--two-columns": layout === "2-columns",
          "vertical-timeline--one-column-left": layout === "1-column" || layout === "1-column-left",
          "vertical-timeline--one-column-right": layout === "1-column-right"
        })
      }, children);
    };
    VerticalTimeline2.propTypes = {
      children: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.node), _propTypes.default.node]).isRequired,
      className: _propTypes.default.string,
      animate: _propTypes.default.bool,
      layout: _propTypes.default.oneOf(["1-column-left", "1-column", "2-columns", "1-column-right"]),
      lineColor: _propTypes.default.string
    };
    VerticalTimeline2.defaultProps = {
      animate: true,
      className: "",
      layout: "2-columns",
      lineColor: "#FFF"
    };
    var _default = VerticalTimeline2;
    exports.default = _default;
  }
});

// node_modules/react-intersection-observer/react-intersection-observer.m.js
var react_intersection_observer_m_exports = {};
__export(react_intersection_observer_m_exports, {
  InView: () => InView,
  default: () => InView,
  defaultFallbackInView: () => defaultFallbackInView,
  observe: () => observe,
  useInView: () => useInView
});
function _extends4() {
  _extends4 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function defaultFallbackInView(inView) {
  unsupportedValue = inView;
}
function getRootId(root) {
  if (!root)
    return "0";
  if (RootIds.has(root))
    return RootIds.get(root);
  rootId += 1;
  RootIds.set(root, rootId.toString());
  return RootIds.get(root);
}
function optionsToId(options) {
  return Object.keys(options).sort().filter(function(key) {
    return options[key] !== void 0;
  }).map(function(key) {
    return key + "_" + (key === "root" ? getRootId(options.root) : options[key]);
  }).toString();
}
function createObserver(options) {
  var id = optionsToId(options);
  var instance = observerMap.get(id);
  if (!instance) {
    var elements = /* @__PURE__ */ new Map();
    var thresholds;
    var observer = new IntersectionObserver(function(entries) {
      entries.forEach(function(entry2) {
        var _elements$get;
        var inView = entry2.isIntersecting && thresholds.some(function(threshold) {
          return entry2.intersectionRatio >= threshold;
        });
        if (options.trackVisibility && typeof entry2.isVisible === "undefined") {
          entry2.isVisible = inView;
        }
        (_elements$get = elements.get(entry2.target)) == null ? void 0 : _elements$get.forEach(function(callback) {
          callback(inView, entry2);
        });
      });
    }, options);
    thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
    instance = {
      id,
      observer,
      elements
    };
    observerMap.set(id, instance);
  }
  return instance;
}
function observe(element, callback, options, fallbackInView) {
  if (options === void 0) {
    options = {};
  }
  if (fallbackInView === void 0) {
    fallbackInView = unsupportedValue;
  }
  if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
    var bounds = element.getBoundingClientRect();
    callback(fallbackInView, {
      isIntersecting: fallbackInView,
      target: element,
      intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
      time: 0,
      boundingClientRect: bounds,
      intersectionRect: bounds,
      rootBounds: bounds
    });
    return function() {
    };
  }
  var _createObserver = createObserver(options), id = _createObserver.id, observer = _createObserver.observer, elements = _createObserver.elements;
  var callbacks2 = elements.get(element) || [];
  if (!elements.has(element)) {
    elements.set(element, callbacks2);
  }
  callbacks2.push(callback);
  observer.observe(element);
  return function unobserve() {
    callbacks2.splice(callbacks2.indexOf(callback), 1);
    if (callbacks2.length === 0) {
      elements["delete"](element);
      observer.unobserve(element);
    }
    if (elements.size === 0) {
      observer.disconnect();
      observerMap["delete"](id);
    }
  };
}
function isPlainChildren(props) {
  return typeof props.children !== "function";
}
function useInView(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, threshold = _ref.threshold, delay = _ref.delay, trackVisibility = _ref.trackVisibility, rootMargin = _ref.rootMargin, root = _ref.root, triggerOnce = _ref.triggerOnce, skip = _ref.skip, initialInView = _ref.initialInView, fallbackInView = _ref.fallbackInView;
  var unobserve = React9.useRef();
  var _React$useState = React9.useState({
    inView: !!initialInView
  }), state = _React$useState[0], setState = _React$useState[1];
  var setRef = React9.useCallback(function(node) {
    if (unobserve.current !== void 0) {
      unobserve.current();
      unobserve.current = void 0;
    }
    if (skip)
      return;
    if (node) {
      unobserve.current = observe(node, function(inView, entry2) {
        setState({
          inView,
          entry: entry2
        });
        if (entry2.isIntersecting && triggerOnce && unobserve.current) {
          unobserve.current();
          unobserve.current = void 0;
        }
      }, {
        root,
        rootMargin,
        threshold,
        trackVisibility,
        delay
      }, fallbackInView);
    }
  }, [
    Array.isArray(threshold) ? threshold.toString() : threshold,
    root,
    rootMargin,
    triggerOnce,
    skip,
    trackVisibility,
    fallbackInView,
    delay
  ]);
  (0, import_react8.useEffect)(function() {
    if (!unobserve.current && state.entry && !triggerOnce && !skip) {
      setState({
        inView: !!initialInView
      });
    }
  });
  var result = [setRef, state.inView, state.entry];
  result.ref = result[0];
  result.inView = result[1];
  result.entry = result[2];
  return result;
}
var React9, import_react8, observerMap, RootIds, rootId, unsupportedValue, _excluded3, InView;
var init_react_intersection_observer_m = __esm({
  "node_modules/react-intersection-observer/react-intersection-observer.m.js"() {
    init_react();
    React9 = __toESM(require_react());
    import_react8 = __toESM(require_react());
    observerMap = /* @__PURE__ */ new Map();
    RootIds = /* @__PURE__ */ new WeakMap();
    rootId = 0;
    unsupportedValue = void 0;
    _excluded3 = ["children", "as", "tag", "triggerOnce", "threshold", "root", "rootMargin", "onChange", "skip", "trackVisibility", "delay", "initialInView", "fallbackInView"];
    InView = /* @__PURE__ */ function(_React$Component) {
      _inheritsLoose(InView2, _React$Component);
      function InView2(props) {
        var _this;
        _this = _React$Component.call(this, props) || this;
        _this.node = null;
        _this._unobserveCb = null;
        _this.handleNode = function(node) {
          if (_this.node) {
            _this.unobserve();
            if (!node && !_this.props.triggerOnce && !_this.props.skip) {
              _this.setState({
                inView: !!_this.props.initialInView,
                entry: void 0
              });
            }
          }
          _this.node = node ? node : null;
          _this.observeNode();
        };
        _this.handleChange = function(inView, entry2) {
          if (inView && _this.props.triggerOnce) {
            _this.unobserve();
          }
          if (!isPlainChildren(_this.props)) {
            _this.setState({
              inView,
              entry: entry2
            });
          }
          if (_this.props.onChange) {
            _this.props.onChange(inView, entry2);
          }
        };
        _this.state = {
          inView: !!props.initialInView,
          entry: void 0
        };
        return _this;
      }
      var _proto = InView2.prototype;
      _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {
          this.unobserve();
          this.observeNode();
        }
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.unobserve();
        this.node = null;
      };
      _proto.observeNode = function observeNode() {
        if (!this.node || this.props.skip)
          return;
        var _this$props = this.props, threshold = _this$props.threshold, root = _this$props.root, rootMargin = _this$props.rootMargin, trackVisibility = _this$props.trackVisibility, delay = _this$props.delay, fallbackInView = _this$props.fallbackInView;
        this._unobserveCb = observe(this.node, this.handleChange, {
          threshold,
          root,
          rootMargin,
          trackVisibility,
          delay
        }, fallbackInView);
      };
      _proto.unobserve = function unobserve() {
        if (this._unobserveCb) {
          this._unobserveCb();
          this._unobserveCb = null;
        }
      };
      _proto.render = function render2() {
        if (!isPlainChildren(this.props)) {
          var _this$state = this.state, inView = _this$state.inView, entry2 = _this$state.entry;
          return this.props.children({
            inView,
            entry: entry2,
            ref: this.handleNode
          });
        }
        var _this$props2 = this.props, children = _this$props2.children, as = _this$props2.as, tag = _this$props2.tag, props = _objectWithoutPropertiesLoose2(_this$props2, _excluded3);
        return /* @__PURE__ */ React9.createElement(as || tag || "div", _extends4({
          ref: this.handleNode
        }, props), children);
      };
      return InView2;
    }(React9.Component);
    InView.displayName = "InView";
    InView.defaultProps = {
      threshold: 0,
      triggerOnce: false,
      initialInView: false
    };
  }
});

// node_modules/react-vertical-timeline-component/dist-es6/VerticalTimelineElement.js
var require_VerticalTimelineElement = __commonJS({
  "node_modules/react-vertical-timeline-component/dist-es6/VerticalTimelineElement.js"(exports) {
    "use strict";
    init_react();
    exports.__esModule = true;
    exports.default = void 0;
    var _react = _interopRequireDefault(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _classnames = _interopRequireDefault(require_classnames());
    var _reactIntersectionObserver = (init_react_intersection_observer_m(), __toCommonJS(react_intersection_observer_m_exports));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var VerticalTimelineElement2 = ({
      children,
      className,
      contentArrowStyle,
      contentStyle,
      date,
      dateClassName,
      icon,
      iconClassName,
      iconOnClick,
      onTimelineElementClick,
      iconStyle,
      id,
      position,
      style,
      textClassName,
      intersectionObserverProps,
      visible
    }) => /* @__PURE__ */ _react.default.createElement(_reactIntersectionObserver.InView, intersectionObserverProps, ({
      inView,
      ref
    }) => /* @__PURE__ */ _react.default.createElement("div", {
      ref,
      id,
      className: (0, _classnames.default)(className, "vertical-timeline-element", {
        "vertical-timeline-element--left": position === "left",
        "vertical-timeline-element--right": position === "right",
        "vertical-timeline-element--no-children": children === ""
      }),
      style
    }, /* @__PURE__ */ _react.default.createElement(_react.default.Fragment, null, /* @__PURE__ */ _react.default.createElement("span", {
      style: iconStyle,
      onClick: iconOnClick,
      className: (0, _classnames.default)(iconClassName, "vertical-timeline-element-icon", {
        "bounce-in": inView || visible,
        "is-hidden": !(inView || visible)
      })
    }, icon), /* @__PURE__ */ _react.default.createElement("div", {
      style: contentStyle,
      onClick: onTimelineElementClick,
      className: (0, _classnames.default)(textClassName, "vertical-timeline-element-content", {
        "bounce-in": inView || visible,
        "is-hidden": !(inView || visible)
      })
    }, /* @__PURE__ */ _react.default.createElement("div", {
      style: contentArrowStyle,
      className: "vertical-timeline-element-content-arrow"
    }), children, /* @__PURE__ */ _react.default.createElement("span", {
      className: (0, _classnames.default)(dateClassName, "vertical-timeline-element-date")
    }, date)))));
    VerticalTimelineElement2.propTypes = {
      children: _propTypes.default.oneOfType([_propTypes.default.arrayOf(_propTypes.default.node), _propTypes.default.node]),
      className: _propTypes.default.string,
      contentArrowStyle: _propTypes.default.shape({}),
      contentStyle: _propTypes.default.shape({}),
      date: _propTypes.default.node,
      dateClassName: _propTypes.default.string,
      icon: _propTypes.default.element,
      iconClassName: _propTypes.default.string,
      iconStyle: _propTypes.default.shape({}),
      iconOnClick: _propTypes.default.func,
      onTimelineElementClick: _propTypes.default.func,
      id: _propTypes.default.string,
      position: _propTypes.default.string,
      style: _propTypes.default.shape({}),
      textClassName: _propTypes.default.string,
      visible: _propTypes.default.bool,
      intersectionObserverProps: _propTypes.default.shape({
        root: _propTypes.default.object,
        rootMargin: _propTypes.default.string,
        threshold: _propTypes.default.number,
        triggerOnce: _propTypes.default.bool
      })
    };
    VerticalTimelineElement2.defaultProps = {
      children: "",
      className: "",
      contentArrowStyle: null,
      contentStyle: null,
      icon: null,
      iconClassName: "",
      iconOnClick: null,
      onTimelineElementClick: null,
      iconStyle: null,
      id: "",
      style: null,
      date: "",
      dateClassName: "",
      position: "",
      textClassName: "",
      visible: false,
      intersectionObserverProps: {
        rootMargin: "0px 0px -40px 0px",
        triggerOnce: true
      }
    };
    var _default = VerticalTimelineElement2;
    exports.default = _default;
  }
});

// node_modules/react-vertical-timeline-component/dist-es6/index.js
var require_dist_es6 = __commonJS({
  "node_modules/react-vertical-timeline-component/dist-es6/index.js"(exports, module) {
    "use strict";
    init_react();
    module.exports = {
      VerticalTimeline: require_VerticalTimeline().default,
      VerticalTimelineElement: require_VerticalTimelineElement().default
    };
  }
});

// server.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/index.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/globals.js
init_react();

// node_modules/@remix-run/cloudflare-pages/esm/cookieSigning.js
init_react();
var encoder = new TextEncoder();
async function sign(value, secret) {
  let key = await crypto.subtle.importKey("raw", encoder.encode(secret), {
    name: "HMAC",
    hash: "SHA-256"
  }, false, ["sign"]);
  let data = encoder.encode(value);
  let signature = await crypto.subtle.sign("HMAC", key, data);
  let hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(/=+$/, "");
  return value + "." + hash;
}
async function unsign(cookie, secret) {
  let key = await crypto.subtle.importKey("raw", encoder.encode(secret), {
    name: "HMAC",
    hash: "SHA-256"
  }, false, ["verify"]);
  let value = cookie.slice(0, cookie.lastIndexOf("."));
  let hash = cookie.slice(cookie.lastIndexOf(".") + 1);
  let data = encoder.encode(value);
  let signature = byteStringToUint8Array(atob(hash));
  let valid = await crypto.subtle.verify("HMAC", key, signature, data);
  return valid ? value : false;
}
function byteStringToUint8Array(byteString) {
  let array = new Uint8Array(byteString.length);
  for (let i = 0; i < byteString.length; i++) {
    array[i] = byteString.charCodeAt(i);
  }
  return array;
}

// node_modules/@remix-run/cloudflare-pages/esm/globals.js
function installGlobals() {
  self.sign = sign;
  self.unsign = unsign;
}

// node_modules/@remix-run/cloudflare-pages/esm/sessions/cloudflareKVSessionStorage.js
init_react();

// node_modules/@remix-run/server-runtime/esm/index.js
init_react();

// node_modules/@remix-run/server-runtime/esm/responses.js
init_react();
function json(data, init2 = {}) {
  let responseInit = init2;
  if (typeof init2 === "number") {
    responseInit = {
      status: init2
    };
  }
  let headers = new Headers(responseInit.headers);
  if (!headers.has("Content-Type")) {
    headers.set("Content-Type", "application/json; charset=utf-8");
  }
  return new Response(JSON.stringify(data), __spreadProps(__spreadValues({}, responseInit), {
    headers
  }));
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
var redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
function isRedirectResponse(response) {
  return redirectStatusCodes.has(response.status);
}
function isCatchResponse(response) {
  return response.headers.get("X-Remix-Catch") != null;
}

// node_modules/@remix-run/server-runtime/esm/server.js
init_react();

// node_modules/@remix-run/server-runtime/esm/data.js
init_react();
async function callRouteAction({
  loadContext,
  match,
  request
}) {
  let action = match.route.module.action;
  if (!action) {
    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide an \`action\` for route "${match.route.id}", so there is no way to handle the request.`);
  }
  let result;
  try {
    result = await action({
      request: stripDataParam(stripIndexParam(request)),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error)) {
      throw error;
    }
    if (!isRedirectResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
    }
    result = error;
  }
  if (result === void 0) {
    throw new Error(`You defined an action for route "${match.route.id}" but didn't return anything from your \`action\` function. Please return a value or \`null\`.`);
  }
  return isResponse(result) ? result : json(result);
}
async function callRouteLoader({
  loadContext,
  match,
  request
}) {
  let loader = match.route.module.loader;
  if (!loader) {
    throw new Error(`You made a ${request.method} request to ${request.url} but did not provide a \`loader\` for route "${match.route.id}", so there is no way to handle the request.`);
  }
  let result;
  try {
    result = await loader({
      request: stripDataParam(stripIndexParam(request.clone())),
      context: loadContext,
      params: match.params
    });
  } catch (error) {
    if (!isResponse(error)) {
      throw error;
    }
    if (!isRedirectResponse(error)) {
      error.headers.set("X-Remix-Catch", "yes");
    }
    result = error;
  }
  if (result === void 0) {
    throw new Error(`You defined a loader for route "${match.route.id}" but didn't return anything from your \`loader\` function. Please return a value or \`null\`.`);
  }
  return isResponse(result) ? result : json(result);
}
function stripIndexParam(request) {
  let url = new URL(request.url);
  let indexValues = url.searchParams.getAll("index");
  url.searchParams.delete("index");
  let indexValuesToKeep = [];
  for (let indexValue of indexValues) {
    if (indexValue) {
      indexValuesToKeep.push(indexValue);
    }
  }
  for (let toKeep of indexValuesToKeep) {
    url.searchParams.append("index", toKeep);
  }
  return new Request(url.href, request);
}
function stripDataParam(request) {
  let url = new URL(request.url);
  url.searchParams.delete("_data");
  return new Request(url.href, request);
}
function extractData(response) {
  let contentType = response.headers.get("Content-Type");
  if (contentType && /\bapplication\/json\b/.test(contentType)) {
    return response.json();
  }
  return response.text();
}

// node_modules/@remix-run/server-runtime/esm/entry.js
init_react();
function createEntryMatches(matches, routes2) {
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: routes2[match.route.id]
  }));
}
function createEntryRouteModules(manifest) {
  return Object.keys(manifest).reduce((memo2, routeId) => {
    memo2[routeId] = manifest[routeId].module;
    return memo2;
  }, {});
}

// node_modules/@remix-run/server-runtime/esm/errors.js
init_react();
async function serializeError(error) {
  return {
    message: error.message,
    stack: error.stack
  };
}

// node_modules/@remix-run/server-runtime/esm/headers.js
init_react();
var import_set_cookie_parser = __toESM(require_set_cookie());
function getDocumentHeaders(build, matches, routeLoaderResponses, actionResponse) {
  return matches.reduce((parentHeaders, match, index2) => {
    let routeModule = build.routes[match.route.id].module;
    let routeLoaderResponse = routeLoaderResponses[match.route.id];
    let loaderHeaders = routeLoaderResponse ? routeLoaderResponse.headers : new Headers();
    let actionHeaders = actionResponse ? actionResponse.headers : new Headers();
    let headers = new Headers(routeModule.headers ? typeof routeModule.headers === "function" ? routeModule.headers({
      loaderHeaders,
      parentHeaders,
      actionHeaders
    }) : routeModule.headers : void 0);
    prependCookies(actionHeaders, headers);
    prependCookies(loaderHeaders, headers);
    prependCookies(parentHeaders, headers);
    return headers;
  }, new Headers());
}
function prependCookies(parentHeaders, childHeaders) {
  let parentSetCookieString = parentHeaders.get("Set-Cookie");
  if (parentSetCookieString) {
    let cookies = (0, import_set_cookie_parser.splitCookiesString)(parentSetCookieString);
    cookies.forEach((cookie) => {
      childHeaders.append("Set-Cookie", cookie);
    });
  }
}

// node_modules/@remix-run/server-runtime/esm/routeMatching.js
init_react();

// node_modules/react-router-dom/index.js
init_react();
var import_react2 = __toESM(require_react());

// node_modules/history/index.js
init_react();

// node_modules/@babel/runtime/helpers/esm/extends.js
init_react();

// node_modules/history/index.js
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
function createPath(_ref) {
  var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? "/" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? "" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? "" : _ref$hash;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  var parsedPath = {};
  if (path) {
    var hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    var searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}

// node_modules/react-router/index.js
init_react();
var import_react = __toESM(require_react());
function invariant(cond, message) {
  if (!cond)
    throw new Error(message);
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e) {
    }
  }
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    true ? warning(false, message) : void 0;
  }
}
var NavigationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
var LocationContext = /* @__PURE__ */ (0, import_react.createContext)(null);
if (true) {
  LocationContext.displayName = "Location";
}
var RouteContext = /* @__PURE__ */ (0, import_react.createContext)({
  outlet: null,
  matches: []
});
if (true) {
  RouteContext.displayName = "Route";
}
function Outlet(props) {
  return useOutlet(props.context);
}
function Router(_ref3) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator,
    static: staticProp = false
  } = _ref3;
  !!useInRouterContext() ? true ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant(false) : void 0;
  let basename = normalizePathname(basenameProp);
  let navigationContext = (0, import_react.useMemo)(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let location2 = (0, import_react.useMemo)(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash,
      state,
      key
    };
  }, [basename, pathname, search, hash, state, key]);
  true ? warning(location2 != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : void 0;
  if (location2 == null) {
    return null;
  }
  return /* @__PURE__ */ (0, import_react.createElement)(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ (0, import_react.createElement)(LocationContext.Provider, {
    children,
    value: {
      location: location2,
      navigationType
    }
  }));
}
function useHref(to) {
  !useInRouterContext() ? true ? invariant(false, "useHref() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0, import_react.useContext)(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to);
  let joinedPathname = pathname;
  if (basename !== "/") {
    let toPathname = getToPathname(to);
    let endsWithSlash = toPathname != null && toPathname.endsWith("/");
    joinedPathname = pathname === "/" ? basename + (endsWithSlash ? "/" : "") : joinPaths([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return (0, import_react.useContext)(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? true ? invariant(false, "useLocation() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  return (0, import_react.useContext)(LocationContext).location;
}
function useNavigate() {
  !useInRouterContext() ? true ? invariant(false, "useNavigate() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = (0, import_react.useContext)(NavigationContext);
  let {
    matches
  } = (0, import_react.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  let activeRef = (0, import_react.useRef)(false);
  (0, import_react.useEffect)(() => {
    activeRef.current = true;
  });
  let navigate = (0, import_react.useCallback)(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    true ? warning(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered.") : void 0;
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);
    if (basename !== "/") {
      path.pathname = joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator.replace : navigator.push)(path, options.state);
  }, [basename, navigator, routePathnamesJson, locationPathname]);
  return navigate;
}
var OutletContext = /* @__PURE__ */ (0, import_react.createContext)(null);
function useOutlet(context) {
  let outlet = (0, import_react.useContext)(RouteContext).outlet;
  if (outlet) {
    return /* @__PURE__ */ (0, import_react.createElement)(OutletContext.Provider, {
      value: context
    }, outlet);
  }
  return outlet;
}
function useResolvedPath(to) {
  let {
    matches
  } = (0, import_react.useContext)(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(matches.map((match) => match.pathnameBase));
  return (0, import_react.useMemo)(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);
}
function useRoutes(routes2, locationArg) {
  !useInRouterContext() ? true ? invariant(false, "useRoutes() may be used only in the context of a <Router> component.") : invariant(false) : void 0;
  let {
    matches: parentMatches
  } = (0, import_react.useContext)(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (true) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
  }
  let locationFromContext = useLocation();
  let location2;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? true ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')) : invariant(false) : void 0;
    location2 = parsedLocationArg;
  } else {
    location2 = locationFromContext;
  }
  let pathname = location2.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes2, {
    pathname: remainingPathname
  });
  if (true) {
    true ? warning(parentRoute || matches != null, 'No routes matched location "' + location2.pathname + location2.search + location2.hash + '" ') : void 0;
    true ? warning(matches == null || matches[matches.length - 1].route.element !== void 0, 'Matched leaf route at location "' + location2.pathname + location2.search + location2.hash + '" does not have an element. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.') : void 0;
  }
  return _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([parentPathnameBase, match.pathname]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])
  })), parentMatches);
}
function matchRoutes(routes2, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location2.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes2);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(branches[i], pathname);
  }
  return matches;
}
function flattenRoutes(routes2, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes2.forEach((route, index2) => {
    let meta2 = {
      relativePath: route.path || "",
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta2.relativePath.startsWith("/")) {
      !meta2.relativePath.startsWith(parentPath) ? true ? invariant(false, 'Absolute route path "' + meta2.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.") : invariant(false) : void 0;
      meta2.relativePath = meta2.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta2.relativePath]);
    let routesMeta = parentsMeta.concat(meta2);
    if (route.children && route.children.length > 0) {
      !(route.index !== true) ? true ? invariant(false, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')) : invariant(false) : void 0;
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a, b) => a.score !== b.score ? b.score - a.score : compareIndexes(a.routesMeta.map((meta2) => meta2.childrenIndex), b.routesMeta.map((meta2) => meta2.childrenIndex)));
}
var paramRe = /^:\w+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s) => s === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a, b) {
  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);
  return siblings ? a[a.length - 1] - b[b.length - 1] : 0;
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta2 = routesMeta[i];
    let end = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta2.relativePath,
      caseSensitive: meta2.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta2.route;
    matches.push({
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function _renderMatches(matches, parentMatches) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null)
    return null;
  return matches.reduceRight((outlet, match, index2) => {
    return /* @__PURE__ */ (0, import_react.createElement)(RouteContext.Provider, {
      children: match.route.element !== void 0 ? match.route.element : outlet,
      value: {
        outlet,
        matches: parentMatches.concat(matches.slice(0, index2 + 1))
      }
    });
  }, null);
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo2, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo2[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo2;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  true ? warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".')) : void 0;
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else {
    regexpSource += end ? "\\/*$" : "(?:(?=[.~-]|%[0-9A-F]{2})|\\b|\\/|$)";
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    true ? warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ").")) : void 0;
    return value;
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function resolveTo(toArg, routePathnames, locationPathname) {
  let to = typeof toArg === "string" ? parsePath(toArg) : toArg;
  let toPathname = toArg === "" || to.pathname === "" ? "/" : to.pathname;
  let from2;
  if (toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  if (toPathname && toPathname !== "/" && toPathname.endsWith("/") && !path.pathname.endsWith("/")) {
    path.pathname += "/";
  }
  return path;
}
function getToPathname(to) {
  return to === "" || to.pathname === "" ? "/" : typeof to === "string" ? parsePath(to).pathname : to.pathname;
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let nextChar = pathname.charAt(basename.length);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(basename.length) || "/";
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;

// node_modules/react-router-dom/index.js
function _extends2() {
  _extends2 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded = ["onClick", "reloadDocument", "replace", "state", "target", "to"];
var _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = (0, import_react2.useState)({
    action: history.action,
    location: history.location
  });
  (0, import_react2.useLayoutEffect)(() => history.listen(setState), [history]);
  return /* @__PURE__ */ (0, import_react2.createElement)(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
var Link = /* @__PURE__ */ (0, import_react2.forwardRef)(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    reloadDocument,
    replace = false,
    state,
    target,
    to
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
  let href = useHref(to);
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented && !reloadDocument) {
      internalOnClick(event);
    }
  }
  return /* @__PURE__ */ (0, import_react2.createElement)("a", _extends2({}, rest, {
    href,
    onClick: handleClick,
    ref,
    target
  }));
});
if (true) {
  Link.displayName = "Link";
}
var NavLink = /* @__PURE__ */ (0, import_react2.forwardRef)(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let location2 = useLocation();
  let path = useResolvedPath(to);
  let locationPathname = location2.pathname;
  let toPathname = path.pathname;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive
    });
  } else {
    className = [classNameProp, isActive ? "active" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive
  }) : styleProp;
  return /* @__PURE__ */ (0, import_react2.createElement)(Link, _extends2({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to
  }), typeof children === "function" ? children({
    isActive
  }) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location2 = useLocation();
  let path = useResolvedPath(to);
  return (0, import_react2.useCallback)((event) => {
    if (event.button === 0 && (!target || target === "_self") && !isModifiedEvent(event)) {
      event.preventDefault();
      let replace = !!replaceProp || createPath(location2) === createPath(path);
      navigate(to, {
        replace,
        state
      });
    }
  }, [location2, navigate, path, replaceProp, state, target, to]);
}

// node_modules/@remix-run/server-runtime/esm/routeMatching.js
function matchServerRoutes(routes2, pathname) {
  let matches = matchRoutes(routes2, pathname);
  if (!matches)
    return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// node_modules/@remix-run/server-runtime/esm/mode.js
init_react();
var ServerMode;
(function(ServerMode2) {
  ServerMode2["Development"] = "development";
  ServerMode2["Production"] = "production";
  ServerMode2["Test"] = "test";
})(ServerMode || (ServerMode = {}));
function isServerMode(value) {
  return value === ServerMode.Development || value === ServerMode.Production || value === ServerMode.Test;
}

// node_modules/@remix-run/server-runtime/esm/routes.js
init_react();
function createRoutes(manifest, parentId) {
  return Object.keys(manifest).filter((key) => manifest[key].parentId === parentId).map((id) => __spreadProps(__spreadValues({}, manifest[id]), {
    children: createRoutes(manifest, id)
  }));
}

// node_modules/@remix-run/server-runtime/esm/serverHandoff.js
init_react();
var import_jsesc = __toESM(require_jsesc());
function createServerHandoffString(serverHandoff) {
  return (0, import_jsesc.default)(serverHandoff, {
    isScriptContext: true
  });
}

// node_modules/@remix-run/server-runtime/esm/server.js
function createRequestHandler(build, platform2, mode) {
  let routes2 = createRoutes(build.routes);
  let serverMode = isServerMode(mode) ? mode : ServerMode.Production;
  return async function requestHandler(request, loadContext) {
    let url = new URL(request.url);
    let matches = matchServerRoutes(routes2, url.pathname);
    let requestType = getRequestType(url, matches);
    let response;
    switch (requestType) {
      case "data":
        response = await handleDataRequest({
          request,
          loadContext,
          matches,
          handleDataRequest: build.entry.module.handleDataRequest,
          serverMode
        });
        break;
      case "document":
        response = await renderDocumentRequest({
          build,
          loadContext,
          matches,
          request,
          routes: routes2,
          serverMode
        });
        break;
      case "resource":
        response = await handleResourceRequest({
          request,
          loadContext,
          matches,
          serverMode
        });
        break;
    }
    if (request.method.toLowerCase() === "head") {
      return new Response(null, {
        headers: response.headers,
        status: response.status,
        statusText: response.statusText
      });
    }
    return response;
  };
}
async function handleDataRequest({
  handleDataRequest: handleDataRequest2,
  loadContext,
  matches,
  request,
  serverMode
}) {
  if (!isValidRequestMethod(request)) {
    return errorBoundaryError(new Error(`Invalid request method "${request.method}"`), 405);
  }
  let url = new URL(request.url);
  if (!matches) {
    return errorBoundaryError(new Error(`No route matches URL "${url.pathname}"`), 404);
  }
  let response;
  let match;
  try {
    if (isActionRequest(request)) {
      match = getActionRequestMatch(url, matches);
      response = await callRouteAction({
        loadContext,
        match,
        request
      });
    } else {
      let routeId = url.searchParams.get("_data");
      if (!routeId) {
        return errorBoundaryError(new Error(`Missing route id in ?_data`), 403);
      }
      let tempMatch = matches.find((match2) => match2.route.id === routeId);
      if (!tempMatch) {
        return errorBoundaryError(new Error(`Route "${routeId}" does not match URL "${url.pathname}"`), 403);
      }
      match = tempMatch;
      response = await callRouteLoader({
        loadContext,
        match,
        request
      });
    }
    if (isRedirectResponse(response)) {
      let headers = new Headers(response.headers);
      headers.set("X-Remix-Redirect", headers.get("Location"));
      headers.delete("Location");
      return new Response(null, {
        status: 204,
        headers
      });
    }
    if (handleDataRequest2) {
      response = await handleDataRequest2(response.clone(), {
        context: loadContext,
        params: match.params,
        request: request.clone()
      });
    }
    return response;
  } catch (error) {
    if (serverMode !== ServerMode.Test) {
      console.error(error);
    }
    if (serverMode === ServerMode.Development) {
      return errorBoundaryError(error, 500);
    }
    return errorBoundaryError(new Error("Unexpected Server Error"), 500);
  }
}
async function renderDocumentRequest({
  build,
  loadContext,
  matches,
  request,
  routes: routes2,
  serverMode
}) {
  let url = new URL(request.url);
  let appState = {
    trackBoundaries: true,
    trackCatchBoundaries: true,
    catchBoundaryRouteId: null,
    renderBoundaryRouteId: null,
    loaderBoundaryRouteId: null,
    error: void 0,
    catch: void 0
  };
  if (!isValidRequestMethod(request)) {
    matches = null;
    appState.trackCatchBoundaries = false;
    appState.catch = {
      data: null,
      status: 405,
      statusText: "Method Not Allowed"
    };
  } else if (!matches) {
    appState.trackCatchBoundaries = false;
    appState.catch = {
      data: null,
      status: 404,
      statusText: "Not Found"
    };
  }
  let actionStatus;
  let actionData;
  let actionMatch;
  let actionResponse;
  if (matches && isActionRequest(request)) {
    actionMatch = getActionRequestMatch(url, matches);
    try {
      actionResponse = await callRouteAction({
        loadContext,
        match: actionMatch,
        request
      });
      if (isRedirectResponse(actionResponse)) {
        return actionResponse;
      }
      actionStatus = {
        status: actionResponse.status,
        statusText: actionResponse.statusText
      };
      if (isCatchResponse(actionResponse)) {
        appState.catchBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "CatchBoundary");
        appState.trackCatchBoundaries = false;
        appState.catch = __spreadProps(__spreadValues({}, actionStatus), {
          data: await extractData(actionResponse)
        });
      } else {
        actionData = {
          [actionMatch.route.id]: await extractData(actionResponse)
        };
      }
    } catch (error) {
      appState.loaderBoundaryRouteId = getDeepestRouteIdWithBoundary(matches, "ErrorBoundary");
      appState.trackBoundaries = false;
      appState.error = await serializeError(error);
      if (serverMode !== ServerMode.Test) {
        console.error(`There was an error running the action for route ${actionMatch.route.id}`);
      }
    }
  }
  let routeModules = createEntryRouteModules(build.routes);
  let matchesToLoad = matches || [];
  if (appState.catch) {
    matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad.slice(0, -1), "CatchBoundary");
  } else if (appState.error) {
    matchesToLoad = getMatchesUpToDeepestBoundary(matchesToLoad.slice(0, -1), "ErrorBoundary");
  }
  let routeLoaderResults = await Promise.allSettled(matchesToLoad.map((match) => match.route.module.loader ? callRouteLoader({
    loadContext,
    match,
    request
  }) : Promise.resolve(void 0)));
  let actionCatch = appState.catch;
  let actionError = appState.error;
  let actionCatchBoundaryRouteId = appState.catchBoundaryRouteId;
  let actionLoaderBoundaryRouteId = appState.loaderBoundaryRouteId;
  appState.catch = void 0;
  appState.error = void 0;
  let routeLoaderResponses = {};
  let loaderStatusCodes = [];
  let routeData = {};
  for (let index2 = 0; index2 < matchesToLoad.length; index2++) {
    let match = matchesToLoad[index2];
    let result = routeLoaderResults[index2];
    let error = result.status === "rejected" ? result.reason : void 0;
    let response = result.status === "fulfilled" ? result.value : void 0;
    let isRedirect = response ? isRedirectResponse(response) : false;
    let isCatch = response ? isCatchResponse(response) : false;
    if (appState.catch || appState.error) {
      break;
    }
    if (!actionCatch && !actionError && response && isRedirect) {
      return response;
    }
    if (match.route.module.CatchBoundary) {
      appState.catchBoundaryRouteId = match.route.id;
    }
    if (match.route.module.ErrorBoundary) {
      appState.loaderBoundaryRouteId = match.route.id;
    }
    if (error) {
      loaderStatusCodes.push(500);
      appState.trackBoundaries = false;
      appState.error = await serializeError(error);
      if (serverMode !== ServerMode.Test) {
        console.error(`There was an error running the data loader for route ${match.route.id}`);
      }
      break;
    } else if (response) {
      routeLoaderResponses[match.route.id] = response;
      loaderStatusCodes.push(response.status);
      if (isCatch) {
        appState.trackCatchBoundaries = false;
        appState.catch = {
          data: await extractData(response),
          status: response.status,
          statusText: response.statusText
        };
        break;
      } else {
        routeData[match.route.id] = await extractData(response);
      }
    }
  }
  if (!appState.catch) {
    appState.catchBoundaryRouteId = actionCatchBoundaryRouteId;
  }
  if (!appState.error) {
    appState.loaderBoundaryRouteId = actionLoaderBoundaryRouteId;
  }
  appState.catch = actionCatch || appState.catch;
  appState.error = actionError || appState.error;
  let renderableMatches = getRenderableMatches(matches, appState);
  if (!renderableMatches) {
    renderableMatches = [];
    let root = routes2[0];
    if (root !== null && root !== void 0 && root.module.CatchBoundary) {
      appState.catchBoundaryRouteId = "root";
      renderableMatches.push({
        params: {},
        pathname: "",
        route: routes2[0]
      });
    }
  }
  let notOkResponse = actionStatus && actionStatus.status !== 200 ? actionStatus.status : loaderStatusCodes.find((status) => status !== 200);
  let responseStatusCode = appState.error ? 500 : typeof notOkResponse === "number" ? notOkResponse : appState.catch ? appState.catch.status : 200;
  let responseHeaders = getDocumentHeaders(build, renderableMatches, routeLoaderResponses, actionResponse);
  let entryMatches = createEntryMatches(renderableMatches, build.assets.routes);
  let serverHandoff = {
    actionData,
    appState,
    matches: entryMatches,
    routeData
  };
  let entryContext = __spreadProps(__spreadValues({}, serverHandoff), {
    manifest: build.assets,
    routeModules,
    serverHandoffString: createServerHandoffString(serverHandoff)
  });
  let handleDocumentRequest = build.entry.module.default;
  try {
    return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);
  } catch (error) {
    responseStatusCode = 500;
    appState.trackBoundaries = false;
    appState.error = await serializeError(error);
    entryContext.serverHandoffString = createServerHandoffString(serverHandoff);
    try {
      return await handleDocumentRequest(request.clone(), responseStatusCode, responseHeaders, entryContext);
    } catch (error2) {
      if (serverMode !== ServerMode.Test) {
        console.error(error2);
      }
      let message = "Unexpected Server Error";
      if (serverMode === ServerMode.Development) {
        message += `

${String(error2)}`;
      }
      return new Response(message, {
        status: 500,
        headers: {
          "Content-Type": "text/plain"
        }
      });
    }
  }
}
async function handleResourceRequest({
  loadContext,
  matches,
  request,
  serverMode
}) {
  let match = matches.slice(-1)[0];
  try {
    if (isActionRequest(request)) {
      return await callRouteAction({
        match,
        loadContext,
        request
      });
    } else {
      return await callRouteLoader({
        match,
        loadContext,
        request
      });
    }
  } catch (error) {
    if (serverMode !== ServerMode.Test) {
      console.error(error);
    }
    let message = "Unexpected Server Error";
    if (serverMode === ServerMode.Development) {
      message += `

${String(error)}`;
    }
    return new Response(message, {
      status: 500,
      headers: {
        "Content-Type": "text/plain"
      }
    });
  }
}
function getRequestType(url, matches) {
  if (url.searchParams.has("_data")) {
    return "data";
  }
  if (!matches) {
    return "document";
  }
  let match = matches.slice(-1)[0];
  if (!match.route.module.default) {
    return "resource";
  }
  return "document";
}
function isActionRequest(request) {
  let method = request.method.toLowerCase();
  return method === "post" || method === "put" || method === "patch" || method === "delete";
}
function isHeadRequest(request) {
  return request.method.toLowerCase() === "head";
}
function isValidRequestMethod(request) {
  return request.method.toLowerCase() === "get" || isHeadRequest(request) || isActionRequest(request);
}
async function errorBoundaryError(error, status) {
  return json(await serializeError(error), {
    status,
    headers: {
      "X-Remix-Error": "yes"
    }
  });
}
function isIndexRequestUrl(url) {
  let indexRequest = false;
  for (let param of url.searchParams.getAll("index")) {
    if (!param) {
      indexRequest = true;
    }
  }
  return indexRequest;
}
function getActionRequestMatch(url, matches) {
  let match = matches.slice(-1)[0];
  if (!isIndexRequestUrl(url) && match.route.id.endsWith("/index")) {
    return matches.slice(-2)[0];
  }
  return match;
}
function getDeepestRouteIdWithBoundary(matches, key) {
  let matched = getMatchesUpToDeepestBoundary(matches, key).slice(-1)[0];
  return matched ? matched.route.id : null;
}
function getMatchesUpToDeepestBoundary(matches, key) {
  let deepestBoundaryIndex = -1;
  matches.forEach((match, index2) => {
    if (match.route.module[key]) {
      deepestBoundaryIndex = index2;
    }
  });
  if (deepestBoundaryIndex === -1) {
    return [];
  }
  return matches.slice(0, deepestBoundaryIndex + 1);
}
function getRenderableMatches(matches, appState) {
  if (!matches) {
    return null;
  }
  if (!appState.catch && !appState.error) {
    return matches;
  }
  let lastRenderableIndex = -1;
  matches.forEach((match, index2) => {
    let id = match.route.id;
    if (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id || appState.catchBoundaryRouteId === id) {
      lastRenderableIndex = index2;
    }
  });
  return matches.slice(0, lastRenderableIndex + 1);
}

// node_modules/@remix-run/cloudflare-pages/esm/worker.js
init_react();
function createRequestHandler2({
  build,
  getLoadContext,
  mode
}) {
  let platform2 = {};
  let handleRequest3 = createRequestHandler(build, platform2, mode);
  return (context) => {
    let loadContext = typeof getLoadContext === "function" ? getLoadContext(context) : void 0;
    return handleRequest3(context.request, loadContext);
  };
}
function createPagesFunctionHandler({
  build,
  getLoadContext,
  mode
}) {
  const handleRequest3 = createRequestHandler2({
    build,
    getLoadContext,
    mode
  });
  const handleFetch = async (context) => {
    let response;
    context.request.headers.delete("if-none-match");
    try {
      response = await context.env.ASSETS.fetch(context.request.url, context.request.clone());
      response = response && response.status >= 200 && response.status < 400 ? new Response(response.body, response) : void 0;
    } catch {
    }
    if (!response) {
      response = await handleRequest3(context);
    }
    return response;
  };
  return async (context) => {
    try {
      return await handleFetch(context);
    } catch (e) {
      if (e instanceof Error) {
        console.error(e);
        return new Response(e.message || e.toString(), {
          status: 500
        });
      }
      return new Response("Internal Error", {
        status: 500
      });
    }
  };
}

// node_modules/@remix-run/cloudflare-pages/esm/index.js
installGlobals();

// server-entry-module:@remix-run/dev/server-build
var server_build_exports = {};
__export(server_build_exports, {
  assets: () => assets_manifest_default,
  entry: () => entry,
  routes: () => routes
});
init_react();

// app/entry.server.tsx
var entry_server_exports = {};
__export(entry_server_exports, {
  default: () => handleRequest
});
init_react();
var import_server3 = __toESM(require_server());

// node_modules/remix/esm/index.js
init_react();

// node_modules/@remix-run/react/esm/index.js
init_react();

// node_modules/@remix-run/react/esm/components.js
init_react();

// node_modules/@remix-run/react/esm/_virtual/_rollupPluginBabelHelpers.js
init_react();
function _extends3() {
  _extends3 = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}

// node_modules/@remix-run/react/esm/components.js
var React3 = __toESM(require_react());

// node_modules/@remix-run/react/esm/errorBoundaries.js
init_react();
var import_react3 = __toESM(require_react());
var RemixErrorBoundary = class extends import_react3.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      error: props.error || null,
      location: props.location
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error || null,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  render() {
    if (this.state.error) {
      return /* @__PURE__ */ import_react3.default.createElement(this.props.component, {
        error: this.state.error
      });
    } else {
      return this.props.children;
    }
  }
};
function RemixRootDefaultErrorBoundary({
  error
}) {
  console.error(error);
  return /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Application Error!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("main", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontSize: "24px"
    }
  }, "Application Error"), /* @__PURE__ */ import_react3.default.createElement("pre", {
    style: {
      padding: "2rem",
      background: "hsla(10, 50%, 50%, 0.1)",
      color: "red",
      overflow: "auto"
    }
  }, error.stack)), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws errors. Check out https://remix.run/guides/errors for more information."
              );
            `
    }
  })));
}
var RemixCatchContext = /* @__PURE__ */ import_react3.default.createContext(void 0);
function useCatch() {
  return (0, import_react3.useContext)(RemixCatchContext);
}
function RemixCatchBoundary({
  catch: catchVal,
  component: Component2,
  children
}) {
  if (catchVal) {
    return /* @__PURE__ */ import_react3.default.createElement(RemixCatchContext.Provider, {
      value: catchVal
    }, /* @__PURE__ */ import_react3.default.createElement(Component2, null));
  }
  return /* @__PURE__ */ import_react3.default.createElement(import_react3.default.Fragment, null, children);
}
function RemixRootDefaultCatchBoundary() {
  let caught = useCatch();
  return /* @__PURE__ */ import_react3.default.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ import_react3.default.createElement("head", null, /* @__PURE__ */ import_react3.default.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ import_react3.default.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1,viewport-fit=cover"
  }), /* @__PURE__ */ import_react3.default.createElement("title", null, "Unhandled Thrown Response!")), /* @__PURE__ */ import_react3.default.createElement("body", null, /* @__PURE__ */ import_react3.default.createElement("h1", {
    style: {
      fontFamily: "system-ui, sans-serif",
      padding: "2rem"
    }
  }, caught.status, " ", caught.statusText), /* @__PURE__ */ import_react3.default.createElement("script", {
    dangerouslySetInnerHTML: {
      __html: `
              console.log(
                "\u{1F4BF} Hey developer\u{1F44B}. You can provide a way better UX than this when your app throws 404s (and other responses). Check out https://remix.run/guides/not-found for more information."
              );
            `
    }
  })));
}

// node_modules/@remix-run/react/esm/invariant.js
init_react();
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}

// node_modules/@remix-run/react/esm/links.js
init_react();

// node_modules/@remix-run/react/esm/routeModules.js
init_react();
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(route.module);
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error) {
    window.location.reload();
    return new Promise(() => {
    });
  }
}

// node_modules/@remix-run/react/esm/links.js
function getLinksForMatches(matches, routeModules, manifest) {
  let descriptors = matches.map((match) => {
    var _module$links;
    let module = routeModules[match.route.id];
    return ((_module$links = module.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module)) || [];
  }).flat(1);
  let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);
  return dedupe(descriptors, preloads);
}
async function prefetchStyleLinks(routeModule) {
  if (!routeModule.links)
    return;
  let descriptors = routeModule.links();
  if (!descriptors)
    return;
  let styleLinks = [];
  for (let descriptor of descriptors) {
    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === "stylesheet") {
      styleLinks.push(__spreadProps(__spreadValues({}, descriptor), {
        rel: "preload",
        as: "style"
      }));
    }
  }
  let matchingLinks = styleLinks.filter((link) => !link.media || window.matchMedia(link.media).matches);
  await Promise.all(matchingLinks.map(prefetchStyleLink));
}
async function prefetchStyleLink(descriptor) {
  return new Promise((resolve) => {
    let link = document.createElement("link");
    Object.assign(link, descriptor);
    function removeLink() {
      if (document.head.contains(link)) {
        document.head.removeChild(link);
      }
    }
    link.onload = () => {
      removeLink();
      resolve();
    };
    link.onerror = () => {
      removeLink();
      resolve();
    };
    document.head.appendChild(link);
  });
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page === "string";
}
function isHtmlLinkDescriptor(object) {
  return object != null && typeof object.rel === "string" && typeof object.href === "string";
}
async function getStylesheetPrefetchLinks(matches, routeModules) {
  let links3 = await Promise.all(matches.map(async (match) => {
    let mod = await loadRouteModule(match.route, routeModules);
    return mod.links ? mod.links() : [];
  }));
  return links3.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map((_a) => {
    var _b = _a, {
      rel
    } = _b, attrs = __objRest(_b, [
      "rel"
    ]);
    return rel === "preload" ? __spreadValues({
      rel: "prefetch"
    }, attrs) : __spreadValues({
      rel: "prefetch",
      as: "style"
    }, attrs);
  });
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, location2, mode) {
  let path = parsePathPatch(page);
  let isNew = (match, index2) => {
    if (!currentMatches[index2])
      return true;
    return match.route.id !== currentMatches[index2].route.id;
  };
  let matchPathChanged = (match, index2) => {
    var _currentMatches$index;
    return currentMatches[index2].pathname !== match.pathname || ((_currentMatches$index = currentMatches[index2].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith("*")) && currentMatches[index2].params["*"] !== match.params["*"];
  };
  let newMatches = mode === "data" && location2.search !== path.search ? nextMatches.filter((match, index2) => {
    if (!match.route.hasLoader) {
      return false;
    }
    if (isNew(match, index2) || matchPathChanged(match, index2)) {
      return true;
    }
    if (match.route.shouldReload) {
      return match.route.shouldReload({
        params: match.params,
        prevUrl: new URL(location2.pathname + location2.search + location2.hash, window.origin),
        url: new URL(page, window.origin)
      });
    }
    return true;
  }) : nextMatches.filter((match, index2) => {
    return (mode === "assets" || match.route.hasLoader) && (isNew(match, index2) || matchPathChanged(match, index2));
  });
  return newMatches;
}
function getDataLinkHrefs(page, matches, manifest) {
  let path = parsePathPatch(page);
  return dedupeHrefs(matches.filter((match) => manifest.routes[match.route.id].hasLoader).map((match) => {
    let {
      pathname,
      search
    } = path;
    let searchParams = new URLSearchParams(search);
    searchParams.set("_data", match.route.id);
    return `${pathname}?${searchParams}`;
  }));
}
function getModuleLinkHrefs(matches, manifestPatch) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifestPatch.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function getCurrentPageModulePreloadHrefs(matches, manifest) {
  return dedupeHrefs(matches.map((match) => {
    let route = manifest.routes[match.route.id];
    let hrefs = [route.module];
    if (route.imports) {
      hrefs = hrefs.concat(route.imports);
    }
    return hrefs;
  }).flat(1));
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function dedupe(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set();
  let preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let alreadyModulePreload = !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
    if (alreadyModulePreload) {
      return deduped;
    }
    let str = JSON.stringify(descriptor);
    if (!set.has(str)) {
      set.add(str);
      deduped.push(descriptor);
    }
    return deduped;
  }, []);
}
function parsePathPatch(href) {
  let path = parsePath(href);
  if (path.search === void 0)
    path.search = "";
  return path;
}

// node_modules/@remix-run/react/esm/markup.js
init_react();
function createHtml(html) {
  return {
    __html: html
  };
}

// node_modules/@remix-run/react/esm/routes.js
init_react();
var React2 = __toESM(require_react());

// node_modules/@remix-run/react/esm/data.js
init_react();
function isCatchResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Catch") != null;
}
function isErrorResponse(response) {
  return response instanceof Response && response.headers.get("X-Remix-Error") != null;
}
function isRedirectResponse2(response) {
  return response instanceof Response && response.headers.get("X-Remix-Redirect") != null;
}
async function fetchData(url, routeId, signal, submission) {
  url.searchParams.set("_data", routeId);
  let init2 = submission ? getActionInit(submission, signal) : {
    credentials: "same-origin",
    signal
  };
  let response = await fetch(url.href, init2);
  if (isErrorResponse(response)) {
    let data = await response.json();
    let error = new Error(data.message);
    error.stack = data.stack;
    return error;
  }
  return response;
}
async function extractData2(response) {
  let contentType = response.headers.get("Content-Type");
  if (contentType && /\bapplication\/json\b/.test(contentType)) {
    return response.json();
  }
  return response.text();
}
function getActionInit(submission, signal) {
  let {
    encType,
    method,
    formData
  } = submission;
  let headers = void 0;
  let body = formData;
  if (encType === "application/x-www-form-urlencoded") {
    body = new URLSearchParams();
    for (let [key, value] of formData) {
      invariant2(typeof value === "string", `File inputs are not supported with encType "application/x-www-form-urlencoded", please use "multipart/form-data" instead.`);
      body.append(key, value);
    }
    headers = {
      "Content-Type": encType
    };
  }
  return {
    method,
    body,
    signal,
    credentials: "same-origin",
    headers
  };
}

// node_modules/@remix-run/react/esm/transition.js
init_react();

// node_modules/@remix-run/react/esm/routeMatching.js
init_react();
function matchClientRoutes(routes2, location2) {
  let matches = matchRoutes(routes2, location2);
  if (!matches)
    return null;
  return matches.map((match) => ({
    params: match.params,
    pathname: match.pathname,
    route: match.route
  }));
}

// node_modules/@remix-run/react/esm/transition.js
var CatchValue = class {
  constructor(status, statusText, data) {
    this.status = status;
    this.statusText = statusText;
    this.data = data;
  }
};
function isActionSubmission(submission) {
  return ["POST", "PUT", "PATCH", "DELETE"].includes(submission.method);
}
function isLoaderSubmission(submission) {
  return submission.method === "GET";
}
function isRedirectLocation(location2) {
  return Boolean(location2.state) && location2.state.isRedirect;
}
function isLoaderRedirectLocation(location2) {
  return isRedirectLocation(location2) && location2.state.type === "loader";
}
function isActionRedirectLocation(location2) {
  return isRedirectLocation(location2) && location2.state.type === "action";
}
function isFetchActionRedirect(location2) {
  return isRedirectLocation(location2) && location2.state.type === "fetchAction";
}
function isLoaderSubmissionRedirectLocation(location2) {
  return isRedirectLocation(location2) && location2.state.type === "loaderSubmission";
}
var TransitionRedirect = class {
  constructor(location2) {
    this.location = typeof location2 === "string" ? location2 : location2.pathname + location2.search;
  }
};
var IDLE_TRANSITION = {
  state: "idle",
  submission: void 0,
  location: void 0,
  type: "idle"
};
var IDLE_FETCHER = {
  state: "idle",
  type: "init",
  data: void 0,
  submission: void 0
};
function createTransitionManager(init2) {
  let {
    routes: routes2
  } = init2;
  let pendingNavigationController;
  let fetchControllers = /* @__PURE__ */ new Map();
  let incrementingLoadId = 0;
  let navigationLoadId = -1;
  let fetchReloadIds = /* @__PURE__ */ new Map();
  let matches = matchClientRoutes(routes2, init2.location);
  if (!matches) {
    matches = [{
      params: {},
      pathname: "",
      route: routes2[0]
    }];
  }
  let state = {
    location: init2.location,
    loaderData: init2.loaderData || {},
    actionData: init2.actionData,
    catch: init2.catch,
    error: init2.error,
    catchBoundaryId: init2.catchBoundaryId || null,
    errorBoundaryId: init2.errorBoundaryId || null,
    matches,
    nextMatches: void 0,
    transition: IDLE_TRANSITION,
    fetchers: /* @__PURE__ */ new Map()
  };
  function update(updates) {
    state = Object.assign({}, state, updates);
    init2.onChange(state);
  }
  function getState() {
    return state;
  }
  function getFetcher(key) {
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    if (fetchControllers.has(key))
      abortFetcher(key);
    fetchReloadIds.delete(key);
    state.fetchers.delete(key);
  }
  async function send2(event) {
    switch (event.type) {
      case "navigation": {
        let {
          action,
          location: location2,
          submission
        } = event;
        let matches2 = matchClientRoutes(routes2, location2);
        if (!matches2) {
          matches2 = [{
            params: {},
            pathname: "",
            route: routes2[0]
          }];
          await handleNotFoundNavigation(location2, matches2);
        } else if (!submission && isHashChangeOnly(location2)) {
          await handleHashChange(location2, matches2);
        } else if (action === Action.Pop) {
          await handleLoad(location2, matches2);
        } else if (submission && isActionSubmission(submission)) {
          await handleActionSubmissionNavigation(location2, submission, matches2);
        } else if (submission && isLoaderSubmission(submission)) {
          await handleLoaderSubmissionNavigation(location2, submission, matches2);
        } else if (isActionRedirectLocation(location2)) {
          await handleActionRedirect(location2, matches2);
        } else if (isLoaderSubmissionRedirectLocation(location2)) {
          await handleLoaderSubmissionRedirect(location2, matches2);
        } else if (isLoaderRedirectLocation(location2)) {
          await handleLoaderRedirect(location2, matches2);
        } else if (isFetchActionRedirect(location2)) {
          await handleFetchActionRedirect(location2, matches2);
        } else {
          await handleLoad(location2, matches2);
        }
        navigationLoadId = -1;
        break;
      }
      case "fetcher": {
        let {
          key,
          submission,
          href
        } = event;
        let matches2 = matchClientRoutes(routes2, href);
        invariant2(matches2, "No matches found");
        let match = matches2.slice(-1)[0];
        if (fetchControllers.has(key))
          abortFetcher(key);
        if (submission && isActionSubmission(submission)) {
          await handleActionFetchSubmission(key, submission, match);
        } else if (submission && isLoaderSubmission(submission)) {
          await handleLoaderFetchSubmission(href, key, submission, match);
        } else {
          await handleLoaderFetch(href, key, match);
        }
        break;
      }
      default: {
        throw new Error(`Unknown data event type: ${event.type}`);
      }
    }
  }
  function dispose() {
    abortNormalNavigation();
    for (let [, controller] of fetchControllers) {
      controller.abort();
    }
  }
  async function handleActionFetchSubmission(key, submission, match) {
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "submitting",
      type: "actionSubmission",
      submission,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callAction(submission, match, controller.signal);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "fetchAction"
      };
      init2.onRedirect(result.value.location, locationState);
      let doneFetcher2 = {
        state: "idle",
        type: "done",
        data: result.value,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher2);
      update({
        fetchers: new Map(state.fetchers)
      });
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let loadFetcher = {
      state: "loading",
      type: "actionReload",
      data: result.value,
      submission
    };
    state.fetchers.set(key, loadFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let maybeActionErrorResult = isErrorResult(result) ? result : void 0;
    let maybeActionCatchResult = isCatchResult(result) ? result : void 0;
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let matchesToLoad = state.nextMatches || state.matches;
    let hrefToLoad = createHref(state.transition.location || state.location);
    let results = await callLoaders(state, createUrl(hrefToLoad), matchesToLoad, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, match.route.id, loadFetcher);
    if (controller.signal.aborted) {
      return;
    }
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    let redirect = findRedirect(results);
    if (redirect) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(redirect.location, locationState);
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, state.matches, maybeActionErrorResult);
    let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, state.matches, maybeActionCatchResult);
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    let abortedKeys = abortStaleFetchLoads(loadId);
    if (abortedKeys) {
      markFetchersDone(abortedKeys);
    }
    let yeetedNavigation = yeetStaleNavigationLoad(loadId);
    if (yeetedNavigation) {
      let {
        transition
      } = state;
      invariant2(transition.state === "loading", "Expected loading transition");
      update({
        location: transition.location,
        matches: state.nextMatches,
        error,
        errorBoundaryId,
        catch: catchVal,
        catchBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad),
        actionData: transition.type === "actionReload" ? state.actionData : void 0,
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers)
      });
    } else {
      update({
        fetchers: new Map(state.fetchers),
        error,
        errorBoundaryId,
        loaderData: makeLoaderData(state, results, matchesToLoad)
      });
    }
  }
  function yeetStaleNavigationLoad(landedId) {
    let isLoadingNavigation = state.transition.state === "loading";
    if (isLoadingNavigation && navigationLoadId < landedId) {
      abortNormalNavigation();
      return true;
    }
    return false;
  }
  function markFetchersDone(keys2) {
    for (let key of keys2) {
      let fetcher = getFetcher(key);
      let doneFetcher = {
        state: "idle",
        type: "done",
        data: fetcher.data,
        submission: void 0
      };
      state.fetchers.set(key, doneFetcher);
    }
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id] of fetchReloadIds) {
      if (id < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant2(fetcher, `Expected fetcher: ${key}`);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    return yeetedKeys.length ? yeetedKeys : false;
  }
  async function handleLoaderFetchSubmission(href, key, submission, match) {
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "submitting",
      type: "loaderSubmission",
      submission,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    fetchControllers.delete(key);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function handleLoaderFetch(href, key, match) {
    if (typeof AbortController === "undefined") {
      throw new Error("handleLoaderFetch was called during the server render, but it shouldn't be. You are likely calling useFetcher.load() in the body of your component. Try moving it to a useEffect or a callback.");
    }
    let currentFetcher = state.fetchers.get(key);
    let fetcher = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      data: (currentFetcher === null || currentFetcher === void 0 ? void 0 : currentFetcher.data) || void 0
    };
    state.fetchers.set(key, fetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
    let controller = new AbortController();
    fetchControllers.set(key, controller);
    let result = await callLoader(match, createUrl(href), controller.signal);
    if (controller.signal.aborted)
      return;
    fetchControllers.delete(key);
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "loader"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (maybeBailOnError(match, key, result)) {
      return;
    }
    if (await maybeBailOnCatch(match, key, result)) {
      return;
    }
    let doneFetcher = {
      state: "idle",
      type: "done",
      data: result.value,
      submission: void 0
    };
    state.fetchers.set(key, doneFetcher);
    update({
      fetchers: new Map(state.fetchers)
    });
  }
  async function maybeBailOnCatch(match, key, result) {
    if (isCatchResult(result)) {
      let catchBoundaryId = findNearestCatchBoundary(match, state.matches);
      state.fetchers.delete(key);
      update({
        transition: IDLE_TRANSITION,
        fetchers: new Map(state.fetchers),
        catch: {
          data: result.value.data,
          status: result.value.status,
          statusText: result.value.statusText
        },
        catchBoundaryId
      });
      return true;
    }
    return false;
  }
  function maybeBailOnError(match, key, result) {
    if (isErrorResult(result)) {
      let errorBoundaryId = findNearestBoundary(match, state.matches);
      state.fetchers.delete(key);
      update({
        fetchers: new Map(state.fetchers),
        error: result.value,
        errorBoundaryId
      });
      return true;
    }
    return false;
  }
  async function handleNotFoundNavigation(location2, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await Promise.resolve();
    let catchBoundaryId = findNearestCatchBoundary(matches2[0], matches2);
    update({
      location: location2,
      matches: matches2,
      catch: {
        data: null,
        status: 404,
        statusText: "Not Found"
      },
      catchBoundaryId,
      transition: IDLE_TRANSITION
    });
  }
  async function handleActionSubmissionNavigation(location2, submission, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "submitting",
      type: "actionSubmission",
      submission,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    let controller = new AbortController();
    pendingNavigationController = controller;
    if (!isIndexRequestAction(submission.action) && matches2[matches2.length - 1].route.id.endsWith("/index")) {
      matches2 = matches2.slice(0, -1);
    }
    let leafMatch = matches2.slice(-1)[0];
    let result = await callAction(submission, leafMatch, controller.signal);
    if (controller.signal.aborted) {
      return;
    }
    if (isRedirectResult(result)) {
      let locationState = {
        isRedirect: true,
        type: "action"
      };
      init2.onRedirect(result.value.location, locationState);
      return;
    }
    if (isCatchResult(result)) {
      let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId([result], matches2, result);
      update({
        transition: IDLE_TRANSITION,
        catch: catchVal,
        catchBoundaryId
      });
      return;
    }
    let loadTransition = {
      state: "loading",
      type: "actionReload",
      submission,
      location: location2
    };
    update({
      transition: loadTransition,
      actionData: {
        [leafMatch.route.id]: result.value
      }
    });
    await loadPageData(location2, matches2, submission, leafMatch.route.id, result);
  }
  async function handleLoaderSubmissionNavigation(location2, submission, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "submitting",
      type: "loaderSubmission",
      submission,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location2, matches2, submission);
  }
  async function handleHashChange(location2, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await Promise.resolve();
    update({
      location: location2,
      matches: matches2,
      transition: IDLE_TRANSITION
    });
  }
  async function handleLoad(location2, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalLoad",
      submission: void 0,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location2, matches2);
  }
  async function handleLoaderRedirect(location2, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "normalRedirect",
      submission: void 0,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location2, matches2);
  }
  async function handleLoaderSubmissionRedirect(location2, matches2) {
    abortNormalNavigation();
    invariant2(state.transition.type === "loaderSubmission", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    let transition = {
      state: "loading",
      type: "loaderSubmissionRedirect",
      submission,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location2, matches2, submission);
  }
  async function handleFetchActionRedirect(location2, matches2) {
    abortNormalNavigation();
    let transition = {
      state: "loading",
      type: "fetchActionRedirect",
      submission: void 0,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location2, matches2);
  }
  async function handleActionRedirect(location2, matches2) {
    abortNormalNavigation();
    invariant2(state.transition.type === "actionSubmission" || state.transition.type === "actionReload", `Unexpected transition: ${JSON.stringify(state.transition)}`);
    let {
      submission
    } = state.transition;
    let transition = {
      state: "loading",
      type: "actionRedirect",
      submission,
      location: location2
    };
    update({
      transition,
      nextMatches: matches2
    });
    await loadPageData(location2, matches2, submission);
  }
  function isHashChangeOnly(location2) {
    return createHref(state.location) === createHref(location2) && state.location.hash !== location2.hash;
  }
  async function loadPageData(location2, matches2, submission, submissionRouteId, actionResult) {
    let maybeActionErrorResult = actionResult && isErrorResult(actionResult) ? actionResult : void 0;
    let maybeActionCatchResult = actionResult && isCatchResult(actionResult) ? actionResult : void 0;
    let controller = new AbortController();
    pendingNavigationController = controller;
    navigationLoadId = ++incrementingLoadId;
    let results = await callLoaders(state, createUrl(createHref(location2)), matches2, controller.signal, maybeActionErrorResult, maybeActionCatchResult, submission, submissionRouteId);
    if (controller.signal.aborted) {
      return;
    }
    let redirect = findRedirect(results);
    if (redirect) {
      if (state.transition.type === "actionReload") {
        let locationState = {
          isRedirect: true,
          type: "action"
        };
        init2.onRedirect(redirect.location, locationState);
      } else if (state.transition.type === "loaderSubmission") {
        let locationState = {
          isRedirect: true,
          type: "loaderSubmission"
        };
        init2.onRedirect(redirect.location, locationState);
      } else {
        let locationState = {
          isRedirect: true,
          type: "loader"
        };
        init2.onRedirect(redirect.location, locationState);
      }
      return;
    }
    let [error, errorBoundaryId] = findErrorAndBoundaryId(results, matches2, maybeActionErrorResult);
    let [catchVal, catchBoundaryId] = await findCatchAndBoundaryId(results, matches2, maybeActionErrorResult);
    let abortedIds = abortStaleFetchLoads(navigationLoadId);
    if (abortedIds) {
      markFetchersDone(abortedIds);
    }
    update({
      location: location2,
      matches: matches2,
      error,
      errorBoundaryId,
      catch: catchVal,
      catchBoundaryId,
      loaderData: makeLoaderData(state, results, matches2),
      actionData: state.transition.type === "actionReload" ? state.actionData : void 0,
      transition: IDLE_TRANSITION,
      fetchers: abortedIds ? new Map(state.fetchers) : state.fetchers
    });
  }
  function abortNormalNavigation() {
    var _pendingNavigationCon;
    (_pendingNavigationCon = pendingNavigationController) === null || _pendingNavigationCon === void 0 ? void 0 : _pendingNavigationCon.abort();
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    invariant2(controller, `Expected fetch controller: ${key}`);
    controller.abort();
    fetchControllers.delete(key);
  }
  return {
    send: send2,
    getState,
    getFetcher,
    deleteFetcher,
    dispose,
    get _internalFetchControllers() {
      return fetchControllers;
    }
  };
}
function isIndexRequestAction(action) {
  let indexRequest = false;
  let searchParams = new URLSearchParams(action.split("?", 2)[1] || "");
  for (let param of searchParams.getAll("index")) {
    if (!param) {
      indexRequest = true;
    }
  }
  return indexRequest;
}
async function callLoaders(state, url, matches, signal, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  let matchesToLoad = filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher);
  return Promise.all(matchesToLoad.map((match) => callLoader(match, url, signal)));
}
async function callLoader(match, url, signal) {
  invariant2(match.route.loader, `Expected loader for ${match.route.id}`);
  try {
    let {
      params
    } = match;
    let value = await match.route.loader({
      params,
      url,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
async function callAction(submission, match, signal) {
  if (!match.route.action) {
    throw new Error(`Route "${match.route.id}" does not have an action, but you are trying to submit to it. To fix this, please add an \`action\` function to the route`);
  }
  try {
    let value = await match.route.action({
      url: createUrl(submission.action),
      params: match.params,
      submission,
      signal
    });
    return {
      match,
      value
    };
  } catch (error) {
    return {
      match,
      value: error
    };
  }
}
function filterMatchesToLoad(state, url, matches, actionErrorResult, actionCatchResult, submission, submissionRouteId, fetcher) {
  if (submissionRouteId && (actionCatchResult || actionErrorResult)) {
    let foundProblematicRoute = false;
    matches = matches.filter((match) => {
      if (foundProblematicRoute) {
        return false;
      }
      if (match.route.id === submissionRouteId) {
        foundProblematicRoute = true;
        return false;
      }
      return true;
    });
  }
  let isNew = (match, index2) => {
    if (!state.matches[index2])
      return true;
    return match.route.id !== state.matches[index2].route.id;
  };
  let matchPathChanged = (match, index2) => {
    var _state$matches$index$;
    return state.matches[index2].pathname !== match.pathname || ((_state$matches$index$ = state.matches[index2].route.path) === null || _state$matches$index$ === void 0 ? void 0 : _state$matches$index$.endsWith("*")) && state.matches[index2].params["*"] !== match.params["*"];
  };
  let filterByRouteProps = (match, index2) => {
    if (!match.route.loader) {
      return false;
    }
    if (isNew(match, index2) || matchPathChanged(match, index2)) {
      return true;
    }
    if (match.route.shouldReload) {
      let prevUrl = createUrl(createHref(state.location));
      return match.route.shouldReload({
        prevUrl,
        url,
        submission,
        params: match.params
      });
    }
    return true;
  };
  let isInRootCatchBoundary = state.matches.length === 1;
  if (isInRootCatchBoundary) {
    return matches.filter((match) => !!match.route.loader);
  }
  if ((fetcher === null || fetcher === void 0 ? void 0 : fetcher.type) === "actionReload") {
    return matches.filter(filterByRouteProps);
  } else if (state.transition.type === "actionReload" || state.transition.type === "actionRedirect" || createHref(url) === createHref(state.location) || url.searchParams.toString() !== state.location.search.substring(1)) {
    return matches.filter(filterByRouteProps);
  }
  return matches.filter((match, index2, arr) => {
    if ((actionErrorResult || actionCatchResult) && arr.length - 1 === index2) {
      return false;
    }
    return match.route.loader && (isNew(match, index2) || matchPathChanged(match, index2));
  });
}
function isRedirectResult(result) {
  return result.value instanceof TransitionRedirect;
}
function createHref(location2) {
  return location2.pathname + location2.search;
}
function findRedirect(results) {
  for (let result of results) {
    if (isRedirectResult(result)) {
      return result.value;
    }
  }
  return null;
}
async function findCatchAndBoundaryId(results, matches, actionCatchResult) {
  let loaderCatchResult;
  for (let result of results) {
    if (isCatchResult(result)) {
      loaderCatchResult = result;
      break;
    }
  }
  let extractCatchData = async (res) => ({
    status: res.status,
    statusText: res.statusText,
    data: res.data
  });
  if (actionCatchResult && loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(actionCatchResult.value), boundaryId];
  }
  if (loaderCatchResult) {
    let boundaryId = findNearestCatchBoundary(loaderCatchResult.match, matches);
    return [await extractCatchData(loaderCatchResult.value), boundaryId];
  }
  return [void 0, void 0];
}
function findErrorAndBoundaryId(results, matches, actionErrorResult) {
  let loaderErrorResult;
  for (let result of results) {
    if (isErrorResult(result)) {
      loaderErrorResult = result;
      break;
    }
  }
  if (actionErrorResult && loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (actionErrorResult) {
    let boundaryId = findNearestBoundary(actionErrorResult.match, matches);
    return [actionErrorResult.value, boundaryId];
  }
  if (loaderErrorResult) {
    let boundaryId = findNearestBoundary(loaderErrorResult.match, matches);
    return [loaderErrorResult.value, boundaryId];
  }
  return [void 0, void 0];
}
function findNearestCatchBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.CatchBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function findNearestBoundary(matchWithError, matches) {
  let nearestBoundaryId = null;
  for (let match of matches) {
    if (match.route.ErrorBoundary) {
      nearestBoundaryId = match.route.id;
    }
    if (match === matchWithError) {
      break;
    }
  }
  return nearestBoundaryId;
}
function makeLoaderData(state, results, matches) {
  let newData = {};
  for (let {
    match,
    value
  } of results) {
    newData[match.route.id] = value;
  }
  let loaderData = {};
  for (let {
    route
  } of matches) {
    let value = newData[route.id] !== void 0 ? newData[route.id] : state.loaderData[route.id];
    if (value !== void 0) {
      loaderData[route.id] = value;
    }
  }
  return loaderData;
}
function isCatchResult(result) {
  return result.value instanceof CatchValue;
}
function isErrorResult(result) {
  return result.value instanceof Error;
}
function createUrl(href) {
  return new URL(href, window.location.origin);
}

// node_modules/@remix-run/react/esm/routes.js
function createClientRoute(entryRoute, routeModulesCache, Component2) {
  return {
    caseSensitive: !!entryRoute.caseSensitive,
    element: /* @__PURE__ */ React2.createElement(Component2, {
      id: entryRoute.id
    }),
    id: entryRoute.id,
    path: entryRoute.path,
    index: entryRoute.index,
    module: entryRoute.module,
    loader: createLoader(entryRoute, routeModulesCache),
    action: createAction(entryRoute),
    shouldReload: createShouldReload(entryRoute, routeModulesCache),
    ErrorBoundary: entryRoute.hasErrorBoundary,
    CatchBoundary: entryRoute.hasCatchBoundary,
    hasLoader: entryRoute.hasLoader
  };
}
function createClientRoutes(routeManifest, routeModulesCache, Component2, parentId) {
  return Object.keys(routeManifest).filter((key) => routeManifest[key].parentId === parentId).map((key) => {
    let route = createClientRoute(routeManifest[key], routeModulesCache, Component2);
    let children = createClientRoutes(routeManifest, routeModulesCache, Component2, route.id);
    if (children.length > 0)
      route.children = children;
    return route;
  });
}
function createShouldReload(route, routeModules) {
  let shouldReload = (arg) => {
    let module = routeModules[route.id];
    invariant2(module, `Expected route module to be loaded for ${route.id}`);
    if (module.unstable_shouldReload) {
      return module.unstable_shouldReload(arg);
    }
    return true;
  };
  return shouldReload;
}
async function loadRouteModuleWithBlockingLinks(route, routeModules) {
  let routeModule = await loadRouteModule(route, routeModules);
  await prefetchStyleLinks(routeModule);
  return routeModule;
}
function createLoader(route, routeModules) {
  let loader = async ({
    url,
    signal,
    submission
  }) => {
    if (route.hasLoader) {
      let [result] = await Promise.all([fetchData(url, route.id, signal, submission), loadRouteModuleWithBlockingLinks(route, routeModules)]);
      if (result instanceof Error)
        throw result;
      let redirect = await checkRedirect(result);
      if (redirect)
        return redirect;
      if (isCatchResponse2(result)) {
        throw new CatchValue(result.status, result.statusText, await extractData2(result.clone()));
      }
      return extractData2(result);
    } else {
      await loadRouteModuleWithBlockingLinks(route, routeModules);
    }
  };
  return loader;
}
function createAction(route) {
  if (!route.hasAction)
    return void 0;
  let action = async ({
    url,
    signal,
    submission
  }) => {
    let result = await fetchData(url, route.id, signal, submission);
    if (result instanceof Error) {
      throw result;
    }
    let redirect = await checkRedirect(result);
    if (redirect)
      return redirect;
    if (isCatchResponse2(result)) {
      throw new CatchValue(result.status, result.statusText, await extractData2(result.clone()));
    }
    return extractData2(result);
  };
  return action;
}
async function checkRedirect(response) {
  if (isRedirectResponse2(response)) {
    let url = new URL(response.headers.get("X-Remix-Redirect"), window.location.origin);
    if (url.origin !== window.location.origin) {
      await new Promise(() => {
        window.location.replace(url.href);
      });
    } else {
      return new TransitionRedirect(url.pathname + url.search);
    }
  }
  return null;
}

// node_modules/@remix-run/react/esm/components.js
var RemixEntryContext = /* @__PURE__ */ React3.createContext(void 0);
function useRemixEntryContext() {
  let context = React3.useContext(RemixEntryContext);
  invariant2(context, "You must render this element inside a <Remix> element");
  return context;
}
function RemixEntry({
  context: entryContext,
  action,
  location: historyLocation,
  navigator: _navigator,
  static: staticProp = false
}) {
  let {
    manifest,
    routeData: documentLoaderData,
    actionData: documentActionData,
    routeModules,
    serverHandoffString,
    appState: entryComponentDidCatchEmulator
  } = entryContext;
  let clientRoutes = React3.useMemo(() => createClientRoutes(manifest.routes, routeModules, RemixRoute), [manifest, routeModules]);
  let [clientState, setClientState] = React3.useState(entryComponentDidCatchEmulator);
  let [transitionManager] = React3.useState(() => {
    return createTransitionManager({
      routes: clientRoutes,
      actionData: documentActionData,
      loaderData: documentLoaderData,
      location: historyLocation,
      catch: entryComponentDidCatchEmulator.catch,
      catchBoundaryId: entryComponentDidCatchEmulator.catchBoundaryRouteId,
      onRedirect: _navigator.replace,
      onChange: (state) => {
        setClientState({
          catch: state.catch,
          error: state.error,
          catchBoundaryRouteId: state.catchBoundaryId,
          loaderBoundaryRouteId: state.errorBoundaryId,
          renderBoundaryRouteId: null,
          trackBoundaries: false,
          trackCatchBoundaries: false
        });
      }
    });
  });
  let navigator = React3.useMemo(() => {
    let push = (to, state) => {
      return transitionManager.getState().transition.state !== "idle" ? _navigator.replace(to, state) : _navigator.push(to, state);
    };
    return __spreadProps(__spreadValues({}, _navigator), {
      push
    });
  }, [_navigator, transitionManager]);
  let {
    location: location2,
    matches,
    loaderData,
    actionData
  } = transitionManager.getState();
  React3.useEffect(() => {
    let {
      location: location3
    } = transitionManager.getState();
    if (historyLocation === location3)
      return;
    transitionManager.send({
      type: "navigation",
      location: historyLocation,
      submission: consumeNextNavigationSubmission(),
      action
    });
  }, [transitionManager, historyLocation, action]);
  let ssrErrorBeforeRoutesRendered = clientState.error && clientState.renderBoundaryRouteId === null && clientState.loaderBoundaryRouteId === null ? deserializeError(clientState.error) : void 0;
  let ssrCatchBeforeRoutesRendered = clientState.catch && clientState.catchBoundaryRouteId === null ? clientState.catch : void 0;
  return /* @__PURE__ */ React3.createElement(RemixEntryContext.Provider, {
    value: {
      matches,
      manifest,
      appState: clientState,
      routeModules,
      serverHandoffString,
      clientRoutes,
      routeData: loaderData,
      actionData,
      transitionManager
    }
  }, /* @__PURE__ */ React3.createElement(RemixErrorBoundary, {
    location: location2,
    component: RemixRootDefaultErrorBoundary,
    error: ssrErrorBeforeRoutesRendered
  }, /* @__PURE__ */ React3.createElement(RemixCatchBoundary, {
    location: location2,
    component: RemixRootDefaultCatchBoundary,
    catch: ssrCatchBeforeRoutesRendered
  }, /* @__PURE__ */ React3.createElement(Router, {
    navigationType: action,
    location: location2,
    navigator,
    static: staticProp
  }, /* @__PURE__ */ React3.createElement(Routes2, null)))));
}
function deserializeError(data) {
  let error = new Error(data.message);
  error.stack = data.stack;
  return error;
}
function Routes2() {
  let {
    clientRoutes
  } = useRemixEntryContext();
  let element = useRoutes(clientRoutes) || clientRoutes[0].element;
  return element;
}
var RemixRouteContext = /* @__PURE__ */ React3.createContext(void 0);
function useRemixRouteContext() {
  let context = React3.useContext(RemixRouteContext);
  invariant2(context, "You must render this element in a remix route element");
  return context;
}
function DefaultRouteComponent({
  id
}) {
  throw new Error(`Route "${id}" has no component! Please go add a \`default\` export in the route module file.
If you were trying to navigate or submit to a resource route, use \`<a>\` instead of \`<Link>\` or \`<Form reloadDocument>\`.`);
}
function RemixRoute({
  id
}) {
  let location2 = useLocation();
  let {
    routeData,
    routeModules,
    appState
  } = useRemixEntryContext();
  let data = routeData[id];
  let {
    default: Component2,
    CatchBoundary,
    ErrorBoundary
  } = routeModules[id];
  let element = Component2 ? /* @__PURE__ */ React3.createElement(Component2, null) : /* @__PURE__ */ React3.createElement(DefaultRouteComponent, {
    id
  });
  let context = {
    data,
    id
  };
  if (CatchBoundary) {
    let maybeServerCaught = appState.catch && appState.catchBoundaryRouteId === id ? appState.catch : void 0;
    if (appState.trackCatchBoundaries) {
      appState.catchBoundaryRouteId = id;
    }
    context = maybeServerCaught ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in a catch boundary.");
        return void 0;
      }
    } : {
      id,
      data
    };
    element = /* @__PURE__ */ React3.createElement(RemixCatchBoundary, {
      location: location2,
      component: CatchBoundary,
      catch: maybeServerCaught
    }, element);
  }
  if (ErrorBoundary) {
    let maybeServerRenderError = appState.error && (appState.renderBoundaryRouteId === id || appState.loaderBoundaryRouteId === id) ? deserializeError(appState.error) : void 0;
    if (appState.trackBoundaries) {
      appState.renderBoundaryRouteId = id;
    }
    context = maybeServerRenderError ? {
      id,
      get data() {
        console.error("You cannot `useLoaderData` in an error boundary.");
        return void 0;
      }
    } : {
      id,
      data
    };
    element = /* @__PURE__ */ React3.createElement(RemixErrorBoundary, {
      location: location2,
      component: ErrorBoundary,
      error: maybeServerRenderError
    }, element);
  }
  return /* @__PURE__ */ React3.createElement(RemixRouteContext.Provider, {
    value: context
  }, element);
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let [maybePrefetch, setMaybePrefetch] = React3.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = React3.useState(false);
  let {
    onFocus,
    onBlur,
    onMouseEnter,
    onMouseLeave,
    onTouchStart
  } = theirElementProps;
  React3.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
  }, [prefetch]);
  let setIntent = () => {
    if (prefetch === "intent") {
      setMaybePrefetch(true);
    }
  };
  let cancelIntent = () => {
    if (prefetch === "intent") {
      setMaybePrefetch(false);
    }
  };
  React3.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  return [shouldPrefetch, {
    onFocus: composeEventHandlers(onFocus, setIntent),
    onBlur: composeEventHandlers(onBlur, cancelIntent),
    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
    onTouchStart: composeEventHandlers(onTouchStart, setIntent)
  }];
}
var NavLink2 = /* @__PURE__ */ React3.forwardRef((_a, forwardedRef) => {
  var _b = _a, {
    to,
    prefetch = "none"
  } = _b, props = __objRest(_b, [
    "to",
    "prefetch"
  ]);
  let href = useHref(to);
  let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(NavLink, _extends3({
    ref: forwardedRef,
    to
  }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
NavLink2.displayName = "NavLink";
var Link2 = /* @__PURE__ */ React3.forwardRef((_a, forwardedRef) => {
  var _b = _a, {
    to,
    prefetch = "none"
  } = _b, props = __objRest(_b, [
    "to",
    "prefetch"
  ]);
  let href = useHref(to);
  let [shouldPrefetch, prefetchHandlers] = usePrefetchBehavior(prefetch, props);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement(Link, _extends3({
    ref: forwardedRef,
    to
  }, props, prefetchHandlers)), shouldPrefetch ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, {
    page: href
  }) : null);
});
Link2.displayName = "Link";
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function Links() {
  let {
    matches,
    routeModules,
    manifest
  } = useRemixEntryContext();
  let links3 = React3.useMemo(() => getLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, links3.map((link) => isPageLinkDescriptor(link) ? /* @__PURE__ */ React3.createElement(PrefetchPageLinks, _extends3({
    key: link.page
  }, link)) : /* @__PURE__ */ React3.createElement("link", _extends3({
    key: link.rel + link.href
  }, link))));
}
function PrefetchPageLinks(_a) {
  var _b = _a, {
    page
  } = _b, dataLinkProps = __objRest(_b, [
    "page"
  ]);
  let {
    clientRoutes
  } = useRemixEntryContext();
  let matches = React3.useMemo(() => matchClientRoutes(clientRoutes, page), [clientRoutes, page]);
  if (!matches) {
    console.warn(`Tried to prefetch ${page} but no routes matched.`);
    return null;
  }
  return /* @__PURE__ */ React3.createElement(PrefetchPageLinksImpl, _extends3({
    page,
    matches
  }, dataLinkProps));
}
function usePrefetchedStylesheets(matches) {
  let {
    routeModules
  } = useRemixEntryContext();
  let [styleLinks, setStyleLinks] = React3.useState([]);
  React3.useEffect(() => {
    let interrupted = false;
    getStylesheetPrefetchLinks(matches, routeModules).then((links3) => {
      if (!interrupted)
        setStyleLinks(links3);
    });
    return () => {
      interrupted = true;
    };
  }, [matches, routeModules]);
  return styleLinks;
}
function PrefetchPageLinksImpl(_a) {
  var _b = _a, {
    page,
    matches: nextMatches
  } = _b, linkProps = __objRest(_b, [
    "page",
    "matches"
  ]);
  let location2 = useLocation();
  let {
    matches,
    manifest
  } = useRemixEntryContext();
  let newMatchesForData = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location2, "data"), [page, nextMatches, matches, location2]);
  let newMatchesForAssets = React3.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, location2, "assets"), [page, nextMatches, matches, location2]);
  let dataHrefs = React3.useMemo(() => getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]);
  let moduleHrefs = React3.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);
  let styleLinks = usePrefetchedStylesheets(newMatchesForAssets);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: href,
    rel: "prefetch",
    as: "fetch",
    href
  }, linkProps))), moduleHrefs.map((href) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: href,
    rel: "modulepreload",
    href
  }, linkProps))), styleLinks.map((link) => /* @__PURE__ */ React3.createElement("link", _extends3({
    key: link.href
  }, link))));
}
function Meta() {
  let {
    matches,
    routeData,
    routeModules
  } = useRemixEntryContext();
  let location2 = useLocation();
  let meta2 = {};
  let parentsData = {};
  for (let match of matches) {
    let routeId = match.route.id;
    let data = routeData[routeId];
    let params = match.params;
    let routeModule = routeModules[routeId];
    if (routeModule.meta) {
      let routeMeta = typeof routeModule.meta === "function" ? routeModule.meta({
        data,
        parentsData,
        params,
        location: location2
      }) : routeModule.meta;
      Object.assign(meta2, routeMeta);
    }
    parentsData[routeId] = data;
  }
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, Object.entries(meta2).map(([name, value]) => {
    let isOpenGraphTag = name.startsWith("og:");
    return name === "title" ? /* @__PURE__ */ React3.createElement("title", {
      key: "title"
    }, value) : Array.isArray(value) ? value.map((content) => isOpenGraphTag ? /* @__PURE__ */ React3.createElement("meta", {
      key: name + content,
      property: name,
      content
    }) : /* @__PURE__ */ React3.createElement("meta", {
      key: name + content,
      name,
      content
    })) : isOpenGraphTag ? /* @__PURE__ */ React3.createElement("meta", {
      key: name,
      property: name,
      content: value
    }) : /* @__PURE__ */ React3.createElement("meta", {
      key: name,
      name,
      content: value
    });
  }));
}
var isHydrated = false;
function Scripts(props) {
  let {
    manifest,
    matches,
    pendingLocation,
    clientRoutes,
    serverHandoffString
  } = useRemixEntryContext();
  React3.useEffect(() => {
    isHydrated = true;
  }, []);
  let initialScripts = React3.useMemo(() => {
    let contextScript = serverHandoffString ? `window.__remixContext = ${serverHandoffString};` : "";
    let routeModulesScript = `${matches.map((match, index2) => `import * as route${index2} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join("\n")}
window.__remixRouteModules = {${matches.map((match, index2) => `${JSON.stringify(match.route.id)}:route${index2}`).join(",")}};`;
    return /* @__PURE__ */ React3.createElement(React3.Fragment, null, /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: createHtml(contextScript)
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      src: manifest.url
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      dangerouslySetInnerHTML: createHtml(routeModulesScript),
      type: "module"
    })), /* @__PURE__ */ React3.createElement("script", _extends3({}, props, {
      src: manifest.entry.module,
      type: "module"
    })));
  }, []);
  let nextMatches = React3.useMemo(() => {
    if (pendingLocation) {
      let matches2 = matchClientRoutes(clientRoutes, pendingLocation);
      invariant2(matches2, `No routes match path "${pendingLocation.pathname}"`);
      return matches2;
    }
    return [];
  }, [pendingLocation, clientRoutes]);
  let routePreloads = matches.concat(nextMatches).map((match) => {
    let route = manifest.routes[match.route.id];
    return (route.imports || []).concat([route.module]);
  }).flat(1);
  let preloads = manifest.entry.imports.concat(routePreloads);
  return /* @__PURE__ */ React3.createElement(React3.Fragment, null, dedupe2(preloads).map((path) => /* @__PURE__ */ React3.createElement("link", {
    key: path,
    rel: "modulepreload",
    href: path,
    crossOrigin: props.crossOrigin
  })), isHydrated ? null : initialScripts);
}
function dedupe2(array) {
  return [...new Set(array)];
}
var Form = /* @__PURE__ */ React3.forwardRef((props, ref) => {
  return /* @__PURE__ */ React3.createElement(FormImpl, _extends3({}, props, {
    ref
  }));
});
Form.displayName = "Form";
var FormImpl = /* @__PURE__ */ React3.forwardRef((_a, forwardedRef) => {
  var _b = _a, {
    reloadDocument = false,
    replace = false,
    method = "get",
    action = ".",
    encType = "application/x-www-form-urlencoded",
    fetchKey,
    onSubmit
  } = _b, props = __objRest(_b, [
    "reloadDocument",
    "replace",
    "method",
    "action",
    "encType",
    "fetchKey",
    "onSubmit"
  ]);
  let submit = useSubmitImpl(fetchKey);
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let formAction = useFormAction(action, formMethod);
  let formRef = React3.useRef();
  let ref = useComposedRefs(forwardedRef, formRef);
  let clickedButtonRef = React3.useRef();
  React3.useEffect(() => {
    let form = formRef.current;
    if (!form)
      return;
    function handleClick(event) {
      if (!(event.target instanceof Element))
        return;
      let submitButton = event.target.closest("button,input[type=submit]");
      if (submitButton && submitButton.form === form && submitButton.type === "submit") {
        clickedButtonRef.current = submitButton;
      }
    }
    window.addEventListener("click", handleClick);
    return () => {
      window.removeEventListener("click", handleClick);
    };
  }, []);
  return /* @__PURE__ */ React3.createElement("form", _extends3({
    ref,
    method: formMethod,
    action: formAction,
    encType,
    onSubmit: reloadDocument ? void 0 : (event) => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented)
        return;
      event.preventDefault();
      submit(clickedButtonRef.current || event.currentTarget, {
        method,
        replace
      });
      clickedButtonRef.current = null;
    }
  }, props));
});
FormImpl.displayName = "FormImpl";
function isActionRequestMethod(method) {
  method = method.toLowerCase();
  return method === "post" || method === "put" || method === "patch" || method === "delete";
}
function useFormAction(action = ".", method = "get") {
  let {
    id
  } = useRemixRouteContext();
  let path = useResolvedPath(action);
  let search = path.search;
  let isIndexRoute = id.endsWith("/index");
  if (action === "." && isIndexRoute && isActionRequestMethod(method)) {
    search = search ? search.replace(/^\?/, "?index&") : "?index";
  }
  return path.pathname + search;
}
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function useSubmitImpl(key) {
  let navigate = useNavigate();
  let defaultAction = useFormAction();
  let {
    transitionManager
  } = useRemixEntryContext();
  return React3.useCallback((target, options = {}) => {
    let method;
    let action;
    let encType;
    let formData;
    if (isFormElement(target)) {
      let submissionTrigger = options.submissionTrigger;
      method = options.method || target.getAttribute("method") || defaultMethod;
      action = options.action || target.getAttribute("action") || defaultAction;
      encType = options.encType || target.getAttribute("enctype") || defaultEncType;
      formData = new FormData(target);
      if (submissionTrigger && submissionTrigger.name) {
        formData.append(submissionTrigger.name, submissionTrigger.value);
      }
    } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
      let form = target.form;
      if (form == null) {
        throw new Error(`Cannot submit a <button> without a <form>`);
      }
      method = options.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
      action = options.action || target.getAttribute("formaction") || form.getAttribute("action") || defaultAction;
      encType = options.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType;
      formData = new FormData(form);
      if (target.name) {
        formData.set(target.name, target.value);
      }
    } else {
      if (isHtmlElement(target)) {
        throw new Error(`Cannot submit element that is not <form>, <button>, or <input type="submit|image">`);
      }
      method = options.method || "get";
      action = options.action || defaultAction;
      encType = options.encType || "application/x-www-form-urlencoded";
      if (target instanceof FormData) {
        formData = target;
      } else {
        formData = new FormData();
        if (target instanceof URLSearchParams) {
          for (let [name, value] of target) {
            formData.append(name, value);
          }
        } else if (target != null) {
          for (let name of Object.keys(target)) {
            formData.append(name, target[name]);
          }
        }
      }
    }
    if (typeof document === "undefined") {
      throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
    }
    let {
      protocol,
      host
    } = window.location;
    let url = new URL(action, `${protocol}//${host}`);
    if (method.toLowerCase() === "get") {
      for (let [name, value] of formData) {
        if (typeof value === "string") {
          url.searchParams.append(name, value);
        } else {
          throw new Error(`Cannot submit binary form data using GET`);
        }
      }
    }
    let submission = {
      formData,
      action: url.pathname + url.search,
      method: method.toUpperCase(),
      encType,
      key: Math.random().toString(36).substr(2, 8)
    };
    if (key) {
      transitionManager.send({
        type: "fetcher",
        href: submission.action,
        submission,
        key
      });
    } else {
      setNextNavigationSubmission(submission);
      navigate(url.pathname + url.search, {
        replace: options.replace
      });
    }
  }, [defaultAction, key, navigate, transitionManager]);
}
var nextNavigationSubmission;
function setNextNavigationSubmission(submission) {
  nextNavigationSubmission = submission;
}
function consumeNextNavigationSubmission() {
  let submission = nextNavigationSubmission;
  nextNavigationSubmission = void 0;
  return submission;
}
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function useBeforeUnload(callback) {
  React3.useEffect(() => {
    window.addEventListener("beforeunload", callback);
    return () => {
      window.removeEventListener("beforeunload", callback);
    };
  }, [callback]);
}
function useTransition() {
  let {
    transitionManager
  } = useRemixEntryContext();
  return transitionManager.getState().transition;
}
var LiveReload = false ? () => null : function LiveReload2({
  port = Number(8002)
}) {
  let setupLiveReload = ((port2) => {
    let protocol = location.protocol === "https:" ? "wss:" : "ws:";
    let host = location.hostname;
    let socketPath = `${protocol}//${host}:${port2}/socket`;
    let ws = new WebSocket(socketPath);
    ws.onmessage = (message) => {
      let event = JSON.parse(message.data);
      if (event.type === "LOG") {
        console.log(event.message);
      }
      if (event.type === "RELOAD") {
        console.log("\u{1F4BF} Reloading window ...");
        window.location.reload();
      }
    };
    ws.onerror = (error) => {
      console.log("Remix dev asset server web socket error:");
      console.error(error);
    };
  }).toString();
  return /* @__PURE__ */ React3.createElement("script", {
    suppressHydrationWarning: true,
    dangerouslySetInnerHTML: {
      __html: `(${setupLiveReload})(${JSON.stringify(port)})`
    }
  });
};
function useComposedRefs(...refs) {
  return React3.useCallback((node) => {
    for (let ref of refs) {
      if (ref == null)
        continue;
      if (typeof ref === "function") {
        ref(node);
      } else {
        try {
          ref.current = node;
        } catch (_) {
        }
      }
    }
  }, refs);
}

// node_modules/@remix-run/react/esm/scroll-restoration.js
init_react();
var React4 = __toESM(require_react());
var STORAGE_KEY = "positions";
var positions = {};
if (typeof document !== "undefined") {
  let sessionPositions = sessionStorage.getItem(STORAGE_KEY);
  if (sessionPositions) {
    positions = JSON.parse(sessionPositions);
  }
}
function ScrollRestoration() {
  useScrollRestoration();
  React4.useEffect(() => {
    window.history.scrollRestoration = "manual";
  }, []);
  useBeforeUnload(React4.useCallback(() => {
    window.history.scrollRestoration = "auto";
  }, []));
  let restoreScroll = ((STORAGE_KEY2) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({
        key
      }, "");
    }
    try {
      let positions2 = JSON.parse(sessionStorage.getItem(STORAGE_KEY2) || "{}");
      let storedY = positions2[window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error) {
      console.error(error);
      sessionStorage.removeItem(STORAGE_KEY2);
    }
  }).toString();
  return /* @__PURE__ */ React4.createElement("script", {
    suppressHydrationWarning: true,
    dangerouslySetInnerHTML: {
      __html: `(${restoreScroll})(${JSON.stringify(STORAGE_KEY)})`
    }
  });
}
var hydrated = false;
function useScrollRestoration() {
  let location2 = useLocation();
  let transition = useTransition();
  let wasSubmissionRef = React4.useRef(false);
  React4.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
  React4.useEffect(() => {
    if (transition.location) {
      positions[location2.key] = window.scrollY;
    }
  }, [transition, location2]);
  useBeforeUnload(React4.useCallback(() => {
    sessionStorage.setItem(STORAGE_KEY, JSON.stringify(positions));
  }, []));
  if (typeof document !== "undefined") {
    React4.useLayoutEffect(() => {
      if (!hydrated) {
        hydrated = true;
        return;
      }
      let y = positions[location2.key];
      if (y != void 0) {
        window.scrollTo(0, y);
        return;
      }
      if (location2.hash) {
        let el = document.getElementById(location2.hash.slice(1));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      if (wasSubmissionRef.current === true) {
        wasSubmissionRef.current = false;
        return;
      }
      window.scrollTo(0, 0);
    }, [location2]);
  }
  React4.useEffect(() => {
    if (transition.submission) {
      wasSubmissionRef.current = true;
    }
  }, [transition]);
}

// node_modules/@remix-run/react/esm/server.js
init_react();
var React5 = __toESM(require_react());
function RemixServer({
  context,
  url
}) {
  if (typeof url === "string") {
    url = new URL(url);
  }
  let location2 = {
    pathname: url.pathname,
    search: url.search,
    hash: "",
    state: null,
    key: "default"
  };
  let staticNavigator = {
    createHref(to) {
      return typeof to === "string" ? to : createPath(to);
    },
    push(to) {
      throw new Error(`You cannot use navigator.push() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)})\` somewhere in your app.`);
    },
    replace(to) {
      throw new Error(`You cannot use navigator.replace() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${JSON.stringify(to)}, { replace: true })\` somewhere in your app.`);
    },
    go(delta) {
      throw new Error(`You cannot use navigator.go() on the server because it is a stateless environment. This error was probably triggered when you did a \`navigate(${delta})\` somewhere in your app.`);
    },
    back() {
      throw new Error(`You cannot use navigator.back() on the server because it is a stateless environment.`);
    },
    forward() {
      throw new Error(`You cannot use navigator.forward() on the server because it is a stateless environment.`);
    },
    block() {
      throw new Error(`You cannot use navigator.block() on the server because it is a stateless environment.`);
    }
  };
  return /* @__PURE__ */ React5.createElement(RemixEntry, {
    context,
    action: Action.Pop,
    location: location2,
    navigator: staticNavigator,
    static: true
  });
}

// app/entry.server.tsx
function handleRequest(request, responseStatusCode, responseHeaders, remixContext) {
  const markup = (0, import_server3.renderToString)(/* @__PURE__ */ React.createElement(RemixServer, {
    context: remixContext,
    url: request.url
  }));
  responseHeaders.set("Content-Type", "text/html");
  return new Response("<!DOCTYPE html>" + markup, {
    status: responseStatusCode,
    headers: responseHeaders
  });
}

// route:/Users/denis.fetinin/dev/portfolio/app/root.tsx
var root_exports = {};
__export(root_exports, {
  default: () => App,
  links: () => links,
  meta: () => meta
});
init_react();

// node_modules/bootstrap/dist/css/bootstrap.min.css
var bootstrap_min_default = "/build/_assets/bootstrap.min-JQXRYYJZ.css";

// app/styles/index.css
var styles_default = "/build/_assets/index-DDIG4M64.css";

// route:/Users/denis.fetinin/dev/portfolio/app/root.tsx
var meta = () => {
  const description = "Hey! Welcome to my website where I share my experience and projects \u{1F44B}";
  return {
    charset: "utf-8",
    description,
    keywords: "Denis Fetinin,Golang developer,Software Developer",
    title: "Denis Fetinin | Software developer"
  };
};
var links = () => {
  return [
    {
      rel: "stylesheet",
      href: "fontawsome/all.min.css"
    },
    {
      rel: "stylesheet",
      href: "https://cdn.jsdelivr.net/gh/devicons/devicon@v2.14.0/devicon.min.css"
    },
    {
      rel: "stylesheet",
      href: styles_default
    },
    {
      rel: "stylesheet",
      href: bootstrap_min_default
    }
  ];
};
function App() {
  return /* @__PURE__ */ React.createElement("html", {
    lang: "en"
  }, /* @__PURE__ */ React.createElement("head", null, /* @__PURE__ */ React.createElement("meta", {
    charSet: "utf-8"
  }), /* @__PURE__ */ React.createElement("meta", {
    name: "viewport",
    content: "width=device-width,initial-scale=1"
  }), /* @__PURE__ */ React.createElement(Meta, null), /* @__PURE__ */ React.createElement(Links, null)), /* @__PURE__ */ React.createElement("body", null, /* @__PURE__ */ React.createElement(Outlet, null), /* @__PURE__ */ React.createElement(ScrollRestoration, null), /* @__PURE__ */ React.createElement(Scripts, null), /* @__PURE__ */ React.createElement(LiveReload, null), /* @__PURE__ */ React.createElement("script", {
    src: "https://code.iconify.design/1/1.0.7/iconify.min.js"
  })));
}

// route:/Users/denis.fetinin/dev/portfolio/app/routes/index.tsx
var routes_exports = {};
__export(routes_exports, {
  default: () => Index,
  links: () => links2
});
init_react();

// node_modules/react-vertical-timeline-component/style.min.css
var style_min_default = "/build/_assets/style.min-TUKDSXF2.css";

// app/components/about.tsx
init_react();
var import_golang = __toESM(require_golang());
var import_kubernetes = __toESM(require_kubernetes());
var import_python = __toESM(require_python());

// node_modules/@iconify/react/dist/iconify.mjs
init_react();
var import_react5 = __toESM(require_react(), 1);
var matchName = /^[a-z0-9]+(-[a-z0-9]+)*$/;
var iconDefaults = Object.freeze({
  left: 0,
  top: 0,
  width: 16,
  height: 16,
  rotate: 0,
  vFlip: false,
  hFlip: false
});
function fullIcon(data) {
  return __spreadValues(__spreadValues({}, iconDefaults), data);
}
var stringToIcon = (value, validate, allowSimpleName, provider = "") => {
  const colonSeparated = value.split(":");
  if (value.slice(0, 1) === "@") {
    if (colonSeparated.length < 2 || colonSeparated.length > 3) {
      return null;
    }
    provider = colonSeparated.shift().slice(1);
  }
  if (colonSeparated.length > 3 || !colonSeparated.length) {
    return null;
  }
  if (colonSeparated.length > 1) {
    const name2 = colonSeparated.pop();
    const prefix = colonSeparated.pop();
    const result = {
      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
      prefix,
      name: name2
    };
    return validate && !validateIcon(result) ? null : result;
  }
  const name = colonSeparated[0];
  const dashSeparated = name.split("-");
  if (dashSeparated.length > 1) {
    const result = {
      provider,
      prefix: dashSeparated.shift(),
      name: dashSeparated.join("-")
    };
    return validate && !validateIcon(result) ? null : result;
  }
  if (allowSimpleName && provider === "") {
    const result = {
      provider,
      prefix: "",
      name
    };
    return validate && !validateIcon(result, allowSimpleName) ? null : result;
  }
  return null;
};
var validateIcon = (icon, allowSimpleName) => {
  if (!icon) {
    return false;
  }
  return !!((icon.provider === "" || icon.provider.match(matchName)) && (allowSimpleName && icon.prefix === "" || icon.prefix.match(matchName)) && icon.name.match(matchName));
};
function mergeIconData(icon, alias) {
  const result = __spreadValues({}, icon);
  for (const key in iconDefaults) {
    const prop = key;
    if (alias[prop] !== void 0) {
      const value = alias[prop];
      if (result[prop] === void 0) {
        result[prop] = value;
        continue;
      }
      switch (prop) {
        case "rotate":
          result[prop] = (result[prop] + value) % 4;
          break;
        case "hFlip":
        case "vFlip":
          result[prop] = value !== result[prop];
          break;
        default:
          result[prop] = value;
      }
    }
  }
  return result;
}
function getIconData$1(data, name, full = false) {
  function getIcon(name2, iteration) {
    var _a, _b, _c, _d;
    if (data.icons[name2] !== void 0) {
      return Object.assign({}, data.icons[name2]);
    }
    if (iteration > 5) {
      return null;
    }
    if (((_a = data.aliases) == null ? void 0 : _a[name2]) !== void 0) {
      const item = (_b = data.aliases) == null ? void 0 : _b[name2];
      const result2 = getIcon(item.parent, iteration + 1);
      if (result2) {
        return mergeIconData(result2, item);
      }
      return result2;
    }
    if (iteration === 0 && ((_c = data.chars) == null ? void 0 : _c[name2]) !== void 0) {
      return getIcon((_d = data.chars) == null ? void 0 : _d[name2], iteration + 1);
    }
    return null;
  }
  const result = getIcon(name, 0);
  if (result) {
    for (const key in iconDefaults) {
      if (result[key] === void 0 && data[key] !== void 0) {
        result[key] = data[key];
      }
    }
  }
  return result && full ? fullIcon(result) : result;
}
var matchChar = /^[a-f0-9]+(-[a-f0-9]+)*$/;
function validateIconProps(item, fix) {
  for (const key in item) {
    const attr = key;
    const value = item[attr];
    const type2 = typeof value;
    if (type2 === "undefined") {
      delete item[attr];
      continue;
    }
    switch (key) {
      case "body":
      case "parent":
        if (type2 !== "string") {
          return key;
        }
        break;
      case "hFlip":
      case "vFlip":
      case "hidden":
        if (type2 !== "boolean") {
          if (fix) {
            delete item[attr];
          } else {
            return key;
          }
        }
        break;
      case "width":
      case "height":
      case "left":
      case "top":
      case "rotate":
      case "inlineHeight":
      case "inlineTop":
      case "verticalAlign":
        if (type2 !== "number") {
          if (fix) {
            delete item[attr];
          } else {
            return key;
          }
        }
        break;
      default:
        if (type2 === "object") {
          if (fix) {
            delete item[attr];
          } else {
            return key;
          }
        }
    }
  }
  return null;
}
function validateIconSet(obj, options) {
  var _a;
  const fix = !!(options == null ? void 0 : options.fix);
  if (typeof obj !== "object" || obj === null || typeof obj.icons !== "object" || !obj.icons) {
    throw new Error("Bad icon set");
  }
  const data = obj;
  if (typeof (options == null ? void 0 : options.prefix) === "string") {
    data.prefix = options.prefix;
  } else if (typeof data.prefix !== "string" || !data.prefix.match(matchName)) {
    throw new Error("Invalid prefix");
  }
  if (typeof (options == null ? void 0 : options.provider) === "string") {
    data.provider = options.provider;
  } else if (data.provider !== void 0) {
    const value = data.provider;
    if (typeof value !== "string" || value !== "" && !value.match(matchName)) {
      if (fix) {
        delete data.provider;
      } else {
        throw new Error("Invalid provider");
      }
    }
  }
  const icons = data.icons;
  Object.keys(icons).forEach((name) => {
    if (!name.match(matchName)) {
      if (fix) {
        delete icons[name];
        return;
      }
      throw new Error(`Invalid icon name: "${name}"`);
    }
    const item = icons[name];
    if (typeof item !== "object" || item === null || typeof item.body !== "string") {
      if (fix) {
        delete icons[name];
        return;
      }
      throw new Error(`Invalid icon: "${name}"`);
    }
    const key = typeof item.parent === "string" ? "parent" : validateIconProps(item, fix);
    if (key !== null) {
      if (fix) {
        delete icons[name];
        return;
      }
      throw new Error(`Invalid property "${key}" in icon "${name}"`);
    }
  });
  if (data.not_found !== void 0 && !(data.not_found instanceof Array)) {
    if (fix) {
      delete data.not_found;
    } else {
      throw new Error("Invalid not_found list");
    }
  }
  if (!Object.keys(data.icons).length && !((_a = data.not_found) == null ? void 0 : _a.length)) {
    throw new Error("Icon set is empty");
  }
  if (data.aliases !== void 0) {
    if (typeof data.aliases !== "object" || data.aliases === null) {
      if (fix) {
        delete data.aliases;
      } else {
        throw new Error("Invalid aliases list");
      }
    }
  }
  if (typeof data.aliases === "object") {
    let validateAlias = function(name, iteration) {
      if (validatedAliases.has(name)) {
        return !failedAliases.has(name);
      }
      const item = aliases[name];
      if (iteration > 5 || typeof item !== "object" || item === null || typeof item.parent !== "string" || !name.match(matchName)) {
        if (fix) {
          delete aliases[name];
          failedAliases.add(name);
          return false;
        }
        throw new Error(`Invalid icon alias: "${name}"`);
      }
      const parent = item.parent;
      if (data.icons[parent] === void 0) {
        if (aliases[parent] === void 0 || !validateAlias(parent, iteration + 1)) {
          if (fix) {
            delete aliases[name];
            failedAliases.add(name);
            return false;
          }
          throw new Error(`Missing parent icon for alias "${name}`);
        }
      }
      if (fix && item.body !== void 0) {
        delete item.body;
      }
      const key = item.body !== void 0 ? "body" : validateIconProps(item, fix);
      if (key !== null) {
        if (fix) {
          delete aliases[name];
          failedAliases.add(name);
          return false;
        }
        throw new Error(`Invalid property "${key}" in alias "${name}"`);
      }
      validatedAliases.add(name);
      return true;
    };
    const aliases = data.aliases;
    const validatedAliases = /* @__PURE__ */ new Set();
    const failedAliases = /* @__PURE__ */ new Set();
    Object.keys(aliases).forEach((name) => {
      validateAlias(name, 0);
    });
    if (fix && !Object.keys(data.aliases).length) {
      delete data.aliases;
    }
  }
  Object.keys(iconDefaults).forEach((prop) => {
    const expectedType = typeof iconDefaults[prop];
    const actualType = typeof data[prop];
    if (actualType !== "undefined" && actualType !== expectedType) {
      throw new Error(`Invalid value type for "${prop}"`);
    }
  });
  if (data.chars !== void 0) {
    if (typeof data.chars !== "object" || data.chars === null) {
      if (fix) {
        delete data.chars;
      } else {
        throw new Error("Invalid characters map");
      }
    }
  }
  if (typeof data.chars === "object") {
    const chars = data.chars;
    Object.keys(chars).forEach((char) => {
      var _a2;
      if (!char.match(matchChar) || typeof chars[char] !== "string") {
        if (fix) {
          delete chars[char];
          return;
        }
        throw new Error(`Invalid character "${char}"`);
      }
      const target = chars[char];
      if (data.icons[target] === void 0 && ((_a2 = data.aliases) == null ? void 0 : _a2[target]) === void 0) {
        if (fix) {
          delete chars[char];
          return;
        }
        throw new Error(`Character "${char}" points to missing icon "${target}"`);
      }
    });
    if (fix && !Object.keys(data.chars).length) {
      delete data.chars;
    }
  }
  return data;
}
function isVariation(item) {
  for (const key in iconDefaults) {
    if (item[key] !== void 0) {
      return true;
    }
  }
  return false;
}
function parseIconSet(data, callback, options) {
  options = options || {};
  const names = [];
  if (typeof data !== "object" || typeof data.icons !== "object") {
    return names;
  }
  const validate = options.validate;
  if (validate !== false) {
    try {
      validateIconSet(data, typeof validate === "object" ? validate : { fix: true });
    } catch (err) {
      return names;
    }
  }
  if (data.not_found instanceof Array) {
    data.not_found.forEach((name) => {
      callback(name, null);
      names.push(name);
    });
  }
  const icons = data.icons;
  Object.keys(icons).forEach((name) => {
    const iconData = getIconData$1(data, name, true);
    if (iconData) {
      callback(name, iconData);
      names.push(name);
    }
  });
  const parseAliases = options.aliases || "all";
  if (parseAliases !== "none" && typeof data.aliases === "object") {
    const aliases = data.aliases;
    Object.keys(aliases).forEach((name) => {
      if (parseAliases === "variations" && isVariation(aliases[name])) {
        return;
      }
      const iconData = getIconData$1(data, name, true);
      if (iconData) {
        callback(name, iconData);
        names.push(name);
      }
    });
  }
  return names;
}
var storageVersion = 1;
var storage$1 = /* @__PURE__ */ Object.create(null);
try {
  const w = window || self;
  if ((w == null ? void 0 : w._iconifyStorage.version) === storageVersion) {
    storage$1 = w._iconifyStorage.storage;
  }
} catch (err) {
}
function newStorage(provider, prefix) {
  return {
    provider,
    prefix,
    icons: /* @__PURE__ */ Object.create(null),
    missing: /* @__PURE__ */ Object.create(null)
  };
}
function getStorage(provider, prefix) {
  if (storage$1[provider] === void 0) {
    storage$1[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerStorage = storage$1[provider];
  if (providerStorage[prefix] === void 0) {
    providerStorage[prefix] = newStorage(provider, prefix);
  }
  return providerStorage[prefix];
}
function addIconSet(storage2, data) {
  const t = Date.now();
  return parseIconSet(data, (name, icon) => {
    if (icon) {
      storage2.icons[name] = icon;
    } else {
      storage2.missing[name] = t;
    }
  });
}
function addIconToStorage(storage2, name, icon) {
  try {
    if (typeof icon.body === "string") {
      storage2.icons[name] = Object.freeze(fullIcon(icon));
      return true;
    }
  } catch (err) {
  }
  return false;
}
function getIconFromStorage(storage2, name) {
  const value = storage2.icons[name];
  return value === void 0 ? null : value;
}
var simpleNames = false;
function allowSimpleNames(allow) {
  if (typeof allow === "boolean") {
    simpleNames = allow;
  }
  return simpleNames;
}
function getIconData(name) {
  const icon = typeof name === "string" ? stringToIcon(name, true, simpleNames) : name;
  return icon ? getIconFromStorage(getStorage(icon.provider, icon.prefix), icon.name) : null;
}
function addIcon(name, data) {
  const icon = stringToIcon(name, true, simpleNames);
  if (!icon) {
    return false;
  }
  const storage2 = getStorage(icon.provider, icon.prefix);
  return addIconToStorage(storage2, icon.name, data);
}
function addCollection(data, provider) {
  if (typeof data !== "object") {
    return false;
  }
  if (typeof provider !== "string") {
    provider = typeof data.provider === "string" ? data.provider : "";
  }
  if (simpleNames && provider === "" && (typeof data.prefix !== "string" || data.prefix === "")) {
    let added = false;
    parseIconSet(data, (name, icon) => {
      if (icon && addIcon(name, icon)) {
        added = true;
      }
    }, {
      validate: {
        fix: true,
        prefix: ""
      }
    });
    return added;
  }
  if (typeof data.prefix !== "string" || !validateIcon({
    provider,
    prefix: data.prefix,
    name: "a"
  })) {
    return false;
  }
  const storage2 = getStorage(provider, data.prefix);
  return !!addIconSet(storage2, data);
}
var defaults = Object.freeze({
  inline: false,
  width: null,
  height: null,
  hAlign: "center",
  vAlign: "middle",
  slice: false,
  hFlip: false,
  vFlip: false,
  rotate: 0
});
function mergeCustomisations(defaults2, item) {
  const result = {};
  for (const key in defaults2) {
    const attr = key;
    result[attr] = defaults2[attr];
    if (item[attr] === void 0) {
      continue;
    }
    const value = item[attr];
    switch (attr) {
      case "inline":
      case "slice":
        if (typeof value === "boolean") {
          result[attr] = value;
        }
        break;
      case "hFlip":
      case "vFlip":
        if (value === true) {
          result[attr] = !result[attr];
        }
        break;
      case "hAlign":
      case "vAlign":
        if (typeof value === "string" && value !== "") {
          result[attr] = value;
        }
        break;
      case "width":
      case "height":
        if (typeof value === "string" && value !== "" || typeof value === "number" && value || value === null) {
          result[attr] = value;
        }
        break;
      case "rotate":
        if (typeof value === "number") {
          result[attr] += value;
        }
        break;
    }
  }
  return result;
}
var unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
var unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize(size, ratio, precision) {
  if (ratio === 1) {
    return size;
  }
  precision = precision === void 0 ? 100 : precision;
  if (typeof size === "number") {
    return Math.ceil(size * ratio * precision) / precision;
  }
  if (typeof size !== "string") {
    return size;
  }
  const oldParts = size.split(unitsSplit);
  if (oldParts === null || !oldParts.length) {
    return size;
  }
  const newParts = [];
  let code = oldParts.shift();
  let isNumber2 = unitsTest.test(code);
  while (true) {
    if (isNumber2) {
      const num = parseFloat(code);
      if (isNaN(num)) {
        newParts.push(code);
      } else {
        newParts.push(Math.ceil(num * ratio * precision) / precision);
      }
    } else {
      newParts.push(code);
    }
    code = oldParts.shift();
    if (code === void 0) {
      return newParts.join("");
    }
    isNumber2 = !isNumber2;
  }
}
function preserveAspectRatio(props) {
  let result = "";
  switch (props.hAlign) {
    case "left":
      result += "xMin";
      break;
    case "right":
      result += "xMax";
      break;
    default:
      result += "xMid";
  }
  switch (props.vAlign) {
    case "top":
      result += "YMin";
      break;
    case "bottom":
      result += "YMax";
      break;
    default:
      result += "YMid";
  }
  result += props.slice ? " slice" : " meet";
  return result;
}
function iconToSVG(icon, customisations) {
  const box = {
    left: icon.left,
    top: icon.top,
    width: icon.width,
    height: icon.height
  };
  let body = icon.body;
  [icon, customisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation += 2;
      } else {
        transformations.push("translate(" + (box.width + box.left) + " " + (0 - box.top) + ")");
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push("translate(" + (0 - box.left) + " " + (box.height + box.top) + ")");
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) {
      rotation -= Math.floor(rotation / 4) * 4;
    }
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift("rotate(90 " + tempValue + " " + tempValue + ")");
        break;
      case 2:
        transformations.unshift("rotate(180 " + (box.width / 2 + box.left) + " " + (box.height / 2 + box.top) + ")");
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift("rotate(-90 " + tempValue + " " + tempValue + ")");
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== 0 || box.top !== 0) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = '<g transform="' + transformations.join(" ") + '">' + body + "</g>";
    }
  });
  let width, height;
  if (customisations.width === null && customisations.height === null) {
    height = "1em";
    width = calculateSize(height, box.width / box.height);
  } else if (customisations.width !== null && customisations.height !== null) {
    width = customisations.width;
    height = customisations.height;
  } else if (customisations.height !== null) {
    height = customisations.height;
    width = calculateSize(height, box.width / box.height);
  } else {
    width = customisations.width;
    height = calculateSize(width, box.height / box.width);
  }
  if (width === "auto") {
    width = box.width;
  }
  if (height === "auto") {
    height = box.height;
  }
  width = typeof width === "string" ? width : width + "";
  height = typeof height === "string" ? height : height + "";
  const result = {
    attributes: {
      width,
      height,
      preserveAspectRatio: preserveAspectRatio(customisations),
      viewBox: box.left + " " + box.top + " " + box.width + " " + box.height
    },
    body
  };
  if (customisations.inline) {
    result.inline = true;
  }
  return result;
}
var regex = /\sid="(\S+)"/g;
var randomPrefix = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
var counter = 0;
function replaceIDs(body, prefix = randomPrefix) {
  const ids = [];
  let match;
  while (match = regex.exec(body)) {
    ids.push(match[1]);
  }
  if (!ids.length) {
    return body;
  }
  ids.forEach((id) => {
    const newID = typeof prefix === "function" ? prefix(id) : prefix + counter++;
    const escapedID = id.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    body = body.replace(new RegExp('([#;"])(' + escapedID + ')([")]|\\.[a-z])', "g"), "$1" + newID + "$3");
  });
  return body;
}
var storage = /* @__PURE__ */ Object.create(null);
function setAPIModule(provider, item) {
  storage[provider] = item;
}
function getAPIModule(provider) {
  return storage[provider] || storage[""];
}
function createAPIConfig(source) {
  let resources;
  if (typeof source.resources === "string") {
    resources = [source.resources];
  } else {
    resources = source.resources;
    if (!(resources instanceof Array) || !resources.length) {
      return null;
    }
  }
  const result = {
    resources,
    path: source.path === void 0 ? "/" : source.path,
    maxURL: source.maxURL ? source.maxURL : 500,
    rotate: source.rotate ? source.rotate : 750,
    timeout: source.timeout ? source.timeout : 5e3,
    random: source.random === true,
    index: source.index ? source.index : 0,
    dataAfterTimeout: source.dataAfterTimeout !== false
  };
  return result;
}
var configStorage = /* @__PURE__ */ Object.create(null);
var fallBackAPISources = [
  "https://api.simplesvg.com",
  "https://api.unisvg.com"
];
var fallBackAPI = [];
while (fallBackAPISources.length > 0) {
  if (fallBackAPISources.length === 1) {
    fallBackAPI.push(fallBackAPISources.shift());
  } else {
    if (Math.random() > 0.5) {
      fallBackAPI.push(fallBackAPISources.shift());
    } else {
      fallBackAPI.push(fallBackAPISources.pop());
    }
  }
}
configStorage[""] = createAPIConfig({
  resources: ["https://api.iconify.design"].concat(fallBackAPI)
});
function addAPIProvider(provider, customConfig) {
  const config3 = createAPIConfig(customConfig);
  if (config3 === null) {
    return false;
  }
  configStorage[provider] = config3;
  return true;
}
function getAPIConfig(provider) {
  return configStorage[provider];
}
var mergeParams = (base, params) => {
  let result = base, hasParams = result.indexOf("?") !== -1;
  function paramToString(value) {
    switch (typeof value) {
      case "boolean":
        return value ? "true" : "false";
      case "number":
        return encodeURIComponent(value);
      case "string":
        return encodeURIComponent(value);
      default:
        throw new Error("Invalid parameter");
    }
  }
  Object.keys(params).forEach((key) => {
    let value;
    try {
      value = paramToString(params[key]);
    } catch (err) {
      return;
    }
    result += (hasParams ? "&" : "?") + encodeURIComponent(key) + "=" + value;
    hasParams = true;
  });
  return result;
};
var maxLengthCache = /* @__PURE__ */ Object.create(null);
var pathCache = /* @__PURE__ */ Object.create(null);
var detectFetch = () => {
  let callback;
  try {
    callback = fetch;
    if (typeof callback === "function") {
      return callback;
    }
  } catch (err) {
  }
  return null;
};
var fetchModule = detectFetch();
function calculateMaxLength(provider, prefix) {
  const config3 = getAPIConfig(provider);
  if (!config3) {
    return 0;
  }
  let result;
  if (!config3.maxURL) {
    result = 0;
  } else {
    let maxHostLength = 0;
    config3.resources.forEach((item) => {
      const host = item;
      maxHostLength = Math.max(maxHostLength, host.length);
    });
    const url = mergeParams(prefix + ".json", {
      icons: ""
    });
    result = config3.maxURL - maxHostLength - config3.path.length - url.length;
  }
  const cacheKey = provider + ":" + prefix;
  pathCache[provider] = config3.path;
  maxLengthCache[cacheKey] = result;
  return result;
}
function shouldAbort(status) {
  return status === 404;
}
var prepare = (provider, prefix, icons) => {
  const results = [];
  let maxLength = maxLengthCache[prefix];
  if (maxLength === void 0) {
    maxLength = calculateMaxLength(provider, prefix);
  }
  const type2 = "icons";
  let item = {
    type: type2,
    provider,
    prefix,
    icons: []
  };
  let length = 0;
  icons.forEach((name, index2) => {
    length += name.length + 1;
    if (length >= maxLength && index2 > 0) {
      results.push(item);
      item = {
        type: type2,
        provider,
        prefix,
        icons: []
      };
      length = name.length;
    }
    item.icons.push(name);
  });
  results.push(item);
  return results;
};
function getPath(provider) {
  if (typeof provider === "string") {
    if (pathCache[provider] === void 0) {
      const config3 = getAPIConfig(provider);
      if (!config3) {
        return "/";
      }
      pathCache[provider] = config3.path;
    }
    return pathCache[provider];
  }
  return "/";
}
var send = (host, params, callback) => {
  if (!fetchModule) {
    callback("abort", 424);
    return;
  }
  let path = getPath(params.provider);
  switch (params.type) {
    case "icons": {
      const prefix = params.prefix;
      const icons = params.icons;
      const iconsList = icons.join(",");
      path += mergeParams(prefix + ".json", {
        icons: iconsList
      });
      break;
    }
    case "custom": {
      const uri = params.uri;
      path += uri.slice(0, 1) === "/" ? uri.slice(1) : uri;
      break;
    }
    default:
      callback("abort", 400);
      return;
  }
  let defaultError = 503;
  fetchModule(host + path).then((response) => {
    const status = response.status;
    if (status !== 200) {
      setTimeout(() => {
        callback(shouldAbort(status) ? "abort" : "next", status);
      });
      return;
    }
    defaultError = 501;
    return response.json();
  }).then((data) => {
    if (typeof data !== "object" || data === null) {
      setTimeout(() => {
        callback("next", defaultError);
      });
      return;
    }
    setTimeout(() => {
      callback("success", data);
    });
  }).catch(() => {
    callback("next", defaultError);
  });
};
var fetchAPIModule = {
  prepare,
  send
};
function sortIcons(icons) {
  const result = {
    loaded: [],
    missing: [],
    pending: []
  };
  const storage2 = /* @__PURE__ */ Object.create(null);
  icons.sort((a, b) => {
    if (a.provider !== b.provider) {
      return a.provider.localeCompare(b.provider);
    }
    if (a.prefix !== b.prefix) {
      return a.prefix.localeCompare(b.prefix);
    }
    return a.name.localeCompare(b.name);
  });
  let lastIcon = {
    provider: "",
    prefix: "",
    name: ""
  };
  icons.forEach((icon) => {
    if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {
      return;
    }
    lastIcon = icon;
    const provider = icon.provider;
    const prefix = icon.prefix;
    const name = icon.name;
    if (storage2[provider] === void 0) {
      storage2[provider] = /* @__PURE__ */ Object.create(null);
    }
    const providerStorage = storage2[provider];
    if (providerStorage[prefix] === void 0) {
      providerStorage[prefix] = getStorage(provider, prefix);
    }
    const localStorage = providerStorage[prefix];
    let list;
    if (localStorage.icons[name] !== void 0) {
      list = result.loaded;
    } else if (prefix === "" || localStorage.missing[name] !== void 0) {
      list = result.missing;
    } else {
      list = result.pending;
    }
    const item = {
      provider,
      prefix,
      name
    };
    list.push(item);
  });
  return result;
}
var callbacks = /* @__PURE__ */ Object.create(null);
var pendingUpdates = /* @__PURE__ */ Object.create(null);
function removeCallback(sources, id) {
  sources.forEach((source) => {
    const provider = source.provider;
    if (callbacks[provider] === void 0) {
      return;
    }
    const providerCallbacks = callbacks[provider];
    const prefix = source.prefix;
    const items = providerCallbacks[prefix];
    if (items) {
      providerCallbacks[prefix] = items.filter((row) => row.id !== id);
    }
  });
}
function updateCallbacks(provider, prefix) {
  if (pendingUpdates[provider] === void 0) {
    pendingUpdates[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerPendingUpdates = pendingUpdates[provider];
  if (!providerPendingUpdates[prefix]) {
    providerPendingUpdates[prefix] = true;
    setTimeout(() => {
      providerPendingUpdates[prefix] = false;
      if (callbacks[provider] === void 0 || callbacks[provider][prefix] === void 0) {
        return;
      }
      const items = callbacks[provider][prefix].slice(0);
      if (!items.length) {
        return;
      }
      const storage2 = getStorage(provider, prefix);
      let hasPending = false;
      items.forEach((item) => {
        const icons = item.icons;
        const oldLength = icons.pending.length;
        icons.pending = icons.pending.filter((icon) => {
          if (icon.prefix !== prefix) {
            return true;
          }
          const name = icon.name;
          if (storage2.icons[name] !== void 0) {
            icons.loaded.push({
              provider,
              prefix,
              name
            });
          } else if (storage2.missing[name] !== void 0) {
            icons.missing.push({
              provider,
              prefix,
              name
            });
          } else {
            hasPending = true;
            return true;
          }
          return false;
        });
        if (icons.pending.length !== oldLength) {
          if (!hasPending) {
            removeCallback([
              {
                provider,
                prefix
              }
            ], item.id);
          }
          item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);
        }
      });
    });
  }
}
var idCounter = 0;
function storeCallback(callback, icons, pendingSources) {
  const id = idCounter++;
  const abort = removeCallback.bind(null, pendingSources, id);
  if (!icons.pending.length) {
    return abort;
  }
  const item = {
    id,
    icons,
    callback,
    abort
  };
  pendingSources.forEach((source) => {
    const provider = source.provider;
    const prefix = source.prefix;
    if (callbacks[provider] === void 0) {
      callbacks[provider] = /* @__PURE__ */ Object.create(null);
    }
    const providerCallbacks = callbacks[provider];
    if (providerCallbacks[prefix] === void 0) {
      providerCallbacks[prefix] = [];
    }
    providerCallbacks[prefix].push(item);
  });
  return abort;
}
function listToIcons(list, validate = true, simpleNames2 = false) {
  const result = [];
  list.forEach((item) => {
    const icon = typeof item === "string" ? stringToIcon(item, false, simpleNames2) : item;
    if (!validate || validateIcon(icon, simpleNames2)) {
      result.push({
        provider: icon.provider,
        prefix: icon.prefix,
        name: icon.name
      });
    }
  });
  return result;
}
var defaultConfig = {
  resources: [],
  index: 0,
  timeout: 2e3,
  rotate: 750,
  random: false,
  dataAfterTimeout: false
};
function sendQuery(config3, payload, query, done2) {
  const resourcesCount = config3.resources.length;
  const startIndex = config3.random ? Math.floor(Math.random() * resourcesCount) : config3.index;
  let resources;
  if (config3.random) {
    let list = config3.resources.slice(0);
    resources = [];
    while (list.length > 1) {
      const nextIndex = Math.floor(Math.random() * list.length);
      resources.push(list[nextIndex]);
      list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));
    }
    resources = resources.concat(list);
  } else {
    resources = config3.resources.slice(startIndex).concat(config3.resources.slice(0, startIndex));
  }
  const startTime2 = Date.now();
  let status = "pending";
  let queriesSent = 0;
  let lastError;
  let timer = null;
  let queue2 = [];
  let doneCallbacks = [];
  if (typeof done2 === "function") {
    doneCallbacks.push(done2);
  }
  function resetTimer() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }
  function abort() {
    if (status === "pending") {
      status = "aborted";
    }
    resetTimer();
    queue2.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue2 = [];
  }
  function subscribe(callback, overwrite) {
    if (overwrite) {
      doneCallbacks = [];
    }
    if (typeof callback === "function") {
      doneCallbacks.push(callback);
    }
  }
  function getQueryStatus() {
    return {
      startTime: startTime2,
      payload,
      status,
      queriesSent,
      queriesPending: queue2.length,
      subscribe,
      abort
    };
  }
  function failQuery() {
    status = "failed";
    doneCallbacks.forEach((callback) => {
      callback(void 0, lastError);
    });
  }
  function clearQueue() {
    queue2.forEach((item) => {
      if (item.status === "pending") {
        item.status = "aborted";
      }
    });
    queue2 = [];
  }
  function moduleResponse(item, response, data) {
    const isError2 = response !== "success";
    queue2 = queue2.filter((queued) => queued !== item);
    switch (status) {
      case "pending":
        break;
      case "failed":
        if (isError2 || !config3.dataAfterTimeout) {
          return;
        }
        break;
      default:
        return;
    }
    if (response === "abort") {
      lastError = data;
      failQuery();
      return;
    }
    if (isError2) {
      lastError = data;
      if (!queue2.length) {
        if (!resources.length) {
          failQuery();
        } else {
          execNext();
        }
      }
      return;
    }
    resetTimer();
    clearQueue();
    if (!config3.random) {
      const index2 = config3.resources.indexOf(item.resource);
      if (index2 !== -1 && index2 !== config3.index) {
        config3.index = index2;
      }
    }
    status = "completed";
    doneCallbacks.forEach((callback) => {
      callback(data);
    });
  }
  function execNext() {
    if (status !== "pending") {
      return;
    }
    resetTimer();
    const resource = resources.shift();
    if (resource === void 0) {
      if (queue2.length) {
        timer = setTimeout(() => {
          resetTimer();
          if (status === "pending") {
            clearQueue();
            failQuery();
          }
        }, config3.timeout);
        return;
      }
      failQuery();
      return;
    }
    const item = {
      status: "pending",
      resource,
      callback: (status2, data) => {
        moduleResponse(item, status2, data);
      }
    };
    queue2.push(item);
    queriesSent++;
    timer = setTimeout(execNext, config3.rotate);
    query(resource, payload, item.callback);
  }
  setTimeout(execNext);
  return getQueryStatus;
}
function setConfig(config3) {
  if (typeof config3 !== "object" || typeof config3.resources !== "object" || !(config3.resources instanceof Array) || !config3.resources.length) {
    throw new Error("Invalid Reduncancy configuration");
  }
  const newConfig = /* @__PURE__ */ Object.create(null);
  let key;
  for (key in defaultConfig) {
    if (config3[key] !== void 0) {
      newConfig[key] = config3[key];
    } else {
      newConfig[key] = defaultConfig[key];
    }
  }
  return newConfig;
}
function initRedundancy(cfg) {
  const config3 = setConfig(cfg);
  let queries = [];
  function cleanup() {
    queries = queries.filter((item) => item().status === "pending");
  }
  function query(payload, queryCallback, doneCallback) {
    const query2 = sendQuery(config3, payload, queryCallback, (data, error) => {
      cleanup();
      if (doneCallback) {
        doneCallback(data, error);
      }
    });
    queries.push(query2);
    return query2;
  }
  function find(callback) {
    const result = queries.find((value) => {
      return callback(value);
    });
    return result !== void 0 ? result : null;
  }
  const instance = {
    query,
    find,
    setIndex: (index2) => {
      config3.index = index2;
    },
    getIndex: () => config3.index,
    cleanup
  };
  return instance;
}
function emptyCallback$1() {
}
var redundancyCache = /* @__PURE__ */ Object.create(null);
function getRedundancyCache(provider) {
  if (redundancyCache[provider] === void 0) {
    const config3 = getAPIConfig(provider);
    if (!config3) {
      return;
    }
    const redundancy = initRedundancy(config3);
    const cachedReundancy = {
      config: config3,
      redundancy
    };
    redundancyCache[provider] = cachedReundancy;
  }
  return redundancyCache[provider];
}
function sendAPIQuery(target, query, callback) {
  let redundancy;
  let send2;
  if (typeof target === "string") {
    const api = getAPIModule(target);
    if (!api) {
      callback(void 0, 424);
      return emptyCallback$1;
    }
    send2 = api.send;
    const cached = getRedundancyCache(target);
    if (cached) {
      redundancy = cached.redundancy;
    }
  } else {
    const config3 = createAPIConfig(target);
    if (config3) {
      redundancy = initRedundancy(config3);
      const moduleKey = target.resources ? target.resources[0] : "";
      const api = getAPIModule(moduleKey);
      if (api) {
        send2 = api.send;
      }
    }
  }
  if (!redundancy || !send2) {
    callback(void 0, 424);
    return emptyCallback$1;
  }
  return redundancy.query(query, send2, callback)().abort;
}
var cache = {};
function emptyCallback() {
}
var pendingIcons = /* @__PURE__ */ Object.create(null);
var iconsToLoad = /* @__PURE__ */ Object.create(null);
var loaderFlags = /* @__PURE__ */ Object.create(null);
var queueFlags = /* @__PURE__ */ Object.create(null);
function loadedNewIcons(provider, prefix) {
  if (loaderFlags[provider] === void 0) {
    loaderFlags[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerLoaderFlags = loaderFlags[provider];
  if (!providerLoaderFlags[prefix]) {
    providerLoaderFlags[prefix] = true;
    setTimeout(() => {
      providerLoaderFlags[prefix] = false;
      updateCallbacks(provider, prefix);
    });
  }
}
var errorsCache = /* @__PURE__ */ Object.create(null);
function loadNewIcons(provider, prefix, icons) {
  function err() {
    const key = (provider === "" ? "" : "@" + provider + ":") + prefix;
    const time = Math.floor(Date.now() / 6e4);
    if (errorsCache[key] < time) {
      errorsCache[key] = time;
      console.error('Unable to retrieve icons for "' + key + '" because API is not configured properly.');
    }
  }
  if (iconsToLoad[provider] === void 0) {
    iconsToLoad[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerIconsToLoad = iconsToLoad[provider];
  if (queueFlags[provider] === void 0) {
    queueFlags[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerQueueFlags = queueFlags[provider];
  if (pendingIcons[provider] === void 0) {
    pendingIcons[provider] = /* @__PURE__ */ Object.create(null);
  }
  const providerPendingIcons = pendingIcons[provider];
  if (providerIconsToLoad[prefix] === void 0) {
    providerIconsToLoad[prefix] = icons;
  } else {
    providerIconsToLoad[prefix] = providerIconsToLoad[prefix].concat(icons).sort();
  }
  if (!providerQueueFlags[prefix]) {
    providerQueueFlags[prefix] = true;
    setTimeout(() => {
      providerQueueFlags[prefix] = false;
      const icons2 = providerIconsToLoad[prefix];
      delete providerIconsToLoad[prefix];
      const api = getAPIModule(provider);
      if (!api) {
        err();
        return;
      }
      const params = api.prepare(provider, prefix, icons2);
      params.forEach((item) => {
        sendAPIQuery(provider, item, (data, error) => {
          const storage2 = getStorage(provider, prefix);
          if (typeof data !== "object") {
            if (error !== 404) {
              return;
            }
            const t = Date.now();
            item.icons.forEach((name) => {
              storage2.missing[name] = t;
            });
          } else {
            try {
              const parsed = addIconSet(storage2, data);
              if (!parsed.length) {
                return;
              }
              const pending = providerPendingIcons[prefix];
              parsed.forEach((name) => {
                delete pending[name];
              });
              if (cache.store) {
                cache.store(provider, data);
              }
            } catch (err2) {
              console.error(err2);
            }
          }
          loadedNewIcons(provider, prefix);
        });
      });
    });
  }
}
var loadIcons = (icons, callback) => {
  const cleanedIcons = listToIcons(icons, true, allowSimpleNames());
  const sortedIcons = sortIcons(cleanedIcons);
  if (!sortedIcons.pending.length) {
    let callCallback = true;
    if (callback) {
      setTimeout(() => {
        if (callCallback) {
          callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);
        }
      });
    }
    return () => {
      callCallback = false;
    };
  }
  const newIcons = /* @__PURE__ */ Object.create(null);
  const sources = [];
  let lastProvider, lastPrefix;
  sortedIcons.pending.forEach((icon) => {
    const provider = icon.provider;
    const prefix = icon.prefix;
    if (prefix === lastPrefix && provider === lastProvider) {
      return;
    }
    lastProvider = provider;
    lastPrefix = prefix;
    sources.push({
      provider,
      prefix
    });
    if (pendingIcons[provider] === void 0) {
      pendingIcons[provider] = /* @__PURE__ */ Object.create(null);
    }
    const providerPendingIcons = pendingIcons[provider];
    if (providerPendingIcons[prefix] === void 0) {
      providerPendingIcons[prefix] = /* @__PURE__ */ Object.create(null);
    }
    if (newIcons[provider] === void 0) {
      newIcons[provider] = /* @__PURE__ */ Object.create(null);
    }
    const providerNewIcons = newIcons[provider];
    if (providerNewIcons[prefix] === void 0) {
      providerNewIcons[prefix] = [];
    }
  });
  const time = Date.now();
  sortedIcons.pending.forEach((icon) => {
    const provider = icon.provider;
    const prefix = icon.prefix;
    const name = icon.name;
    const pendingQueue = pendingIcons[provider][prefix];
    if (pendingQueue[name] === void 0) {
      pendingQueue[name] = time;
      newIcons[provider][prefix].push(name);
    }
  });
  sources.forEach((source) => {
    const provider = source.provider;
    const prefix = source.prefix;
    if (newIcons[provider][prefix].length) {
      loadNewIcons(provider, prefix, newIcons[provider][prefix]);
    }
  });
  return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;
};
var cacheVersion = "iconify2";
var cachePrefix = "iconify";
var countKey = cachePrefix + "-count";
var versionKey = cachePrefix + "-version";
var hour = 36e5;
var cacheExpiration = 168;
var config2 = {
  local: true,
  session: true
};
var loaded = false;
var count = {
  local: 0,
  session: 0
};
var emptyList = {
  local: [],
  session: []
};
var _window = typeof window === "undefined" ? {} : window;
function getGlobal(key) {
  const attr = key + "Storage";
  try {
    if (_window && _window[attr] && typeof _window[attr].length === "number") {
      return _window[attr];
    }
  } catch (err) {
  }
  config2[key] = false;
  return null;
}
function setCount(storage2, key, value) {
  try {
    storage2.setItem(countKey, value + "");
    count[key] = value;
    return true;
  } catch (err) {
    return false;
  }
}
function getCount(storage2) {
  const count2 = storage2.getItem(countKey);
  if (count2) {
    const total = parseInt(count2);
    return total ? total : 0;
  }
  return 0;
}
function initCache(storage2, key) {
  try {
    storage2.setItem(versionKey, cacheVersion);
  } catch (err) {
  }
  setCount(storage2, key, 0);
}
function destroyCache(storage2) {
  try {
    const total = getCount(storage2);
    for (let i = 0; i < total; i++) {
      storage2.removeItem(cachePrefix + i);
    }
  } catch (err) {
  }
}
var loadCache = () => {
  if (loaded) {
    return;
  }
  loaded = true;
  const minTime = Math.floor(Date.now() / hour) - cacheExpiration;
  function load(key) {
    const func = getGlobal(key);
    if (!func) {
      return;
    }
    const getItem = (index2) => {
      const name = cachePrefix + index2;
      const item = func.getItem(name);
      if (typeof item !== "string") {
        return false;
      }
      let valid = true;
      try {
        const data = JSON.parse(item);
        if (typeof data !== "object" || typeof data.cached !== "number" || data.cached < minTime || typeof data.provider !== "string" || typeof data.data !== "object" || typeof data.data.prefix !== "string") {
          valid = false;
        } else {
          const provider = data.provider;
          const prefix = data.data.prefix;
          const storage2 = getStorage(provider, prefix);
          valid = addIconSet(storage2, data.data).length > 0;
        }
      } catch (err) {
        valid = false;
      }
      if (!valid) {
        func.removeItem(name);
      }
      return valid;
    };
    try {
      const version2 = func.getItem(versionKey);
      if (version2 !== cacheVersion) {
        if (version2) {
          destroyCache(func);
        }
        initCache(func, key);
        return;
      }
      let total = getCount(func);
      for (let i = total - 1; i >= 0; i--) {
        if (!getItem(i)) {
          if (i === total - 1) {
            total--;
          } else {
            emptyList[key].push(i);
          }
        }
      }
      setCount(func, key, total);
    } catch (err) {
    }
  }
  for (const key in config2) {
    load(key);
  }
};
var storeCache = (provider, data) => {
  if (!loaded) {
    loadCache();
  }
  function store(key) {
    if (!config2[key]) {
      return false;
    }
    const func = getGlobal(key);
    if (!func) {
      return false;
    }
    let index2 = emptyList[key].shift();
    if (index2 === void 0) {
      index2 = count[key];
      if (!setCount(func, key, index2 + 1)) {
        return false;
      }
    }
    try {
      const item = {
        cached: Math.floor(Date.now() / hour),
        provider,
        data
      };
      func.setItem(cachePrefix + index2, JSON.stringify(item));
    } catch (err) {
      return false;
    }
    return true;
  }
  if (!Object.keys(data.icons).length) {
    return;
  }
  if (data.not_found) {
    data = Object.assign({}, data);
    delete data.not_found;
  }
  if (!store("local")) {
    store("session");
  }
};
var separator = /[\s,]+/;
function flipFromString(custom, flip) {
  flip.split(separator).forEach((str) => {
    const value = str.trim();
    switch (value) {
      case "horizontal":
        custom.hFlip = true;
        break;
      case "vertical":
        custom.vFlip = true;
        break;
    }
  });
}
function alignmentFromString(custom, align) {
  align.split(separator).forEach((str) => {
    const value = str.trim();
    switch (value) {
      case "left":
      case "center":
      case "right":
        custom.hAlign = value;
        break;
      case "top":
      case "middle":
      case "bottom":
        custom.vAlign = value;
        break;
      case "slice":
      case "crop":
        custom.slice = true;
        break;
      case "meet":
        custom.slice = false;
    }
  });
}
function rotateFromString(value, defaultValue = 0) {
  const units = value.replace(/^-?[0-9.]*/, "");
  function cleanup(value2) {
    while (value2 < 0) {
      value2 += 4;
    }
    return value2 % 4;
  }
  if (units === "") {
    const num = parseInt(value);
    return isNaN(num) ? 0 : cleanup(num);
  } else if (units !== value) {
    let split = 0;
    switch (units) {
      case "%":
        split = 25;
        break;
      case "deg":
        split = 90;
    }
    if (split) {
      let num = parseFloat(value.slice(0, value.length - units.length));
      if (isNaN(num)) {
        return 0;
      }
      num = num / split;
      return num % 1 === 0 ? cleanup(num) : 0;
    }
  }
  return defaultValue;
}
var svgDefaults = {
  "xmlns": "http://www.w3.org/2000/svg",
  "xmlnsXlink": "http://www.w3.org/1999/xlink",
  "aria-hidden": true,
  "role": "img",
  "style": {}
};
var inlineDefaults = __spreadProps(__spreadValues({}, defaults), { inline: true });
var render = (icon, props, inline, ref) => {
  const defaultProps2 = inline ? inlineDefaults : defaults;
  const customisations = mergeCustomisations(defaultProps2, props);
  const style = typeof props.style === "object" && props.style !== null ? props.style : {};
  const componentProps = __spreadProps(__spreadValues({}, svgDefaults), { ref, style });
  for (let key in props) {
    const value = props[key];
    if (value === void 0) {
      continue;
    }
    switch (key) {
      case "icon":
      case "style":
      case "children":
      case "onLoad":
      case "_ref":
      case "_inline":
        break;
      case "inline":
      case "hFlip":
      case "vFlip":
        customisations[key] = value === true || value === "true" || value === 1;
        break;
      case "flip":
        if (typeof value === "string") {
          flipFromString(customisations, value);
        }
        break;
      case "align":
        if (typeof value === "string") {
          alignmentFromString(customisations, value);
        }
        break;
      case "color":
        style.color = value;
        break;
      case "rotate":
        if (typeof value === "string") {
          customisations[key] = rotateFromString(value);
        } else if (typeof value === "number") {
          customisations[key] = value;
        }
        break;
      case "ariaHidden":
      case "aria-hidden":
        if (value !== true && value !== "true") {
          delete componentProps["aria-hidden"];
        }
        break;
      default:
        if (defaultProps2[key] === void 0) {
          componentProps[key] = value;
        }
    }
  }
  const item = iconToSVG(icon, customisations);
  let localCounter = 0;
  let id = props.id;
  if (typeof id === "string") {
    id = id.replace(/-/g, "_");
  }
  componentProps.dangerouslySetInnerHTML = {
    __html: replaceIDs(item.body, id ? () => id + "ID" + localCounter++ : "iconifyReact")
  };
  for (let key in item.attributes) {
    componentProps[key] = item.attributes[key];
  }
  if (item.inline && style.verticalAlign === void 0) {
    style.verticalAlign = "-0.125em";
  }
  return import_react5.default.createElement("svg", componentProps);
};
allowSimpleNames(true);
setAPIModule("", fetchAPIModule);
if (typeof document !== "undefined" && typeof window !== "undefined") {
  cache.store = storeCache;
  loadCache();
  const _window2 = window;
  if (_window2.IconifyPreload !== void 0) {
    const preload = _window2.IconifyPreload;
    const err = "Invalid IconifyPreload syntax.";
    if (typeof preload === "object" && preload !== null) {
      (preload instanceof Array ? preload : [preload]).forEach((item) => {
        try {
          if (typeof item !== "object" || item === null || item instanceof Array || typeof item.icons !== "object" || typeof item.prefix !== "string" || !addCollection(item)) {
            console.error(err);
          }
        } catch (e) {
          console.error(err);
        }
      });
    }
  }
  if (_window2.IconifyProviders !== void 0) {
    const providers = _window2.IconifyProviders;
    if (typeof providers === "object" && providers !== null) {
      for (let key in providers) {
        const err = "IconifyProviders[" + key + "] is invalid.";
        try {
          const value = providers[key];
          if (typeof value !== "object" || !value || value.resources === void 0) {
            continue;
          }
          if (!addAPIProvider(key, value)) {
            console.error(err);
          }
        } catch (e) {
          console.error(err);
        }
      }
    }
  }
}
var IconComponent = class extends import_react5.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      icon: null
    };
  }
  _abortLoading() {
    if (this._loading) {
      this._loading.abort();
      this._loading = null;
    }
  }
  _setData(icon) {
    if (this.state.icon !== icon) {
      this.setState({
        icon
      });
    }
  }
  _checkIcon(changed) {
    const state = this.state;
    const icon = this.props.icon;
    if (typeof icon === "object" && icon !== null && typeof icon.body === "string") {
      this._icon = "";
      this._abortLoading();
      if (changed || state.icon === null) {
        this._setData({
          data: fullIcon(icon)
        });
      }
      return;
    }
    let iconName;
    if (typeof icon !== "string" || (iconName = stringToIcon(icon, false, true)) === null) {
      this._abortLoading();
      this._setData(null);
      return;
    }
    const data = getIconData(iconName);
    if (data === null) {
      if (!this._loading || this._loading.name !== icon) {
        this._abortLoading();
        this._icon = "";
        this._setData(null);
        this._loading = {
          name: icon,
          abort: loadIcons([iconName], this._checkIcon.bind(this, false))
        };
      }
      return;
    }
    if (this._icon !== icon || state.icon === null) {
      this._abortLoading();
      this._icon = icon;
      const classes = ["iconify"];
      if (iconName.prefix !== "") {
        classes.push("iconify--" + iconName.prefix);
      }
      if (iconName.provider !== "") {
        classes.push("iconify--" + iconName.provider);
      }
      this._setData({
        data,
        classes
      });
      if (this.props.onLoad) {
        this.props.onLoad(icon);
      }
    }
  }
  componentDidMount() {
    this._checkIcon(false);
  }
  componentDidUpdate(oldProps) {
    if (oldProps.icon !== this.props.icon) {
      this._checkIcon(true);
    }
  }
  componentWillUnmount() {
    this._abortLoading();
  }
  render() {
    const props = this.props;
    const icon = this.state.icon;
    if (icon === null) {
      return props.children ? props.children : import_react5.default.createElement("span", {});
    }
    let newProps = props;
    if (icon.classes) {
      newProps = __spreadProps(__spreadValues({}, props), {
        className: (typeof props.className === "string" ? props.className + " " : "") + icon.classes.join(" ")
      });
    }
    return render(icon.data, newProps, props._inline, props._ref);
  }
};
var Icon = import_react5.default.forwardRef(function Icon2(props, ref) {
  const newProps = __spreadProps(__spreadValues({}, props), {
    _ref: ref,
    _inline: false
  });
  return import_react5.default.createElement(IconComponent, newProps);
});
var InlineIcon = import_react5.default.forwardRef(function InlineIcon2(props, ref) {
  const newProps = __spreadProps(__spreadValues({}, props), { _ref: ref, _inline: true });
  return import_react5.default.createElement(IconComponent, newProps);
});

// app/components/about.tsx
function About() {
  return /* @__PURE__ */ React.createElement("section", {
    id: "about"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "col-md-12"
  }, /* @__PURE__ */ React.createElement("h1", {
    style: { color: "black" }
  }, /* @__PURE__ */ React.createElement("span", null, "About me")), /* @__PURE__ */ React.createElement("div", {
    className: "row center mx-auto mb-5"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "col-md-4 mb-5 center"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "polaroid"
  }, /* @__PURE__ */ React.createElement("span", {
    style: { cursor: "auto" }
  }, /* @__PURE__ */ React.createElement("img", {
    src: "images/myProfile.webp",
    alt: "My profile picture"
  }), /* @__PURE__ */ React.createElement(Icon, {
    icon: import_golang.default,
    style: { fontSize: "400%", margin: "9% 5% 0 5%", color: "#00ADD8" }
  }), /* @__PURE__ */ React.createElement(Icon, {
    icon: import_python.default,
    style: { fontSize: "400%", margin: "9% 5% 0 5%" }
  }), /* @__PURE__ */ React.createElement(Icon, {
    icon: import_kubernetes.default,
    style: { fontSize: "400%", margin: "9% 5% 0 5%" }
  })))), /* @__PURE__ */ React.createElement("div", {
    className: "col-md-8 center"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "col-md-10"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "card"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "card-header"
  }, /* @__PURE__ */ React.createElement("span", {
    className: "iconify",
    "data-icon": "emojione:red-circle",
    "data-inline": "false"
  }), " \xA0", " ", /* @__PURE__ */ React.createElement("span", {
    className: "iconify",
    "data-icon": "twemoji:yellow-circle",
    "data-inline": "false"
  }), " \xA0", " ", /* @__PURE__ */ React.createElement("span", {
    className: "iconify",
    "data-icon": "twemoji:green-circle",
    "data-inline": "false"
  })), /* @__PURE__ */ React.createElement("div", {
    className: "card-body font-trebuchet text-justify ml-3 mr-3",
    style: {
      height: "auto",
      fontSize: "132%",
      lineHeight: "200%"
    }
  }, /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("span", {
    className: "wave"
  }, "Hi \u{1F44B}"), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("p", null, "I'm Denis Fetinin. Golang and Python developer that loves building software. :)"), /* @__PURE__ */ React.createElement("p", null, "Secretly love frontend but most of the time work as a backend developer. I have expirience with microservices and event-driven architecture. Worked in E-commerce on apps and website backend, discounts, catalog, pricing, checkout, cart and other systems."))))))));
}

// app/components/experience.tsx
init_react();

// node_modules/react-bootstrap/esm/Badge.js
init_react();
var import_classnames = __toESM(require_classnames());
var React8 = __toESM(require_react());

// node_modules/react-bootstrap/esm/ThemeProvider.js
init_react();
var React7 = __toESM(require_react());
var import_react7 = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var ThemeContext = /* @__PURE__ */ React7.createContext({
  prefixes: {}
});
var {
  Consumer,
  Provider
} = ThemeContext;
function useBootstrapPrefix(prefix, defaultPrefix) {
  const {
    prefixes
  } = (0, import_react7.useContext)(ThemeContext);
  return prefix || prefixes[defaultPrefix] || defaultPrefix;
}

// node_modules/react-bootstrap/esm/Badge.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var defaultProps = {
  bg: "primary",
  pill: false
};
var Badge = /* @__PURE__ */ React8.forwardRef((_a, ref) => {
  var _b = _a, {
    bsPrefix,
    bg,
    pill,
    text,
    className,
    as: Component2 = "span"
  } = _b, props = __objRest(_b, [
    "bsPrefix",
    "bg",
    "pill",
    "text",
    "className",
    "as"
  ]);
  const prefix = useBootstrapPrefix(bsPrefix, "badge");
  return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Component2, __spreadProps(__spreadValues({
    ref
  }, props), {
    className: (0, import_classnames.default)(className, prefix, pill && `rounded-pill`, text && `text-${text}`, bg && `bg-${bg}`)
  }));
});
Badge.displayName = "Badge";
Badge.defaultProps = defaultProps;
var Badge_default = Badge;

// app/components/experience.tsx
var import_react_vertical_timeline_component = __toESM(require_dist_es6());
function Experience({ expirience }) {
  const work = expirience.map(function(work2, i) {
    const mainTech = work2.mainTech.map((technology, i2) => {
      return /* @__PURE__ */ React.createElement(Badge_default, {
        pill: true,
        className: "main-badge mr-2 mb-2",
        key: i2
      }, technology);
    });
    const tech = work2.technologies.map((technology, i2) => {
      return /* @__PURE__ */ React.createElement(Badge_default, {
        pill: true,
        className: "experience-badge mr-2 mb-2",
        key: i2
      }, technology);
    });
    return /* @__PURE__ */ React.createElement(import_react_vertical_timeline_component.VerticalTimelineElement, {
      className: "vertical-timeline-element--work",
      date: work2.years,
      iconStyle: {
        background: "#AE944F",
        color: "#fff",
        textAlign: "center"
      },
      icon: /* @__PURE__ */ React.createElement("i", {
        className: `experience-icon ${work2.iconClass}`
      }),
      key: i
    }, /* @__PURE__ */ React.createElement("div", {
      style: { textAlign: "left", marginBottom: "4px" }
    }, mainTech), /* @__PURE__ */ React.createElement("h3", {
      className: "vertical-timeline-element-title",
      style: { textAlign: "left" }
    }, work2.title), /* @__PURE__ */ React.createElement("h4", {
      className: "vertical-timeline-element-subtitle",
      style: { textAlign: "left" }
    }, /* @__PURE__ */ React.createElement("a", {
      href: work2.company.link
    }, "@", work2.company.title)), /* @__PURE__ */ React.createElement("div", {
      style: { textAlign: "left", marginTop: "15px" }
    }, tech));
  });
  return /* @__PURE__ */ React.createElement("section", {
    id: "resume",
    className: "pb-5"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "col-md-12 mx-auto"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "col-md-12"
  }, /* @__PURE__ */ React.createElement("h1", {
    className: "section-title",
    style: { color: "black" }
  }, /* @__PURE__ */ React.createElement("span", {
    className: "text-black",
    style: { textAlign: "center" }
  }, "Expirience")))), /* @__PURE__ */ React.createElement("div", {
    className: "col-md-8 mx-auto"
  }, /* @__PURE__ */ React.createElement(import_react_vertical_timeline_component.VerticalTimeline, null, work, /* @__PURE__ */ React.createElement(import_react_vertical_timeline_component.VerticalTimelineElement, {
    iconStyle: {
      background: "#AE944F",
      color: "#fff",
      textAlign: "center"
    },
    icon: /* @__PURE__ */ React.createElement("i", {
      className: "fas fa-hourglass-start mx-auto experience-icon"
    })
  }))));
}

// app/components/footer.tsx
init_react();
function Footer({ social }) {
  var networks = social.map(function(network) {
    return /* @__PURE__ */ React.createElement("span", {
      key: network.name,
      className: "m-4"
    }, /* @__PURE__ */ React.createElement("a", {
      href: network.url,
      target: "_blank",
      rel: "noopener noreferrer"
    }, /* @__PURE__ */ React.createElement("i", {
      className: network.class
    })));
  });
  return /* @__PURE__ */ React.createElement("footer", null, /* @__PURE__ */ React.createElement("div", {
    className: "col-md-12"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "social-links"
  }, networks), /* @__PURE__ */ React.createElement("div", {
    className: "copyright py-4 text-center"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "container"
  }, /* @__PURE__ */ React.createElement("small", null, "Copyright \xA9 Denis Fetinin")))));
}

// app/components/header.tsx
init_react();

// node_modules/react-typical/dist/index.es.js
init_react();
var import_react9 = __toESM(require_react());
async function type(node, ...args) {
  for (const arg of args) {
    switch (typeof arg) {
      case "string":
        await edit(node, arg);
        break;
      case "number":
        await wait(arg);
        break;
      case "function":
        await arg(node, ...args);
        break;
      default:
        await arg;
    }
  }
}
async function edit(node, text) {
  const overlap = getOverlap(node.textContent, text);
  await perform(node, [...deleter(node.textContent, overlap), ...writer(text, overlap)]);
}
async function wait(ms) {
  await new Promise((resolve) => setTimeout(resolve, ms));
}
async function perform(node, edits, speed = 60) {
  for (const op of editor(edits)) {
    op(node);
    await wait(speed + speed * (Math.random() - 0.5));
  }
}
function* editor(edits) {
  for (const edit2 of edits) {
    yield (node) => requestAnimationFrame(() => node.textContent = edit2);
  }
}
function* writer([...text], startIndex = 0, endIndex = text.length) {
  while (startIndex < endIndex) {
    yield text.slice(0, ++startIndex).join("");
  }
}
function* deleter([...text], startIndex = 0, endIndex = text.length) {
  while (endIndex > startIndex) {
    yield text.slice(0, --endIndex).join("");
  }
}
function getOverlap(start, [...end]) {
  return [...start, NaN].findIndex((char, i) => end[i] !== char);
}
function styleInject(css2, ref) {
  if (ref === void 0)
    ref = {};
  var insertAt = ref.insertAt;
  if (!css2 || typeof document === "undefined") {
    return;
  }
  var head = document.head || document.getElementsByTagName("head")[0];
  var style = document.createElement("style");
  style.type = "text/css";
  if (insertAt === "top") {
    if (head.firstChild) {
      head.insertBefore(style, head.firstChild);
    } else {
      head.appendChild(style);
    }
  } else {
    head.appendChild(style);
  }
  if (style.styleSheet) {
    style.styleSheet.cssText = css2;
  } else {
    style.appendChild(document.createTextNode(css2));
  }
}
var css = '.styles_typicalWrapper__1_Uvh::after {\n  content: "|";\n  animation: styles_blink__2CKyC 1s infinite step-start;\n}\n\n@keyframes styles_blink__2CKyC {\n  50% { opacity: 0; }\n}';
var styles = { "typicalWrapper": "styles_typicalWrapper__1_Uvh", "blink": "styles_blink__2CKyC" };
styleInject(css);
var toConsumableArray = function(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
      arr2[i] = arr[i];
    return arr2;
  } else {
    return Array.from(arr);
  }
};
var Typical = function Typical2(_ref) {
  var steps = _ref.steps, loop = _ref.loop, className = _ref.className, _ref$wrapper = _ref.wrapper, wrapper = _ref$wrapper === void 0 ? "p" : _ref$wrapper;
  var typicalRef = (0, import_react9.useRef)(null);
  var Component2 = wrapper;
  var classNames2 = [styles.typicalWrapper];
  if (className) {
    classNames2.unshift(className);
  }
  (0, import_react9.useEffect)(function() {
    if (loop === Infinity) {
      type.apply(void 0, [typicalRef.current].concat(toConsumableArray(steps), [type]));
    } else if (typeof loop === "number") {
      type.apply(void 0, [typicalRef.current].concat(toConsumableArray(Array(loop).fill(steps).flat())));
    } else {
      type.apply(void 0, [typicalRef.current].concat(toConsumableArray(steps)));
    }
  });
  return import_react9.default.createElement(Component2, { ref: typicalRef, className: classNames2.join(" ") });
};
var index = (0, import_react9.memo)(Typical);
var index_es_default = index;

// app/components/header.tsx
function Header() {
  const titles = ["Golang Developer", "Python developer", "Tech Lead"];
  const animationSpeed = 500;
  const titlesFormatted = titles.map((x) => [x.toUpperCase(), animationSpeed]).flat();
  return /* @__PURE__ */ React.createElement("header", {
    id: "home"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "row aligner",
    style: { height: "100%" }
  }, /* @__PURE__ */ React.createElement("div", {
    className: "col-md-12"
  }, /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("span", {
    className: "iconify header-icon",
    "data-icon": "la:laptop-code",
    "data-inline": "false"
  }), /* @__PURE__ */ React.createElement("br", null), /* @__PURE__ */ React.createElement("h1", {
    className: "mb-0"
  }, /* @__PURE__ */ React.createElement(index_es_default, {
    steps: ["Denis Fetinin"],
    wrapper: "p"
  })), /* @__PURE__ */ React.createElement("div", {
    className: "title-container"
  }, /* @__PURE__ */ React.createElement(index_es_default, {
    className: "title-styles",
    steps: titlesFormatted,
    loop: Infinity
  }))))));
}

// app/components/skills.tsx
init_react();
function Skills({ skills: skills2 }) {
  var skillsHtml = skills2.flatMap((skill, i) => {
    return /* @__PURE__ */ React.createElement("li", {
      className: "list-inline-item mx-3",
      key: i
    }, /* @__PURE__ */ React.createElement("span", null, /* @__PURE__ */ React.createElement("div", {
      className: "text-center skills-tile"
    }, /* @__PURE__ */ React.createElement("i", {
      className: skill.class,
      style: { fontSize: "220%" }
    }, /* @__PURE__ */ React.createElement("p", {
      className: "text-center",
      style: { fontSize: "30%", marginTop: "4px" }
    }, skill.name)))));
  });
  return /* @__PURE__ */ React.createElement("section", {
    id: "skills"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "col-md-12"
  }, /* @__PURE__ */ React.createElement("div", {
    className: "col-md-12"
  }, /* @__PURE__ */ React.createElement("h1", {
    className: "section-title"
  }, /* @__PURE__ */ React.createElement("span", {
    className: "text-white"
  }, "Skills"))), /* @__PURE__ */ React.createElement("div", {
    className: "col-md-12 text-center"
  }, /* @__PURE__ */ React.createElement("ul", {
    className: "list-inline mx-auto skill-icon"
  }, skillsHtml))));
}

// app/resume_content/experience.tsx
init_react();
var experience_default = [
  {
    title: "Senior Software Developer",
    company: { title: "Lamoda", link: "https://lamoda.ru/" },
    years: "10.2019 - present",
    mainTech: ["Golang"],
    technologies: ["Kafka", "PostgreSQL", "Kubernetes", "Python 3.6+", "Vue.js", "Django", "Reddis", "RabbitMQ"],
    iconClass: "fa-brands fa-golang"
  },
  {
    title: "Python Developer",
    company: { title: "Tionix", link: "https://www.tionix.ru" },
    years: "09.2016 - 08.2018",
    mainTech: ["Python 2.7/3"],
    technologies: ["Python", "Django", "RabbitMQ", "MySQL", "CentOS", "Rest API", "SQLAlchemy"],
    iconClass: "fab fa-python"
  }
];

// app/resume_content/skills.tsx
init_react();
var skills = [
  {
    name: "Golang",
    class: "devicon-go-plain",
    level: "95"
  },
  {
    name: "Python",
    class: "devicon-python-plain",
    level: "80"
  },
  {
    name: "Postgres",
    class: "devicon-postgresql-plain",
    level: "75"
  },
  {
    name: "Kafka",
    class: "devicon-apachekafka-plain",
    level: "70"
  },
  {
    name: "Kubernetes",
    class: "devicon-kubernetes-plain",
    level: "95"
  },
  {
    name: "VueJS",
    class: "devicon-vuejs-plain",
    level: "85"
  },
  {
    name: "MySql",
    class: "devicon-mysql-plain",
    level: "60"
  },
  {
    name: "TypeScript",
    class: "devicon-typescript-plain",
    level: "90"
  }
];

// app/resume_content/social.tsx
init_react();
var social_default = [
  {
    name: "linkedin",
    url: "https://www.linkedin.com/in/denis-fetinin",
    class: "fab fa-linkedin"
  },
  {
    name: "github",
    url: "https://github.com/What-If-I",
    class: "fab fa-github"
  },
  {
    name: "telegram",
    url: "https://www.t.me/fetinin",
    class: "fab fa-telegram"
  },
  {
    name: "instagram",
    url: "https://www.instagram.com/d.fetinin",
    class: "fab fa-instagram"
  }
];

// app/styles/app.css
var app_default = "/build/_assets/app-7SA7AXGI.css";

// route:/Users/denis.fetinin/dev/portfolio/app/routes/index.tsx
var links2 = () => {
  return [
    { rel: "stylesheet", href: style_min_default },
    { rel: "stylesheet", href: app_default }
  ];
};
function Index() {
  return /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement(Header, null), /* @__PURE__ */ React.createElement(About, null), /* @__PURE__ */ React.createElement(Skills, {
    skills
  }), /* @__PURE__ */ React.createElement(Experience, {
    expirience: experience_default
  }), /* @__PURE__ */ React.createElement(Footer, {
    social: social_default
  }));
}

// server-assets-manifest:@remix-run/dev/assets-manifest
init_react();
var assets_manifest_default = { "version": "db42cf12", "entry": { "module": "/build/entry.client-KXWHOVWG.js", "imports": ["/build/_shared/chunk-OUVEGUXJ.js", "/build/_shared/chunk-325D37MS.js"] }, "routes": { "root": { "id": "root", "parentId": void 0, "path": "", "index": void 0, "caseSensitive": void 0, "module": "/build/root-A3ZGX3EA.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false }, "routes/index": { "id": "routes/index", "parentId": "root", "path": void 0, "index": true, "caseSensitive": void 0, "module": "/build/routes/index-EADXTQI4.js", "imports": void 0, "hasAction": false, "hasLoader": false, "hasCatchBoundary": false, "hasErrorBoundary": false } }, "url": "/build/manifest-DB42CF12.js" };

// server-entry-module:@remix-run/dev/server-build
var entry = { module: entry_server_exports };
var routes = {
  "root": {
    id: "root",
    parentId: void 0,
    path: "",
    index: void 0,
    caseSensitive: void 0,
    module: root_exports
  },
  "routes/index": {
    id: "routes/index",
    parentId: "root",
    path: void 0,
    index: true,
    caseSensitive: void 0,
    module: routes_exports
  }
};

// server.js
var handleRequest2 = createPagesFunctionHandler({
  build: server_build_exports,
  mode: "development",
  getLoadContext: (context) => context.env
});
function onRequest(context) {
  return handleRequest2(context);
}
export {
  onRequest
};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/**
 * @remix-run/cloudflare-pages v1.2.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/react v1.2.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * @remix-run/server-runtime v1.2.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router DOM v6.2.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/**
 * React Router v6.2.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-dom-server.node.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vZGV2L2NvbXBpbGVyL3NoaW1zL3JlYWN0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9ub2RlX21vZHVsZXMvanNlc2MvanNlc2MuanMiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpldmVudHMiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpwcm9jZXNzIiwgIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9pbmhlcml0cy5qcyIsICJub2RlLW1vZHVsZXMtcG9seWZpbGxzOnV0aWwiLCAibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpidWZmZXIiLCAiLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS9idWZmZXItbGlzdC5qcyIsICJub2RlLW1vZHVsZXMtcG9seWZpbGxzOnN0cmluZ19kZWNvZGVyIiwgIi4uL25vZGVfbW9kdWxlcy9yb2xsdXAtcGx1Z2luLW5vZGUtcG9seWZpbGxzL3BvbHlmaWxscy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JvbGx1cC1wbHVnaW4tbm9kZS1wb2x5ZmlsbHMvcG9seWZpbGxzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsICIuLi9ub2RlX21vZHVsZXMvcm9sbHVwLXBsdWdpbi1ub2RlLXBvbHlmaWxscy9wb2x5ZmlsbHMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwgIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHM6c3RyZWFtIiwgIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHMtY29tbW9uanM6c3RyZWFtIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL3NlcnZlci5ub2RlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vc2VydmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AaWNvbmlmeS9pY29ucy1mYTYtYnJhbmRzL2dvbGFuZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQGljb25pZnkvaWNvbnMtbG9nb3Mva3ViZXJuZXRlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQGljb25pZnkvaWNvbnMtbG9nb3MvcHl0aG9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9jbGFzc25hbWVzL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1ydW50aW1lLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC12ZXJ0aWNhbC10aW1lbGluZS1jb21wb25lbnQvZGlzdC1lczYvVmVydGljYWxUaW1lbGluZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvc3JjL29ic2VydmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL3NyYy9JblZpZXcudHN4IiwgIi4uL25vZGVfbW9kdWxlcy9zcmMvdXNlSW5WaWV3LnRzeCIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QtdmVydGljYWwtdGltZWxpbmUtY29tcG9uZW50L2Rpc3QtZXM2L1ZlcnRpY2FsVGltZWxpbmVFbGVtZW50LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC12ZXJ0aWNhbC10aW1lbGluZS1jb21wb25lbnQvZGlzdC1lczYvaW5kZXguanMiLCAiLi4vc2VydmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMvZXNtL2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXMvZXNtL2dsb2JhbHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcy9lc20vY29va2llU2lnbmluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzL2VzbS9zZXNzaW9ucy9jbG91ZGZsYXJlS1ZTZXNzaW9uU3RvcmFnZS5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL3Jlc3BvbnNlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vc2VydmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9kYXRhLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9lbnRyeS5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vZXJyb3JzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9oZWFkZXJzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lL2VzbS9yb3V0ZU1hdGNoaW5nLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9oaXN0b3J5L2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwgIi4uLy4uL3BhY2thZ2VzL3JlYWN0LXJvdXRlci9pbmRleC50c3giLCAiLi4vLi4vcGFja2FnZXMvcmVhY3Qtcm91dGVyLWRvbS9pbmRleC50c3giLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL21vZGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUvZXNtL3JvdXRlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZS9lc20vc2VydmVySGFuZG9mZi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzL2VzbS93b3JrZXIuanMiLCAic2VydmVyLWVudHJ5LW1vZHVsZTpAcmVtaXgtcnVuL2Rldi9zZXJ2ZXItYnVpbGQiLCAiLi4vYXBwL2VudHJ5LnNlcnZlci50c3giLCAiLi4vbm9kZV9tb2R1bGVzL3JlbWl4L2VzbS9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2NvbXBvbmVudHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL192aXJ0dWFsL19yb2xsdXBQbHVnaW5CYWJlbEhlbHBlcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL2Vycm9yQm91bmRhcmllcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vaW52YXJpYW50LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9saW5rcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vcm91dGVNb2R1bGVzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9tYXJrdXAuanMiLCAiLi4vbm9kZV9tb2R1bGVzL0ByZW1peC1ydW4vcmVhY3QvZXNtL3JvdXRlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vZGF0YS5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vdHJhbnNpdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vcm91dGVNYXRjaGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yZWFjdC9lc20vc2Nyb2xsLXJlc3RvcmF0aW9uLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JlYWN0L2VzbS9zZXJ2ZXIuanMiLCAicm91dGU6L1VzZXJzL2RlbmlzLmZldGluaW4vZGV2L3BvcnRmb2xpby9hcHAvcm9vdC50c3giLCAicm91dGU6L1VzZXJzL2RlbmlzLmZldGluaW4vZGV2L3BvcnRmb2xpby9hcHAvcm91dGVzL2luZGV4LnRzeCIsICIuLi9hcHAvY29tcG9uZW50cy9hYm91dC50c3giLCAiLi4vbm9kZV9tb2R1bGVzL0BpY29uaWZ5L3JlYWN0L2Rpc3QvaWNvbmlmeS5tanMiLCAiLi4vYXBwL2NvbXBvbmVudHMvZXhwZXJpZW5jZS50c3giLCAiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWJvb3RzdHJhcC9lc20vQmFkZ2UuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWJvb3RzdHJhcC9lc20vVGhlbWVQcm92aWRlci5qcyIsICIuLi9hcHAvY29tcG9uZW50cy9mb290ZXIudHN4IiwgIi4uL2FwcC9jb21wb25lbnRzL2hlYWRlci50c3giLCAiLi4vbm9kZV9tb2R1bGVzL3JlYWN0LXR5cGljYWwvbm9kZV9tb2R1bGVzL0BjYW13aWVnZXJ0L3R5cGljYWwvdHlwaWNhbC5qcyIsICIuLi9ub2RlX21vZHVsZXMvcmVhY3QtdHlwaWNhbC9ub2RlX21vZHVsZXMvc3R5bGUtaW5qZWN0L2Rpc3Qvc3R5bGUtaW5qZWN0LmVzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9yZWFjdC10eXBpY2FsL3NyYy9pbmRleC5qcyIsICIuLi9hcHAvY29tcG9uZW50cy9za2lsbHMudHN4IiwgIi4uL2FwcC9yZXN1bWVfY29udGVudC9leHBlcmllbmNlLnRzeCIsICIuLi9hcHAvcmVzdW1lX2NvbnRlbnQvc2tpbGxzLnRzeCIsICIuLi9hcHAvcmVzdW1lX2NvbnRlbnQvc29jaWFsLnRzeCIsICJzZXJ2ZXItYXNzZXRzLW1hbmlmZXN0OkByZW1peC1ydW4vZGV2L2Fzc2V0cy1tYW5pZmVzdCJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsICIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE3LjAuMic7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG5leHBvcnRzLkZyYWdtZW50ID0gMHhlYWNiO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gMHhlYWNjO1xuZXhwb3J0cy5Qcm9maWxlciA9IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IDB4ZWFjZTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gMHhlYWQwO1xuZXhwb3J0cy5TdXNwZW5zZSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIGV4cG9ydHMuU3RyaWN0TW9kZSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgZXhwb3J0cy5Qcm9maWxlciA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIGV4cG9ydHMuU3VzcGVuc2UgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBkaXNwYXRjaGVyLlxuICovXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IGJhdGNoJ3MgY29uZmlndXJhdGlvbiBzdWNoIGFzIGhvdyBsb25nIGFuIHVwZGF0ZVxuICogc2hvdWxkIHN1c3BlbmQgZm9yIGlmIGl0IG5lZWRzIHRvLlxuICovXG52YXIgUmVhY3RDdXJyZW50QmF0Y2hDb25maWcgPSB7XG4gIHRyYW5zaXRpb246IDBcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcbnZhciBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gbnVsbDtcbmZ1bmN0aW9uIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjaykge1xuICB7XG4gICAgY3VycmVudEV4dHJhU3RhY2tGcmFtZSA9IHN0YWNrO1xuICB9XG59XG5cbntcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoc3RhY2spIHtcbiAgICB7XG4gICAgICBjdXJyZW50RXh0cmFTdGFja0ZyYW1lID0gc3RhY2s7XG4gICAgfVxuICB9OyAvLyBTdGFjayBpbXBsZW1lbnRhdGlvbiBpbmplY3RlZCBieSB0aGUgY3VycmVudCByZW5kZXJlci5cblxuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7IC8vIEFkZCBhbiBleHRyYSB0b3AgZnJhbWUgd2hpbGUgYW4gZWxlbWVudCBpcyBiZWluZyB2YWxpZGF0ZWRcblxuICAgIGlmIChjdXJyZW50RXh0cmFTdGFja0ZyYW1lKSB7XG4gICAgICBzdGFjayArPSBjdXJyZW50RXh0cmFTdGFja0ZyYW1lO1xuICAgIH0gLy8gRGVsZWdhdGUgdG8gdGhlIGluamVjdGVkIHJlbmRlcmVyLXNwZWNpZmljIGltcGxlbWVudGF0aW9uXG5cblxuICAgIHZhciBpbXBsID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2s7XG5cbiAgICBpZiAoaW1wbCkge1xuICAgICAgc3RhY2sgKz0gaW1wbCgpIHx8ICcnO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGFjdCgpIHRvIHRyYWNrIHdoZXRoZXIgeW91J3JlIGluc2lkZSBhbiBhY3QoKSBzY29wZS5cbiAqL1xudmFyIElzU29tZVJlbmRlcmVyQWN0aW5nID0ge1xuICBjdXJyZW50OiBmYWxzZVxufTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogUmVhY3RDdXJyZW50QmF0Y2hDb25maWcsXG4gIFJlYWN0Q3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgSXNTb21lUmVuZGVyZXJBY3Rpbmc6IElzU29tZVJlbmRlcmVyQWN0aW5nLFxuICAvLyBVc2VkIGJ5IHJlbmRlcmVycyB0byBhdm9pZCBidW5kbGluZyBvYmplY3QtYXNzaWduIHR3aWNlIGluIFVNRCBidW5kbGVzOlxuICBhc3NpZ246IF9hc3NpZ25cbn07XG5cbntcbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG59XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgKF9jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBfY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArIFwiLlwiICsgY2FsbGVyTmFtZTtcblxuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcihcIkNhbid0IGNhbGwgJXMgb24gYSBjb21wb25lbnQgdGhhdCBpcyBub3QgeWV0IG1vdW50ZWQuIFwiICsgJ1RoaXMgaXMgYSBuby1vcCwgYnV0IGl0IG1pZ2h0IGluZGljYXRlIGEgYnVnIGluIHlvdXIgYXBwbGljYXRpb24uICcgKyAnSW5zdGVhZCwgYXNzaWduIHRvIGB0aGlzLnN0YXRlYCBkaXJlY3RseSBvciBkZWZpbmUgYSBgc3RhdGUgPSB7fTtgICcgKyAnY2xhc3MgcHJvcGVydHkgd2l0aCB0aGUgZGVzaXJlZCBzdGF0ZSBpbiB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xuXG5cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDsgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgaWYgKCEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblxuXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG5cblxue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG5cbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4vKipcbiAqIENvbnZlbmllbmNlIGNvbXBvbmVudCB3aXRoIGRlZmF1bHQgc2hhbGxvdyBlcXVhbGl0eSBjaGVjayBmb3Igc0NVLlxuICovXG5cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyAvLyBJZiBhIGNvbXBvbmVudCBoYXMgc3RyaW5nIHJlZnMsIHdlIHdpbGwgYXNzaWduIGEgZGlmZmVyZW50IG9iamVjdCBsYXRlci5cblxuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7IC8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuXG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuLy8gYW4gaW1tdXRhYmxlIG9iamVjdCB3aXRoIGEgc2luZ2xlIG11dGFibGUgdmFsdWVcbmZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcbiAgdmFyIHJlZk9iamVjdCA9IHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5zZWFsKHJlZk9iamVjdCk7XG4gIH1cblxuICByZXR1cm4gcmVmT2JqZWN0O1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLkZyYWdtZW50OlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBleHBvcnRzLlByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3RyaWN0TW9kZTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIGV4cG9ydHMuU3VzcGVuc2U6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24sIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duLCBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0cmluZ1JlZnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRSZWYoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdyZWYnKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAncmVmJykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuXG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBjb25maWcuX19zZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBjb25maWcuX19zZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGNvbXBvbmVudE5hbWUsIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG5cbiAgICAgIHtcbiAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBzZWxmID0gY29uZmlnLl9fc2VsZiA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NlbGY7XG4gICAgc291cmNlID0gY29uZmlnLl9fc291cmNlID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc291cmNlOyAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgaWYgKCEhKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdW5kZWZpbmVkKSkge1xuICAgIHtcbiAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0LmNsb25lRWxlbWVudCguLi4pOiBUaGUgYXJndW1lbnQgbXVzdCBiZSBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB5b3UgcGFzc2VkIFwiICsgZWxlbWVudCArIFwiLlwiICk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3BOYW1lOyAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG5cbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmOyAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjsgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTsgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG5cblxuICAgIHZhciBkZWZhdWx0UHJvcHM7XG5cbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuXG5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG5cbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuXG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuXG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6Jztcbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSBrZXkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gdGV4dC5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBlbGVtZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGVsZW1lbnQgQSBlbGVtZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRFbGVtZW50S2V5KGVsZW1lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnICYmIGVsZW1lbnQgIT09IG51bGwgJiYgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoJycgKyBlbGVtZW50LmtleSk7XG4gIH0gLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcblxuXG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIG1hcEludG9BcnJheShjaGlsZHJlbiwgYXJyYXksIGVzY2FwZWRQcmVmaXgsIG5hbWVTb0ZhciwgY2FsbGJhY2spIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpbnZva2VDYWxsYmFjayA9IGZhbHNlO1xuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBzd2l0Y2ggKGNoaWxkcmVuLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIGludm9rZUNhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgaWYgKGludm9rZUNhbGxiYWNrKSB7XG4gICAgdmFyIF9jaGlsZCA9IGNoaWxkcmVuO1xuICAgIHZhciBtYXBwZWRDaGlsZCA9IGNhbGxiYWNrKF9jaGlsZCk7IC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93czpcblxuICAgIHZhciBjaGlsZEtleSA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRFbGVtZW50S2V5KF9jaGlsZCwgMCkgOiBuYW1lU29GYXI7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShtYXBwZWRDaGlsZCkpIHtcbiAgICAgIHZhciBlc2NhcGVkQ2hpbGRLZXkgPSAnJztcblxuICAgICAgaWYgKGNoaWxkS2V5ICE9IG51bGwpIHtcbiAgICAgICAgZXNjYXBlZENoaWxkS2V5ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KGNoaWxkS2V5KSArICcvJztcbiAgICAgIH1cblxuICAgICAgbWFwSW50b0FycmF5KG1hcHBlZENoaWxkLCBhcnJheSwgZXNjYXBlZENoaWxkS2V5LCAnJywgZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKG1hcHBlZENoaWxkICE9IG51bGwpIHtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsIC8vIEtlZXAgYm90aCB0aGUgKG1hcHBlZCkgYW5kIG9sZCBrZXlzIGlmIHRoZXkgZGlmZmVyLCBqdXN0IGFzXG4gICAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAgICBlc2NhcGVkUHJlZml4ICsgKCAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIFJlYWN0LlBvcnRhbCBkb2Vzbid0IGhhdmUgYSBrZXlcbiAgICAgICAgbWFwcGVkQ2hpbGQua2V5ICYmICghX2NoaWxkIHx8IF9jaGlsZC5rZXkgIT09IG1hcHBlZENoaWxkLmtleSkgPyAvLyAkRmxvd0ZpeE1lIEZsb3cgaW5jb3JyZWN0bHkgdGhpbmtzIGV4aXN0aW5nIGVsZW1lbnQncyBrZXkgY2FuIGJlIGEgbnVtYmVyXG4gICAgICAgIGVzY2FwZVVzZXJQcm92aWRlZEtleSgnJyArIG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgICB9XG5cbiAgICAgIGFycmF5LnB1c2gobWFwcGVkQ2hpbGQpO1xuICAgIH1cblxuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRFbGVtZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaXRlcmFibGVDaGlsZHJlbiA9IGNoaWxkcmVuO1xuXG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gaXRlcmFibGVDaGlsZHJlbi5lbnRyaWVzKSB7XG4gICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRNYXBzKSB7XG4gICAgICAgICAgICB3YXJuKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoaXRlcmFibGVDaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG5cbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0RWxlbWVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSBtYXBJbnRvQXJyYXkoY2hpbGQsIGFycmF5LCBlc2NhcGVkUHJlZml4LCBuZXh0TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBjaGlsZHJlblN0cmluZyA9ICcnICsgY2hpbGRyZW47XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIk9iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogXCIgKyAoY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nKSArIFwiKS4gSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSBpbnN0ZWFkLlwiICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3RjaGlsZHJlbm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmdW5jIFRoZSBtYXAgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgQ29udGV4dCBmb3IgbWFwRnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuYywgY29udGV4dCkge1xuICBpZiAoY2hpbGRyZW4gPT0gbnVsbCkge1xuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGNvdW50ID0gMDtcbiAgbWFwSW50b0FycmF5KGNoaWxkcmVuLCByZXN1bHQsICcnLCAnJywgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgY291bnQrKyk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdGNoaWxkcmVuY291bnRcbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbi5cbiAqL1xuXG5cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIG4gPSAwO1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIG4rKzsgLy8gRG9uJ3QgcmV0dXJuIGFueXRoaW5nXG4gIH0pO1xuICByZXR1cm4gbjtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5mb3JlYWNoXG4gKlxuICogVGhlIHByb3ZpZGVkIGZvckVhY2hGdW5jKGNoaWxkLCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZvckVhY2hGdW5jXG4gKiBAcGFyYW0geyp9IGZvckVhY2hDb250ZXh0IENvbnRleHQgZm9yIGZvckVhY2hDb250ZXh0LlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hGdW5jLCBmb3JFYWNoQ29udGV4dCkge1xuICBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKCkge1xuICAgIGZvckVhY2hGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIERvbid0IHJldHVybiBhbnl0aGluZy5cbiAgfSwgZm9yRWFjaENvbnRleHQpO1xufVxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW50b2FycmF5XG4gKi9cblxuXG5mdW5jdGlvbiB0b0FycmF5KGNoaWxkcmVuKSB7XG4gIHJldHVybiBtYXBDaGlsZHJlbihjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9KSB8fCBbXTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0Y2hpbGRyZW5vbmx5XG4gKlxuICogVGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgYSBzaW5nbGUgY2hpbGQgZ2V0c1xuICogcGFzc2VkIHdpdGhvdXQgYSB3cmFwcGVyLCBidXQgdGhlIHB1cnBvc2Ugb2YgdGhpcyBoZWxwZXIgZnVuY3Rpb24gaXMgdG9cbiAqIGFic3RyYWN0IGF3YXkgdGhlIHBhcnRpY3VsYXIgc3RydWN0dXJlIG9mIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gY2hpbGRyZW4gQ2hpbGQgY29sbGVjdGlvbiBzdHJ1Y3R1cmUuXG4gKiBAcmV0dXJuIHtSZWFjdEVsZW1lbnR9IFRoZSBmaXJzdCBhbmQgb25seSBgUmVhY3RFbGVtZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cblxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKSB7XG4gIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChjYWxjdWxhdGVDaGFuZ2VkQml0cyAhPT0gbnVsbCAmJiB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ2NyZWF0ZUNvbnRleHQ6IEV4cGVjdGVkIHRoZSBvcHRpb25hbCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIGNhbGN1bGF0ZUNoYW5nZWRCaXRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgIF9jYWxjdWxhdGVDaGFuZ2VkQml0czogY2FsY3VsYXRlQ2hhbmdlZEJpdHMsXG4gICAgLy8gQXMgYSB3b3JrYXJvdW5kIHRvIHN1cHBvcnQgbXVsdGlwbGUgY29uY3VycmVudCByZW5kZXJlcnMsIHdlIGNhdGVnb3JpemVcbiAgICAvLyBzb21lIHJlbmRlcmVycyBhcyBwcmltYXJ5IGFuZCBvdGhlcnMgYXMgc2Vjb25kYXJ5LiBXZSBvbmx5IGV4cGVjdFxuICAgIC8vIHRoZXJlIHRvIGJlIHR3byBjb25jdXJyZW50IHJlbmRlcmVycyBhdCBtb3N0OiBSZWFjdCBOYXRpdmUgKHByaW1hcnkpIGFuZFxuICAgIC8vIEZhYnJpYyAoc2Vjb25kYXJ5KTsgUmVhY3QgRE9NIChwcmltYXJ5KSBhbmQgUmVhY3QgQVJUIChzZWNvbmRhcnkpLlxuICAgIC8vIFNlY29uZGFyeSByZW5kZXJlcnMgc3RvcmUgdGhlaXIgY29udGV4dCB2YWx1ZXMgb24gc2VwYXJhdGUgZmllbGRzLlxuICAgIF9jdXJyZW50VmFsdWU6IGRlZmF1bHRWYWx1ZSxcbiAgICBfY3VycmVudFZhbHVlMjogZGVmYXVsdFZhbHVlLFxuICAgIC8vIFVzZWQgdG8gdHJhY2sgaG93IG1hbnkgY29uY3VycmVudCByZW5kZXJlcnMgdGhpcyBjb250ZXh0IGN1cnJlbnRseVxuICAgIC8vIHN1cHBvcnRzIHdpdGhpbiBpbiBhIHNpbmdsZSByZW5kZXJlci4gU3VjaCBhcyBwYXJhbGxlbCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgIF90aHJlYWRDb3VudDogMCxcbiAgICAvLyBUaGVzZSBhcmUgY2lyY3VsYXJcbiAgICBQcm92aWRlcjogbnVsbCxcbiAgICBDb25zdW1lcjogbnVsbFxuICB9O1xuICBjb250ZXh0LlByb3ZpZGVyID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9QUk9WSURFUl9UWVBFLFxuICAgIF9jb250ZXh0OiBjb250ZXh0XG4gIH07XG4gIHZhciBoYXNXYXJuZWRBYm91dFVzaW5nTmVzdGVkQ29udGV4dENvbnN1bWVycyA9IGZhbHNlO1xuICB2YXIgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIgPSBmYWxzZTtcbiAgdmFyIGhhc1dhcm5lZEFib3V0RGlzcGxheU5hbWVPbkNvbnN1bWVyID0gZmFsc2U7XG5cbiAge1xuICAgIC8vIEEgc2VwYXJhdGUgb2JqZWN0LCBidXQgcHJveGllcyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBjb250ZXh0IG9iamVjdCBmb3JcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSXQgaGFzIGEgZGlmZmVyZW50ICQkdHlwZW9mLCBzbyB3ZSBjYW4gcHJvcGVybHlcbiAgICAvLyB3YXJuIGZvciB0aGUgaW5jb3JyZWN0IHVzYWdlIG9mIENvbnRleHQgYXMgYSBDb25zdW1lci5cbiAgICB2YXIgQ29uc3VtZXIgPSB7XG4gICAgICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAgICAgX2NvbnRleHQ6IGNvbnRleHQsXG4gICAgICBfY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IGNvbnRleHQuX2NhbGN1bGF0ZUNoYW5nZWRCaXRzXG4gICAgfTsgLy8gJEZsb3dGaXhNZTogRmxvdyBjb21wbGFpbnMgYWJvdXQgbm90IHNldHRpbmcgYSB2YWx1ZSwgd2hpY2ggaXMgaW50ZW50aW9uYWwgaGVyZVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ29uc3VtZXIsIHtcbiAgICAgIFByb3ZpZGVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnN1bWVyUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdDb25zdW1lclByb3ZpZGVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Qcm92aWRlcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Qcm92aWRlcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Qcm92aWRlcjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX1Byb3ZpZGVyKSB7XG4gICAgICAgICAgY29udGV4dC5Qcm92aWRlciA9IF9Qcm92aWRlcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jdXJyZW50VmFsdWU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IF9jdXJyZW50VmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfY3VycmVudFZhbHVlMjoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5fY3VycmVudFZhbHVlMjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoX2N1cnJlbnRWYWx1ZTIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gX2N1cnJlbnRWYWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfdGhyZWFkQ291bnQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnRleHQuX3RocmVhZENvdW50O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChfdGhyZWFkQ291bnQpIHtcbiAgICAgICAgICBjb250ZXh0Ll90aHJlYWRDb3VudCA9IF90aHJlYWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIENvbnN1bWVyOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05lc3RlZENvbnRleHRDb25zdW1lcnMpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZEFib3V0VXNpbmdOZXN0ZWRDb250ZXh0Q29uc3VtZXJzID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlbmRlcmluZyA8Q29udGV4dC5Db25zdW1lci5Db25zdW1lcj4gaXMgbm90IHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gRGlkIHlvdSBtZWFuIHRvIHJlbmRlciA8Q29udGV4dC5Db25zdW1lcj4gaW5zdGVhZD8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY29udGV4dC5Db25zdW1lcjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc3BsYXlOYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjb250ZXh0LmRpc3BsYXlOYW1lO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xuICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIpIHtcbiAgICAgICAgICAgIHdhcm4oJ1NldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiBDb250ZXh0LkNvbnN1bWVyIGhhcyBubyBlZmZlY3QuICcgKyBcIllvdSBzaG91bGQgc2V0IGl0IGRpcmVjdGx5IG9uIHRoZSBjb250ZXh0IHdpdGggQ29udGV4dC5kaXNwbGF5TmFtZSA9ICclcycuXCIsIGRpc3BsYXlOYW1lKTtcblxuICAgICAgICAgICAgaGFzV2FybmVkQWJvdXREaXNwbGF5TmFtZU9uQ29uc3VtZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pOyAvLyAkRmxvd0ZpeE1lOiBGbG93IGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBkb2Vzbid0IHVuZGVyc3RhbmQgZGVmaW5lUHJvcGVydHlcblxuICAgIGNvbnRleHQuQ29uc3VtZXIgPSBDb25zdW1lcjtcbiAgfVxuXG4gIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbnZhciBVbmluaXRpYWxpemVkID0gLTE7XG52YXIgUGVuZGluZyA9IDA7XG52YXIgUmVzb2x2ZWQgPSAxO1xudmFyIFJlamVjdGVkID0gMjtcblxuZnVuY3Rpb24gbGF6eUluaXRpYWxpemVyKHBheWxvYWQpIHtcbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gVW5pbml0aWFsaXplZCkge1xuICAgIHZhciBjdG9yID0gcGF5bG9hZC5fcmVzdWx0O1xuICAgIHZhciB0aGVuYWJsZSA9IGN0b3IoKTsgLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuICAgIHZhciBwZW5kaW5nID0gcGF5bG9hZDtcbiAgICBwZW5kaW5nLl9zdGF0dXMgPSBQZW5kaW5nO1xuICAgIHBlbmRpbmcuX3Jlc3VsdCA9IHRoZW5hYmxlO1xuICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG1vZHVsZU9iamVjdCkge1xuICAgICAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUGVuZGluZykge1xuICAgICAgICB2YXIgZGVmYXVsdEV4cG9ydCA9IG1vZHVsZU9iamVjdC5kZWZhdWx0O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGVmYXVsdEV4cG9ydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlcnJvcignbGF6eTogRXhwZWN0ZWQgdGhlIHJlc3VsdCBvZiBhIGR5bmFtaWMgaW1wb3J0KCkgY2FsbC4gJyArICdJbnN0ZWFkIHJlY2VpdmVkOiAlc1xcblxcbllvdXIgY29kZSBzaG91bGQgbG9vayBsaWtlOiBcXG4gICcgKyAvLyBCcmVhayB1cCBpbXBvcnRzIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwYXJzaW5nIHRoZW0gYXMgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgJ2NvbnN0IE15Q29tcG9uZW50ID0gbGF6eSgoKSA9PiBpbXAnICsgXCJvcnQoJy4vTXlDb21wb25lbnQnKSlcIiwgbW9kdWxlT2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVHJhbnNpdGlvbiB0byB0aGUgbmV4dCBzdGF0ZS5cblxuXG4gICAgICAgIHZhciByZXNvbHZlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlc29sdmVkLl9zdGF0dXMgPSBSZXNvbHZlZDtcbiAgICAgICAgcmVzb2x2ZWQuX3Jlc3VsdCA9IGRlZmF1bHRFeHBvcnQ7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICBpZiAocGF5bG9hZC5fc3RhdHVzID09PSBQZW5kaW5nKSB7XG4gICAgICAgIC8vIFRyYW5zaXRpb24gdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgICAgIHZhciByZWplY3RlZCA9IHBheWxvYWQ7XG4gICAgICAgIHJlamVjdGVkLl9zdGF0dXMgPSBSZWplY3RlZDtcbiAgICAgICAgcmVqZWN0ZWQuX3Jlc3VsdCA9IGVycm9yO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHBheWxvYWQuX3N0YXR1cyA9PT0gUmVzb2x2ZWQpIHtcbiAgICByZXR1cm4gcGF5bG9hZC5fcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHRocm93IHBheWxvYWQuX3Jlc3VsdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYXp5KGN0b3IpIHtcbiAgdmFyIHBheWxvYWQgPSB7XG4gICAgLy8gV2UgdXNlIHRoZXNlIGZpZWxkcyB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICAgIF9zdGF0dXM6IC0xLFxuICAgIF9yZXN1bHQ6IGN0b3JcbiAgfTtcbiAgdmFyIGxhenlUeXBlID0ge1xuICAgICQkdHlwZW9mOiBSRUFDVF9MQVpZX1RZUEUsXG4gICAgX3BheWxvYWQ6IHBheWxvYWQsXG4gICAgX2luaXQ6IGxhenlJbml0aWFsaXplclxuICB9O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGp1c3Qgc2V0IGl0IG9uIHRoZSBvYmplY3QuXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICB2YXIgcHJvcFR5cGVzOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhsYXp5VHlwZSwge1xuICAgICAgZGVmYXVsdFByb3BzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGRlZmF1bHRQcm9wcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3RGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYGRlZmF1bHRQcm9wc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIGRlZmF1bHRQcm9wcyA9IG5ld0RlZmF1bHRQcm9wczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAnZGVmYXVsdFByb3BzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvcFR5cGVzOiB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BUeXBlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3UHJvcFR5cGVzKSB7XG4gICAgICAgICAgZXJyb3IoJ1JlYWN0LmxhenkoLi4uKTogSXQgaXMgbm90IHN1cHBvcnRlZCB0byBhc3NpZ24gYHByb3BUeXBlc2AgdG8gJyArICdhIGxhenkgY29tcG9uZW50IGltcG9ydC4gRWl0aGVyIHNwZWNpZnkgdGhlbSB3aGVyZSB0aGUgY29tcG9uZW50ICcgKyAnaXMgZGVmaW5lZCwgb3IgY3JlYXRlIGEgd3JhcHBpbmcgY29tcG9uZW50IGFyb3VuZCBpdC4nKTtcblxuICAgICAgICAgIHByb3BUeXBlcyA9IG5ld1Byb3BUeXBlczsgLy8gTWF0Y2ggcHJvZHVjdGlvbiBiZWhhdmlvciBtb3JlIGNsb3NlbHk6XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGxhenlUeXBlLCAncHJvcFR5cGVzJywge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGF6eVR5cGU7XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWYocmVuZGVyKSB7XG4gIHtcbiAgICBpZiAocmVuZGVyICE9IG51bGwgJiYgcmVuZGVyLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCByZWNlaXZlZCBhIGBtZW1vYCAnICsgJ2NvbXBvbmVudC4gSW5zdGVhZCBvZiBmb3J3YXJkUmVmKG1lbW8oLi4uKSksIHVzZSAnICsgJ21lbW8oZm9yd2FyZFJlZiguLi4pKS4nKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZW5kZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlcXVpcmVzIGEgcmVuZGVyIGZ1bmN0aW9uIGJ1dCB3YXMgZ2l2ZW4gJXMuJywgcmVuZGVyID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHJlbmRlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChyZW5kZXIubGVuZ3RoICE9PSAwICYmIHJlbmRlci5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgZXJyb3IoJ2ZvcndhcmRSZWYgcmVuZGVyIGZ1bmN0aW9ucyBhY2NlcHQgZXhhY3RseSB0d28gcGFyYW1ldGVyczogcHJvcHMgYW5kIHJlZi4gJXMnLCByZW5kZXIubGVuZ3RoID09PSAxID8gJ0RpZCB5b3UgZm9yZ2V0IHRvIHVzZSB0aGUgcmVmIHBhcmFtZXRlcj8nIDogJ0FueSBhZGRpdGlvbmFsIHBhcmFtZXRlciB3aWxsIGJlIHVuZGVmaW5lZC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVuZGVyICE9IG51bGwpIHtcbiAgICAgIGlmIChyZW5kZXIuZGVmYXVsdFByb3BzICE9IG51bGwgfHwgcmVuZGVyLnByb3BUeXBlcyAhPSBudWxsKSB7XG4gICAgICAgIGVycm9yKCdmb3J3YXJkUmVmIHJlbmRlciBmdW5jdGlvbnMgZG8gbm90IHN1cHBvcnQgcHJvcFR5cGVzIG9yIGRlZmF1bHRQcm9wcy4gJyArICdEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIGEgUmVhY3QgY29tcG9uZW50PycpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSxcbiAgICByZW5kZXI6IHJlbmRlclxuICB9O1xuXG4gIHtcbiAgICB2YXIgb3duTmFtZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudFR5cGUsICdkaXNwbGF5TmFtZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBvd25OYW1lO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgb3duTmFtZSA9IG5hbWU7XG5cbiAgICAgICAgaWYgKHJlbmRlci5kaXNwbGF5TmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmVuZGVyLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBleHBvcnRzLlByb2ZpbGVyIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IGV4cG9ydHMuU3RyaWN0TW9kZSB8fCB0eXBlID09PSBleHBvcnRzLlN1c3BlbnNlIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSB8fCB0eXBlWzBdID09PSBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBtZW1vKHR5cGUsIGNvbXBhcmUpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICBlcnJvcignbWVtbzogVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBjb21wb25lbnQuIEluc3RlYWQgJyArICdyZWNlaXZlZDogJXMnLCB0eXBlID09PSBudWxsID8gJ251bGwnIDogdHlwZW9mIHR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50VHlwZSA9IHtcbiAgICAkJHR5cGVvZjogUkVBQ1RfTUVNT19UWVBFLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgY29tcGFyZTogY29tcGFyZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBhcmVcbiAgfTtcblxuICB7XG4gICAgdmFyIG93bk5hbWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnRUeXBlLCAnZGlzcGxheU5hbWUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3duTmFtZTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIG93bk5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lID09IG51bGwpIHtcbiAgICAgICAgICB0eXBlLmRpc3BsYXlOYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRUeXBlO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRGlzcGF0Y2hlcigpIHtcbiAgdmFyIGRpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7XG5cbiAgaWYgKCEoZGlzcGF0Y2hlciAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXNwYXRjaGVyO1xufVxuXG5mdW5jdGlvbiB1c2VDb250ZXh0KENvbnRleHQsIHVuc3RhYmxlX29ic2VydmVkQml0cykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG5cbiAge1xuICAgIGlmICh1bnN0YWJsZV9vYnNlcnZlZEJpdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IoJ3VzZUNvbnRleHQoKSBzZWNvbmQgYXJndW1lbnQgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSAnICsgJ3VzZSBpbiBSZWFjdC4gUGFzc2luZyBpdCBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1lvdSBwYXNzZWQ6ICVzLiVzJywgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzLCB0eXBlb2YgdW5zdGFibGVfb2JzZXJ2ZWRCaXRzID09PSAnbnVtYmVyJyAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1syXSkgPyAnXFxuXFxuRGlkIHlvdSBjYWxsIGFycmF5Lm1hcCh1c2VDb250ZXh0KT8gJyArICdDYWxsaW5nIEhvb2tzIGluc2lkZSBhIGxvb3AgaXMgbm90IHN1cHBvcnRlZC4gJyArICdMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9ydWxlcy1vZi1ob29rcycgOiAnJyk7XG4gICAgfSAvLyBUT0RPOiBhZGQgYSBtb3JlIGdlbmVyaWMgd2FybmluZyBmb3IgaW52YWxpZCB2YWx1ZXMuXG5cblxuICAgIGlmIChDb250ZXh0Ll9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciByZWFsQ29udGV4dCA9IENvbnRleHQuX2NvbnRleHQ7IC8vIERvbid0IGRlZHVwbGljYXRlIGJlY2F1c2UgdGhpcyBsZWdpdGltYXRlbHkgY2F1c2VzIGJ1Z3NcbiAgICAgIC8vIGFuZCBub2JvZHkgc2hvdWxkIGJlIHVzaW5nIHRoaXMgaW4gZXhpc3RpbmcgY29kZS5cblxuICAgICAgaWYgKHJlYWxDb250ZXh0LkNvbnN1bWVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Db25zdW1lcikgaXMgbm90IHN1cHBvcnRlZCwgbWF5IGNhdXNlIGJ1Z3MsIGFuZCB3aWxsIGJlICcgKyAncmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9IGVsc2UgaWYgKHJlYWxDb250ZXh0LlByb3ZpZGVyID09PSBDb250ZXh0KSB7XG4gICAgICAgIGVycm9yKCdDYWxsaW5nIHVzZUNvbnRleHQoQ29udGV4dC5Qcm92aWRlcikgaXMgbm90IHN1cHBvcnRlZC4gJyArICdEaWQgeW91IG1lYW4gdG8gY2FsbCB1c2VDb250ZXh0KENvbnRleHQpIGluc3RlYWQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlQ29udGV4dChDb250ZXh0LCB1bnN0YWJsZV9vYnNlcnZlZEJpdHMpO1xufVxuZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn1cbmZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG59XG5mdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlUmVmKGluaXRpYWxWYWx1ZSk7XG59XG5mdW5jdGlvbiB1c2VFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG59XG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbn1cbmZ1bmN0aW9uIHVzZU1lbW8oY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgcmV0dXJuIGRpc3BhdGNoZXIudXNlTWVtbyhjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZGlzcGF0Y2hlciA9IHJlc29sdmVEaXNwYXRjaGVyKCk7XG4gIHJldHVybiBkaXNwYXRjaGVyLnVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xufVxuZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAge1xuICAgIHZhciBkaXNwYXRjaGVyID0gcmVzb2x2ZURpc3BhdGNoZXIoKTtcbiAgICByZXR1cm4gZGlzcGF0Y2hlci51c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXJGbik7XG4gIH1cbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBleHBvcnRzLlN1c3BlbnNlOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtRm9yUHJvcHMoZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzLl9fc291cmNlKTtcbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICBpZiAoIWluZm8pIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluZm87XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gIH1cblxuICB7XG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bUZvclByb3BzKHByb3BzKTtcblxuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSA9IGZhbHNlO1xuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgaWYgKCFkaWRXYXJuQWJvdXREZXByZWNhdGVkQ3JlYXRlRmFjdG9yeSkge1xuICAgICAgZGlkV2FybkFib3V0RGVwcmVjYXRlZENyZWF0ZUZhY3RvcnkgPSB0cnVlO1xuXG4gICAgICB3YXJuKCdSZWFjdC5jcmVhdGVGYWN0b3J5KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluICcgKyAnYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gQ29uc2lkZXIgdXNpbmcgSlNYICcgKyAnb3IgdXNlIFJlYWN0LmNyZWF0ZUVsZW1lbnQoKSBkaXJlY3RseSBpbnN0ZWFkLicpO1xuICAgIH0gLy8gTGVnYWN5IGhvb2s6IHJlbW92ZSBpdFxuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB3YXJuKCdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cblxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbntcblxuICB0cnkge1xuICAgIHZhciBmcm96ZW5PYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cblxuICAgIG5ldyBNYXAoW1tmcm96ZW5PYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbZnJvemVuT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICB9XG59XG5cbnZhciBjcmVhdGVFbGVtZW50JDEgPSAgY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uIDtcbnZhciBjbG9uZUVsZW1lbnQkMSA9ICBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiA7XG52YXIgY3JlYXRlRmFjdG9yeSA9ICBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24gO1xudmFyIENoaWxkcmVuID0ge1xuICBtYXA6IG1hcENoaWxkcmVuLFxuICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gIGNvdW50OiBjb3VudENoaWxkcmVuLFxuICB0b0FycmF5OiB0b0FycmF5LFxuICBvbmx5OiBvbmx5Q2hpbGRcbn07XG5cbmV4cG9ydHMuQ2hpbGRyZW4gPSBDaGlsZHJlbjtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5QdXJlQ29tcG9uZW50ID0gUHVyZUNvbXBvbmVudDtcbmV4cG9ydHMuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdFNoYXJlZEludGVybmFscztcbmV4cG9ydHMuY2xvbmVFbGVtZW50ID0gY2xvbmVFbGVtZW50JDE7XG5leHBvcnRzLmNyZWF0ZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0O1xuZXhwb3J0cy5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudCQxO1xuZXhwb3J0cy5jcmVhdGVGYWN0b3J5ID0gY3JlYXRlRmFjdG9yeTtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5mb3J3YXJkUmVmID0gZm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnQgPSBpc1ZhbGlkRWxlbWVudDtcbmV4cG9ydHMubGF6eSA9IGxhenk7XG5leHBvcnRzLm1lbW8gPSBtZW1vO1xuZXhwb3J0cy51c2VDYWxsYmFjayA9IHVzZUNhbGxiYWNrO1xuZXhwb3J0cy51c2VDb250ZXh0ID0gdXNlQ29udGV4dDtcbmV4cG9ydHMudXNlRGVidWdWYWx1ZSA9IHVzZURlYnVnVmFsdWU7XG5leHBvcnRzLnVzZUVmZmVjdCA9IHVzZUVmZmVjdDtcbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IHVzZUltcGVyYXRpdmVIYW5kbGU7XG5leHBvcnRzLnVzZUxheW91dEVmZmVjdCA9IHVzZUxheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTWVtbyA9IHVzZU1lbW87XG5leHBvcnRzLnVzZVJlZHVjZXIgPSB1c2VSZWR1Y2VyO1xuZXhwb3J0cy51c2VSZWYgPSB1c2VSZWY7XG5leHBvcnRzLnVzZVN0YXRlID0gdXNlU3RhdGU7XG5leHBvcnRzLnZlcnNpb24gPSBSZWFjdFZlcnNpb247XG4gIH0pKCk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCAiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5leHBvcnQgeyBSZWFjdCB9O1xuIiwgIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZGVmYXVsdFBhcnNlT3B0aW9ucyA9IHtcbiAgZGVjb2RlVmFsdWVzOiB0cnVlLFxuICBtYXA6IGZhbHNlLFxuICBzaWxlbnQ6IGZhbHNlLFxufTtcblxuZnVuY3Rpb24gaXNOb25FbXB0eVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIgJiYgISFzdHIudHJpbSgpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzZXRDb29raWVWYWx1ZSwgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBzZXRDb29raWVWYWx1ZS5zcGxpdChcIjtcIikuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpO1xuICB2YXIgbmFtZVZhbHVlID0gcGFydHMuc2hpZnQoKS5zcGxpdChcIj1cIik7XG4gIHZhciBuYW1lID0gbmFtZVZhbHVlLnNoaWZ0KCk7XG4gIHZhciB2YWx1ZSA9IG5hbWVWYWx1ZS5qb2luKFwiPVwiKTsgLy8gZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgPSwgam9pbmVkIGJ5IGEgXCI9XCIgaWYgdGhlcmUgd2FzIG1vcmUgdGhhbiBvbmUgcGFydFxuXG4gIG9wdGlvbnMgPSBvcHRpb25zXG4gICAgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKVxuICAgIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcblxuICB0cnkge1xuICAgIHZhbHVlID0gb3B0aW9ucy5kZWNvZGVWYWx1ZXMgPyBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpIDogdmFsdWU7IC8vIGRlY29kZSBjb29raWUgdmFsdWVcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcInNldC1jb29raWUtcGFyc2VyIGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGRlY29kaW5nIGEgY29va2llIHdpdGggdmFsdWUgJ1wiICtcbiAgICAgICAgdmFsdWUgK1xuICAgICAgICBcIicuIFNldCBvcHRpb25zLmRlY29kZVZhbHVlcyB0byBmYWxzZSB0byBkaXNhYmxlIHRoaXMgZmVhdHVyZS5cIixcbiAgICAgIGVcbiAgICApO1xuICB9XG5cbiAgdmFyIGNvb2tpZSA9IHtcbiAgICBuYW1lOiBuYW1lLCAvLyBncmFiIGV2ZXJ5dGhpbmcgYmVmb3JlIHRoZSBmaXJzdCA9XG4gICAgdmFsdWU6IHZhbHVlLFxuICB9O1xuXG4gIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHBhcnQpIHtcbiAgICB2YXIgc2lkZXMgPSBwYXJ0LnNwbGl0KFwiPVwiKTtcbiAgICB2YXIga2V5ID0gc2lkZXMuc2hpZnQoKS50cmltTGVmdCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHZhbHVlID0gc2lkZXMuam9pbihcIj1cIik7XG4gICAgaWYgKGtleSA9PT0gXCJleHBpcmVzXCIpIHtcbiAgICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm1heC1hZ2VcIikge1xuICAgICAgY29va2llLm1heEFnZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2VjdXJlXCIpIHtcbiAgICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImh0dHBvbmx5XCIpIHtcbiAgICAgIGNvb2tpZS5odHRwT25seSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2FtZXNpdGVcIikge1xuICAgICAgY29va2llLnNhbWVTaXRlID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvb2tpZVtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29va2llO1xufVxuXG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9uc1xuICAgID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcnNlT3B0aW9ucywgb3B0aW9ucylcbiAgICA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG5cbiAgaWYgKCFpbnB1dCkge1xuICAgIGlmICghb3B0aW9ucy5tYXApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbnB1dC5oZWFkZXJzICYmIGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdKSB7XG4gICAgLy8gZmFzdC1wYXRoIGZvciBub2RlLmpzICh3aGljaCBhdXRvbWF0aWNhbGx5IG5vcm1hbGl6ZXMgaGVhZGVyIG5hbWVzIHRvIGxvd2VyLWNhc2VcbiAgICBpbnB1dCA9IGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdO1xuICB9IGVsc2UgaWYgKGlucHV0LmhlYWRlcnMpIHtcbiAgICAvLyBzbG93LXBhdGggZm9yIG90aGVyIGVudmlyb25tZW50cyAtIHNlZSAjMjVcbiAgICB2YXIgc2NoID1cbiAgICAgIGlucHV0LmhlYWRlcnNbXG4gICAgICAgIE9iamVjdC5rZXlzKGlucHV0LmhlYWRlcnMpLmZpbmQoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gXCJzZXQtY29va2llXCI7XG4gICAgICAgIH0pXG4gICAgICBdO1xuICAgIC8vIHdhcm4gaWYgY2FsbGVkIG9uIGEgcmVxdWVzdC1saWtlIG9iamVjdCB3aXRoIGEgY29va2llIGhlYWRlciByYXRoZXIgdGhhbiBhIHNldC1jb29raWUgaGVhZGVyIC0gc2VlICMzNCwgMzZcbiAgICBpZiAoIXNjaCAmJiBpbnB1dC5oZWFkZXJzLmNvb2tpZSAmJiAhb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJXYXJuaW5nOiBzZXQtY29va2llLXBhcnNlciBhcHBlYXJzIHRvIGhhdmUgYmVlbiBjYWxsZWQgb24gYSByZXF1ZXN0IG9iamVjdC4gSXQgaXMgZGVzaWduZWQgdG8gcGFyc2UgU2V0LUNvb2tpZSBoZWFkZXJzIGZyb20gcmVzcG9uc2VzLCBub3QgQ29va2llIGhlYWRlcnMgZnJvbSByZXF1ZXN0cy4gU2V0IHRoZSBvcHRpb24ge3NpbGVudDogdHJ1ZX0gdG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpbnB1dCA9IHNjaDtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgaW5wdXQgPSBbaW5wdXRdO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnNcbiAgICA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpXG4gICAgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuXG4gIGlmICghb3B0aW9ucy5tYXApIHtcbiAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY29va2llcyA9IHt9O1xuICAgIHJldHVybiBpbnB1dC5maWx0ZXIoaXNOb25FbXB0eVN0cmluZykucmVkdWNlKGZ1bmN0aW9uIChjb29raWVzLCBzdHIpIHtcbiAgICAgIHZhciBjb29raWUgPSBwYXJzZVN0cmluZyhzdHIsIG9wdGlvbnMpO1xuICAgICAgY29va2llc1tjb29raWUubmFtZV0gPSBjb29raWU7XG4gICAgICByZXR1cm4gY29va2llcztcbiAgICB9LCBjb29raWVzKTtcbiAgfVxufVxuXG4vKlxuICBTZXQtQ29va2llIGhlYWRlciBmaWVsZC12YWx1ZXMgYXJlIHNvbWV0aW1lcyBjb21tYSBqb2luZWQgaW4gb25lIHN0cmluZy4gVGhpcyBzcGxpdHMgdGhlbSB3aXRob3V0IGNob2tpbmcgb24gY29tbWFzXG4gIHRoYXQgYXJlIHdpdGhpbiBhIHNpbmdsZSBzZXQtY29va2llIGZpZWxkLXZhbHVlLCBzdWNoIGFzIGluIHRoZSBFeHBpcmVzIHBvcnRpb24uXG5cbiAgVGhpcyBpcyB1bmNvbW1vbiwgYnV0IGV4cGxpY2l0bHkgYWxsb3dlZCAtIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjYxNiNzZWN0aW9uLTQuMlxuICBOb2RlLmpzIGRvZXMgdGhpcyBmb3IgZXZlcnkgaGVhZGVyICpleGNlcHQqIHNldC1jb29raWUgLSBzZWUgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvZDVlMzYzYjc3ZWJhZjFjYWY2N2NkNzUyODIyNGI2NTFjODY4MTVjMS9saWIvX2h0dHBfaW5jb21pbmcuanMjTDEyOFxuICBSZWFjdCBOYXRpdmUncyBmZXRjaCBkb2VzIHRoaXMgZm9yICpldmVyeSogaGVhZGVyLCBpbmNsdWRpbmcgc2V0LWNvb2tpZS5cblxuICBCYXNlZCBvbjogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9qMm9iamMvY29tbWl0LzE2ODIwZmRiYzhmNzZjYTBjMzM0NzI4MTBjZTBjYjAzZDIwZWZlMjVcbiAgQ3JlZGl0cyB0bzogaHR0cHM6Ly9naXRodWIuY29tL3RvbWJhbGwgZm9yIG9yaWdpbmFsIGFuZCBodHRwczovL2dpdGh1Yi5jb20vY2hydXNhcnQgZm9yIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb25cbiovXG5mdW5jdGlvbiBzcGxpdENvb2tpZXNTdHJpbmcoY29va2llc1N0cmluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb29raWVzU3RyaW5nKSkge1xuICAgIHJldHVybiBjb29raWVzU3RyaW5nO1xuICB9XG4gIGlmICh0eXBlb2YgY29va2llc1N0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBjb29raWVzU3RyaW5ncyA9IFtdO1xuICB2YXIgcG9zID0gMDtcbiAgdmFyIHN0YXJ0O1xuICB2YXIgY2g7XG4gIHZhciBsYXN0Q29tbWE7XG4gIHZhciBuZXh0U3RhcnQ7XG4gIHZhciBjb29raWVzU2VwYXJhdG9yRm91bmQ7XG5cbiAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIC9cXHMvLnRlc3QoY29va2llc1N0cmluZy5jaGFyQXQocG9zKSkpIHtcbiAgICAgIHBvcyArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gcG9zIDwgY29va2llc1N0cmluZy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBub3RTcGVjaWFsQ2hhcigpIHtcbiAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG5cbiAgICByZXR1cm4gY2ggIT09IFwiPVwiICYmIGNoICE9PSBcIjtcIiAmJiBjaCAhPT0gXCIsXCI7XG4gIH1cblxuICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGgpIHtcbiAgICBzdGFydCA9IHBvcztcbiAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSBmYWxzZTtcblxuICAgIHdoaWxlIChza2lwV2hpdGVzcGFjZSgpKSB7XG4gICAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICBpZiAoY2ggPT09IFwiLFwiKSB7XG4gICAgICAgIC8vICcsJyBpcyBhIGNvb2tpZSBzZXBhcmF0b3IgaWYgd2UgaGF2ZSBsYXRlciBmaXJzdCAnPScsIG5vdCAnOycgb3IgJywnXG4gICAgICAgIGxhc3RDb21tYSA9IHBvcztcbiAgICAgICAgcG9zICs9IDE7XG5cbiAgICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgbmV4dFN0YXJ0ID0gcG9zO1xuXG4gICAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBub3RTcGVjaWFsQ2hhcigpKSB7XG4gICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjdXJyZW50bHkgc3BlY2lhbCBjaGFyYWN0ZXJcbiAgICAgICAgaWYgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykgPT09IFwiPVwiKSB7XG4gICAgICAgICAgLy8gd2UgZm91bmQgY29va2llcyBzZXBhcmF0b3JcbiAgICAgICAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSB0cnVlO1xuICAgICAgICAgIC8vIHBvcyBpcyBpbnNpZGUgdGhlIG5leHQgY29va2llLCBzbyBiYWNrIHVwIGFuZCByZXR1cm4gaXQuXG4gICAgICAgICAgcG9zID0gbmV4dFN0YXJ0O1xuICAgICAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGxhc3RDb21tYSkpO1xuICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGluIHBhcmFtICcsJyBvciBwYXJhbSBzZXBhcmF0b3IgJzsnLFxuICAgICAgICAgIC8vIHdlIGNvbnRpbnVlIGZyb20gdGhhdCBjb21tYVxuICAgICAgICAgIHBvcyA9IGxhc3RDb21tYSArIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvcyArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY29va2llc1NlcGFyYXRvckZvdW5kIHx8IHBvcyA+PSBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgY29va2llc1N0cmluZy5sZW5ndGgpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29va2llc1N0cmluZ3M7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xubW9kdWxlLmV4cG9ydHMucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcbm1vZHVsZS5leHBvcnRzLnNwbGl0Q29va2llc1N0cmluZyA9IHNwbGl0Q29va2llc1N0cmluZztcbiIsICIndXNlIHN0cmljdCc7XG5cbmNvbnN0IG9iamVjdCA9IHt9O1xuY29uc3QgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG5jb25zdCBmb3JPd24gPSAob2JqZWN0LCBjYWxsYmFjaykgPT4ge1xuXHRmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcblx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcblx0XHRcdGNhbGxiYWNrKGtleSwgb2JqZWN0W2tleV0pO1xuXHRcdH1cblx0fVxufTtcblxuY29uc3QgZXh0ZW5kID0gKGRlc3RpbmF0aW9uLCBzb3VyY2UpID0+IHtcblx0aWYgKCFzb3VyY2UpIHtcblx0XHRyZXR1cm4gZGVzdGluYXRpb247XG5cdH1cblx0Zm9yT3duKHNvdXJjZSwgKGtleSwgdmFsdWUpID0+IHtcblx0XHRkZXN0aW5hdGlvbltrZXldID0gdmFsdWU7XG5cdH0pO1xuXHRyZXR1cm4gZGVzdGluYXRpb247XG59O1xuXG5jb25zdCBmb3JFYWNoID0gKGFycmF5LCBjYWxsYmFjaykgPT4ge1xuXHRjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdGxldCBpbmRleCA9IC0xO1xuXHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdGNhbGxiYWNrKGFycmF5W2luZGV4XSk7XG5cdH1cbn07XG5cbmNvbnN0IGZvdXJIZXhFc2NhcGUgPSAoaGV4KSA9PiB7XG5cdHJldHVybiAnXFxcXHUnICsgKCcwMDAwJyArIGhleCkuc2xpY2UoLTQpO1xufVxuXG5jb25zdCBoZXhhZGVjaW1hbCA9IChjb2RlLCBsb3dlcmNhc2UpID0+IHtcblx0bGV0IGhleGFkZWNpbWFsID0gY29kZS50b1N0cmluZygxNik7XG5cdGlmIChsb3dlcmNhc2UpIHJldHVybiBoZXhhZGVjaW1hbDtcblx0cmV0dXJuIGhleGFkZWNpbWFsLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5jb25zdCB0b1N0cmluZyA9IG9iamVjdC50b1N0cmluZztcbmNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuY29uc3QgaXNCdWZmZXIgPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLmlzQnVmZmVyKHZhbHVlKTtcbn07XG5jb25zdCBpc09iamVjdCA9ICh2YWx1ZSkgPT4ge1xuXHQvLyBUaGlzIGlzIGEgdmVyeSBzaW1wbGUgY2hlY2ssIGJ1dCBpdFx1MjAxOXMgZ29vZCBlbm91Z2ggZm9yIHdoYXQgd2UgbmVlZC5cblx0cmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IE9iamVjdF0nO1xufTtcbmNvbnN0IGlzU3RyaW5nID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHxcblx0XHR0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5jb25zdCBpc051bWJlciA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8XG5cdFx0dG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4ge1xuXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbic7XG59O1xuY29uc3QgaXNNYXAgPSAodmFsdWUpID0+IHtcblx0cmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09ICdbb2JqZWN0IE1hcF0nO1xufTtcbmNvbnN0IGlzU2V0ID0gKHZhbHVlKSA9PiB7XG5cdHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSAnW29iamVjdCBTZXRdJztcbn07XG5cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4vLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lc2NhcGVzI3NpbmdsZVxuY29uc3Qgc2luZ2xlRXNjYXBlcyA9IHtcblx0J1xcXFwnOiAnXFxcXFxcXFwnLFxuXHQnXFxiJzogJ1xcXFxiJyxcblx0J1xcZic6ICdcXFxcZicsXG5cdCdcXG4nOiAnXFxcXG4nLFxuXHQnXFxyJzogJ1xcXFxyJyxcblx0J1xcdCc6ICdcXFxcdCdcblx0Ly8gYFxcdmAgaXMgb21pdHRlZCBpbnRlbnRpb25hbGx5LCBiZWNhdXNlIGluIElFIDwgOSwgJ1xcdicgPT0gJ3YnLlxuXHQvLyAnXFx2JzogJ1xcXFx4MEInXG59O1xuY29uc3QgcmVnZXhTaW5nbGVFc2NhcGUgPSAvW1xcXFxcXGJcXGZcXG5cXHJcXHRdLztcblxuY29uc3QgcmVnZXhEaWdpdCA9IC9bMC05XS87XG5jb25zdCByZWdleFdoaXRlc3BhY2UgPSAvW1xceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMjhcXHUyMDI5XFx1MjAyRlxcdTIwNUZcXHUzMDAwXS87XG5cbmNvbnN0IGVzY2FwZUV2ZXJ5dGhpbmdSZWdleCA9IC8oW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXSl8KFtcXHVEODAwLVxcdURGRkZdKXwoWydcImBdKXxbXl0vZztcbmNvbnN0IGVzY2FwZU5vbkFzY2lpUmVnZXggPSAvKFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0pfChbXFx1RDgwMC1cXHVERkZGXSl8KFsnXCJgXSl8W14gISMtJlxcKC1cXFtcXF0tX2Etfl0vZztcblxuY29uc3QganNlc2MgPSAoYXJndW1lbnQsIG9wdGlvbnMpID0+IHtcblx0Y29uc3QgaW5jcmVhc2VJbmRlbnRhdGlvbiA9ICgpID0+IHtcblx0XHRvbGRJbmRlbnQgPSBpbmRlbnQ7XG5cdFx0KytvcHRpb25zLmluZGVudExldmVsO1xuXHRcdGluZGVudCA9IG9wdGlvbnMuaW5kZW50LnJlcGVhdChvcHRpb25zLmluZGVudExldmVsKVxuXHR9O1xuXHQvLyBIYW5kbGUgb3B0aW9uc1xuXHRjb25zdCBkZWZhdWx0cyA9IHtcblx0XHQnZXNjYXBlRXZlcnl0aGluZyc6IGZhbHNlLFxuXHRcdCdtaW5pbWFsJzogZmFsc2UsXG5cdFx0J2lzU2NyaXB0Q29udGV4dCc6IGZhbHNlLFxuXHRcdCdxdW90ZXMnOiAnc2luZ2xlJyxcblx0XHQnd3JhcCc6IGZhbHNlLFxuXHRcdCdlczYnOiBmYWxzZSxcblx0XHQnanNvbic6IGZhbHNlLFxuXHRcdCdjb21wYWN0JzogdHJ1ZSxcblx0XHQnbG93ZXJjYXNlSGV4JzogZmFsc2UsXG5cdFx0J251bWJlcnMnOiAnZGVjaW1hbCcsXG5cdFx0J2luZGVudCc6ICdcXHQnLFxuXHRcdCdpbmRlbnRMZXZlbCc6IDAsXG5cdFx0J19faW5saW5lMV9fJzogZmFsc2UsXG5cdFx0J19faW5saW5lMl9fJzogZmFsc2Vcblx0fTtcblx0Y29uc3QganNvbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5qc29uO1xuXHRpZiAoanNvbikge1xuXHRcdGRlZmF1bHRzLnF1b3RlcyA9ICdkb3VibGUnO1xuXHRcdGRlZmF1bHRzLndyYXAgPSB0cnVlO1xuXHR9XG5cdG9wdGlvbnMgPSBleHRlbmQoZGVmYXVsdHMsIG9wdGlvbnMpO1xuXHRpZiAoXG5cdFx0b3B0aW9ucy5xdW90ZXMgIT0gJ3NpbmdsZScgJiZcblx0XHRvcHRpb25zLnF1b3RlcyAhPSAnZG91YmxlJyAmJlxuXHRcdG9wdGlvbnMucXVvdGVzICE9ICdiYWNrdGljaydcblx0KSB7XG5cdFx0b3B0aW9ucy5xdW90ZXMgPSAnc2luZ2xlJztcblx0fVxuXHRjb25zdCBxdW90ZSA9IG9wdGlvbnMucXVvdGVzID09ICdkb3VibGUnID9cblx0XHQnXCInIDpcblx0XHQob3B0aW9ucy5xdW90ZXMgPT0gJ2JhY2t0aWNrJyA/XG5cdFx0XHQnYCcgOlxuXHRcdFx0J1xcJydcblx0XHQpO1xuXHRjb25zdCBjb21wYWN0ID0gb3B0aW9ucy5jb21wYWN0O1xuXHRjb25zdCBsb3dlcmNhc2VIZXggPSBvcHRpb25zLmxvd2VyY2FzZUhleDtcblx0bGV0IGluZGVudCA9IG9wdGlvbnMuaW5kZW50LnJlcGVhdChvcHRpb25zLmluZGVudExldmVsKTtcblx0bGV0IG9sZEluZGVudCA9ICcnO1xuXHRjb25zdCBpbmxpbmUxID0gb3B0aW9ucy5fX2lubGluZTFfXztcblx0Y29uc3QgaW5saW5lMiA9IG9wdGlvbnMuX19pbmxpbmUyX187XG5cdGNvbnN0IG5ld0xpbmUgPSBjb21wYWN0ID8gJycgOiAnXFxuJztcblx0bGV0IHJlc3VsdDtcblx0bGV0IGlzRW1wdHkgPSB0cnVlO1xuXHRjb25zdCB1c2VCaW5OdW1iZXJzID0gb3B0aW9ucy5udW1iZXJzID09ICdiaW5hcnknO1xuXHRjb25zdCB1c2VPY3ROdW1iZXJzID0gb3B0aW9ucy5udW1iZXJzID09ICdvY3RhbCc7XG5cdGNvbnN0IHVzZURlY051bWJlcnMgPSBvcHRpb25zLm51bWJlcnMgPT0gJ2RlY2ltYWwnO1xuXHRjb25zdCB1c2VIZXhOdW1iZXJzID0gb3B0aW9ucy5udW1iZXJzID09ICdoZXhhZGVjaW1hbCc7XG5cblx0aWYgKGpzb24gJiYgYXJndW1lbnQgJiYgaXNGdW5jdGlvbihhcmd1bWVudC50b0pTT04pKSB7XG5cdFx0YXJndW1lbnQgPSBhcmd1bWVudC50b0pTT04oKTtcblx0fVxuXG5cdGlmICghaXNTdHJpbmcoYXJndW1lbnQpKSB7XG5cdFx0aWYgKGlzTWFwKGFyZ3VtZW50KSkge1xuXHRcdFx0aWYgKGFyZ3VtZW50LnNpemUgPT0gMCkge1xuXHRcdFx0XHRyZXR1cm4gJ25ldyBNYXAoKSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWNvbXBhY3QpIHtcblx0XHRcdFx0b3B0aW9ucy5fX2lubGluZTFfXyA9IHRydWU7XG5cdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUyX18gPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAnbmV3IE1hcCgnICsganNlc2MoQXJyYXkuZnJvbShhcmd1bWVudCksIG9wdGlvbnMpICsgJyknO1xuXHRcdH1cblx0XHRpZiAoaXNTZXQoYXJndW1lbnQpKSB7XG5cdFx0XHRpZiAoYXJndW1lbnQuc2l6ZSA9PSAwKSB7XG5cdFx0XHRcdHJldHVybiAnbmV3IFNldCgpJztcblx0XHRcdH1cblx0XHRcdHJldHVybiAnbmV3IFNldCgnICsganNlc2MoQXJyYXkuZnJvbShhcmd1bWVudCksIG9wdGlvbnMpICsgJyknO1xuXHRcdH1cblx0XHRpZiAoaXNCdWZmZXIoYXJndW1lbnQpKSB7XG5cdFx0XHRpZiAoYXJndW1lbnQubGVuZ3RoID09IDApIHtcblx0XHRcdFx0cmV0dXJuICdCdWZmZXIuZnJvbShbXSknO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICdCdWZmZXIuZnJvbSgnICsganNlc2MoQXJyYXkuZnJvbShhcmd1bWVudCksIG9wdGlvbnMpICsgJyknO1xuXHRcdH1cblx0XHRpZiAoaXNBcnJheShhcmd1bWVudCkpIHtcblx0XHRcdHJlc3VsdCA9IFtdO1xuXHRcdFx0b3B0aW9ucy53cmFwID0gdHJ1ZTtcblx0XHRcdGlmIChpbmxpbmUxKSB7XG5cdFx0XHRcdG9wdGlvbnMuX19pbmxpbmUxX18gPSBmYWxzZTtcblx0XHRcdFx0b3B0aW9ucy5fX2lubGluZTJfXyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWlubGluZTIpIHtcblx0XHRcdFx0aW5jcmVhc2VJbmRlbnRhdGlvbigpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yRWFjaChhcmd1bWVudCwgKHZhbHVlKSA9PiB7XG5cdFx0XHRcdGlzRW1wdHkgPSBmYWxzZTtcblx0XHRcdFx0aWYgKGlubGluZTIpIHtcblx0XHRcdFx0XHRvcHRpb25zLl9faW5saW5lMl9fID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzdWx0LnB1c2goXG5cdFx0XHRcdFx0KGNvbXBhY3QgfHwgaW5saW5lMiA/ICcnIDogaW5kZW50KSArXG5cdFx0XHRcdFx0anNlc2ModmFsdWUsIG9wdGlvbnMpXG5cdFx0XHRcdCk7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChpc0VtcHR5KSB7XG5cdFx0XHRcdHJldHVybiAnW10nO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGlubGluZTIpIHtcblx0XHRcdFx0cmV0dXJuICdbJyArIHJlc3VsdC5qb2luKCcsICcpICsgJ10nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICdbJyArIG5ld0xpbmUgKyByZXN1bHQuam9pbignLCcgKyBuZXdMaW5lKSArIG5ld0xpbmUgK1xuXHRcdFx0XHQoY29tcGFjdCA/ICcnIDogb2xkSW5kZW50KSArICddJztcblx0XHR9IGVsc2UgaWYgKGlzTnVtYmVyKGFyZ3VtZW50KSkge1xuXHRcdFx0aWYgKGpzb24pIHtcblx0XHRcdFx0Ly8gU29tZSBudW1iZXIgdmFsdWVzIChlLmcuIGBJbmZpbml0eWApIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OLlxuXHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJndW1lbnQpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHVzZURlY051bWJlcnMpIHtcblx0XHRcdFx0cmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodXNlSGV4TnVtYmVycykge1xuXHRcdFx0XHRsZXQgaGV4YWRlY2ltYWwgPSBhcmd1bWVudC50b1N0cmluZygxNik7XG5cdFx0XHRcdGlmICghbG93ZXJjYXNlSGV4KSB7XG5cdFx0XHRcdFx0aGV4YWRlY2ltYWwgPSBoZXhhZGVjaW1hbC50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiAnMHgnICsgaGV4YWRlY2ltYWw7XG5cdFx0XHR9XG5cdFx0XHRpZiAodXNlQmluTnVtYmVycykge1xuXHRcdFx0XHRyZXR1cm4gJzBiJyArIGFyZ3VtZW50LnRvU3RyaW5nKDIpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHVzZU9jdE51bWJlcnMpIHtcblx0XHRcdFx0cmV0dXJuICcwbycgKyBhcmd1bWVudC50b1N0cmluZyg4KTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCFpc09iamVjdChhcmd1bWVudCkpIHtcblx0XHRcdGlmIChqc29uKSB7XG5cdFx0XHRcdC8vIEZvciBzb21lIHZhbHVlcyAoZS5nLiBgdW5kZWZpbmVkYCwgYGZ1bmN0aW9uYCBvYmplY3RzKSxcblx0XHRcdFx0Ly8gYEpTT04uc3RyaW5naWZ5KHZhbHVlKWAgcmV0dXJucyBgdW5kZWZpbmVkYCAod2hpY2ggaXNuXHUyMDE5dCB2YWxpZFxuXHRcdFx0XHQvLyBKU09OKSBpbnN0ZWFkIG9mIGAnbnVsbCdgLlxuXHRcdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJndW1lbnQpIHx8ICdudWxsJztcblx0XHRcdH1cblx0XHRcdHJldHVybiBTdHJpbmcoYXJndW1lbnQpO1xuXHRcdH0gZWxzZSB7IC8vIGl0XHUyMDE5cyBhbiBvYmplY3Rcblx0XHRcdHJlc3VsdCA9IFtdO1xuXHRcdFx0b3B0aW9ucy53cmFwID0gdHJ1ZTtcblx0XHRcdGluY3JlYXNlSW5kZW50YXRpb24oKTtcblx0XHRcdGZvck93bihhcmd1bWVudCwgKGtleSwgdmFsdWUpID0+IHtcblx0XHRcdFx0aXNFbXB0eSA9IGZhbHNlO1xuXHRcdFx0XHRyZXN1bHQucHVzaChcblx0XHRcdFx0XHQoY29tcGFjdCA/ICcnIDogaW5kZW50KSArXG5cdFx0XHRcdFx0anNlc2Moa2V5LCBvcHRpb25zKSArICc6JyArXG5cdFx0XHRcdFx0KGNvbXBhY3QgPyAnJyA6ICcgJykgK1xuXHRcdFx0XHRcdGpzZXNjKHZhbHVlLCBvcHRpb25zKVxuXHRcdFx0XHQpO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoaXNFbXB0eSkge1xuXHRcdFx0XHRyZXR1cm4gJ3t9Jztcblx0XHRcdH1cblx0XHRcdHJldHVybiAneycgKyBuZXdMaW5lICsgcmVzdWx0LmpvaW4oJywnICsgbmV3TGluZSkgKyBuZXdMaW5lICtcblx0XHRcdFx0KGNvbXBhY3QgPyAnJyA6IG9sZEluZGVudCkgKyAnfSc7XG5cdFx0fVxuXHR9XG5cblx0Y29uc3QgcmVnZXggPSBvcHRpb25zLmVzY2FwZUV2ZXJ5dGhpbmcgPyBlc2NhcGVFdmVyeXRoaW5nUmVnZXggOiBlc2NhcGVOb25Bc2NpaVJlZ2V4O1xuXHRyZXN1bHQgPSBhcmd1bWVudC5yZXBsYWNlKHJlZ2V4LCAoY2hhciwgcGFpciwgbG9uZSwgcXVvdGVDaGFyLCBpbmRleCwgc3RyaW5nKSA9PiB7XG5cdFx0aWYgKHBhaXIpIHtcblx0XHRcdGlmIChvcHRpb25zLm1pbmltYWwpIHJldHVybiBwYWlyO1xuXHRcdFx0Y29uc3QgZmlyc3QgPSBwYWlyLmNoYXJDb2RlQXQoMCk7XG5cdFx0XHRjb25zdCBzZWNvbmQgPSBwYWlyLmNoYXJDb2RlQXQoMSk7XG5cdFx0XHRpZiAob3B0aW9ucy5lczYpIHtcblx0XHRcdFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG5cdFx0XHRcdGNvbnN0IGNvZGVQb2ludCA9IChmaXJzdCAtIDB4RDgwMCkgKiAweDQwMCArIHNlY29uZCAtIDB4REMwMCArIDB4MTAwMDA7XG5cdFx0XHRcdGNvbnN0IGhleCA9IGhleGFkZWNpbWFsKGNvZGVQb2ludCwgbG93ZXJjYXNlSGV4KTtcblx0XHRcdFx0cmV0dXJuICdcXFxcdXsnICsgaGV4ICsgJ30nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZvdXJIZXhFc2NhcGUoaGV4YWRlY2ltYWwoZmlyc3QsIGxvd2VyY2FzZUhleCkpICsgZm91ckhleEVzY2FwZShoZXhhZGVjaW1hbChzZWNvbmQsIGxvd2VyY2FzZUhleCkpO1xuXHRcdH1cblxuXHRcdGlmIChsb25lKSB7XG5cdFx0XHRyZXR1cm4gZm91ckhleEVzY2FwZShoZXhhZGVjaW1hbChsb25lLmNoYXJDb2RlQXQoMCksIGxvd2VyY2FzZUhleCkpO1xuXHRcdH1cblxuXHRcdGlmIChcblx0XHRcdGNoYXIgPT0gJ1xcMCcgJiZcblx0XHRcdCFqc29uICYmXG5cdFx0XHQhcmVnZXhEaWdpdC50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXggKyAxKSlcblx0XHQpIHtcblx0XHRcdHJldHVybiAnXFxcXDAnO1xuXHRcdH1cblxuXHRcdGlmIChxdW90ZUNoYXIpIHtcblx0XHRcdGlmIChxdW90ZUNoYXIgPT0gcXVvdGUgfHwgb3B0aW9ucy5lc2NhcGVFdmVyeXRoaW5nKSB7XG5cdFx0XHRcdHJldHVybiAnXFxcXCcgKyBxdW90ZUNoYXI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVvdGVDaGFyO1xuXHRcdH1cblxuXHRcdGlmIChyZWdleFNpbmdsZUVzY2FwZS50ZXN0KGNoYXIpKSB7XG5cdFx0XHQvLyBubyBuZWVkIGZvciBhIGBoYXNPd25Qcm9wZXJ0eWAgY2hlY2sgaGVyZVxuXHRcdFx0cmV0dXJuIHNpbmdsZUVzY2FwZXNbY2hhcl07XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMubWluaW1hbCAmJiAhcmVnZXhXaGl0ZXNwYWNlLnRlc3QoY2hhcikpIHtcblx0XHRcdHJldHVybiBjaGFyO1xuXHRcdH1cblxuXHRcdGNvbnN0IGhleCA9IGhleGFkZWNpbWFsKGNoYXIuY2hhckNvZGVBdCgwKSwgbG93ZXJjYXNlSGV4KTtcblx0XHRpZiAoanNvbiB8fCBoZXgubGVuZ3RoID4gMikge1xuXHRcdFx0cmV0dXJuIGZvdXJIZXhFc2NhcGUoaGV4KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJ1xcXFx4JyArICgnMDAnICsgaGV4KS5zbGljZSgtMik7XG5cdH0pO1xuXG5cdGlmIChxdW90ZSA9PSAnYCcpIHtcblx0XHRyZXN1bHQgPSByZXN1bHQucmVwbGFjZSgvXFwkXFx7L2csICdcXFxcJHsnKTtcblx0fVxuXHRpZiAob3B0aW9ucy5pc1NjcmlwdENvbnRleHQpIHtcblx0XHQvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZXRhZ29cblx0XHRyZXN1bHQgPSByZXN1bHRcblx0XHRcdC5yZXBsYWNlKC88XFwvKHNjcmlwdHxzdHlsZSkvZ2ksICc8XFxcXC8kMScpXG5cdFx0XHQucmVwbGFjZSgvPCEtLS9nLCBqc29uID8gJ1xcXFx1MDAzQyEtLScgOiAnXFxcXHgzQyEtLScpO1xuXHR9XG5cdGlmIChvcHRpb25zLndyYXApIHtcblx0XHRyZXN1bHQgPSBxdW90ZSArIHJlc3VsdCArIHF1b3RlO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG5qc2VzYy52ZXJzaW9uID0gJzMuMC4yJztcblxubW9kdWxlLmV4cG9ydHMgPSBqc2VzYztcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciBkb21haW47XG5cbi8vIFRoaXMgY29uc3RydWN0b3IgaXMgdXNlZCB0byBzdG9yZSBldmVudCBoYW5kbGVycy4gSW5zdGFudGlhdGluZyB0aGlzIGlzXG4vLyBmYXN0ZXIgdGhhbiBleHBsaWNpdGx5IGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIHRvIGdldCBhIFwiY2xlYW5cIiBlbXB0eVxuLy8gb2JqZWN0ICh0ZXN0ZWQgd2l0aCB2OCB2NC45KS5cbmZ1bmN0aW9uIEV2ZW50SGFuZGxlcnMoKSB7fVxuRXZlbnRIYW5kbGVycy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXI7XG5leHBvcnQge0V2ZW50RW1pdHRlcn07XG5cbi8vIG5vZGVqcyBvZGRpdHlcbi8vIHJlcXVpcmUoJ2V2ZW50cycpID09PSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXJcblxuRXZlbnRFbWl0dGVyLnVzaW5nRG9tYWlucyA9IGZhbHNlO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmRvbWFpbiA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kb21haW4gPSBudWxsO1xuICBpZiAoRXZlbnRFbWl0dGVyLnVzaW5nRG9tYWlucykge1xuICAgIC8vIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSBkb21haW4sIHRoZW4gYXR0YWNoIHRvIGl0LlxuICAgIGlmIChkb21haW4uYWN0aXZlICYmICEodGhpcyBpbnN0YW5jZW9mIGRvbWFpbi5Eb21haW4pKSB7XG4gICAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbi5hY3RpdmU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG4vLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBhcmd1bWVudHMgYW5kIGNhbiBiZSBkZW9wdGltaXplZCBiZWNhdXNlIG9mIHRoYXQuIFRoZXNlIGZ1bmN0aW9ucyBhbHdheXMgaGF2ZVxuLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuZnVuY3Rpb24gZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgc2VsZikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cywgZG9tYWluO1xuICB2YXIgbmVlZERvbWFpbkV4aXQgPSBmYWxzZTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBkb21haW4gPSB0aGlzLmRvbWFpbjtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGRvbWFpbikge1xuICAgICAgaWYgKCFlcilcbiAgICAgICAgZXIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQnKTtcbiAgICAgIGVyLmRvbWFpbkVtaXR0ZXIgPSB0aGlzO1xuICAgICAgZXIuZG9tYWluID0gZG9tYWluO1xuICAgICAgZXIuZG9tYWluVGhyb3duID0gZmFsc2U7XG4gICAgICBkb21haW4uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmICghaGFuZGxlcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGlzRm4gPSB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJztcbiAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgc3dpdGNoIChsZW4pIHtcbiAgICAvLyBmYXN0IGNhc2VzXG4gICAgY2FzZSAxOlxuICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIHNsb3dlclxuICAgIGRlZmF1bHQ6XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgaWYgKG5lZWREb21haW5FeGl0KVxuICAgIGRvbWFpbi5leGl0KCk7XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZykge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgdHlwZSArICcgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgZW1pdFdhcm5pbmcodyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGVtaXRXYXJuaW5nKGUpIHtcbiAgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gJ2Z1bmN0aW9uJyA/IGNvbnNvbGUud2FybihlKSA6IGNvbnNvbGUubG9nKGUpO1xufVxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgZmlyZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0YXJnZXQucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHJldHVybiBnO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICghbGlzdClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCAobGlzdC5saXN0ZW5lciAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGxpc3RbMF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cztcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKCFldmVudHMpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoIWV2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGtleTsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBkbyB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgfSB3aGlsZSAobGlzdGVuZXJzWzBdKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICB2YXIgZXZsaXN0ZW5lcjtcbiAgdmFyIHJldDtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoIWV2ZW50cylcbiAgICByZXQgPSBbXTtcbiAgZWxzZSB7XG4gICAgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAoIWV2bGlzdGVuZXIpXG4gICAgICByZXQgPSBbXTtcbiAgICBlbHNlIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHJldCA9IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdC5vd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpXG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBpKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwgIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuLy8gYmFzZWQgb2ZmIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL25vZGUtcHJvY2Vzcy9ibG9iL21hc3Rlci9icm93c2VyLmpzXG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxudmFyIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG5pZiAodHlwZW9mIGdsb2JhbC5zZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG59XG5pZiAodHlwZW9mIGdsb2JhbC5jbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG59XG5cbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cbmZ1bmN0aW9uIG5leHRUaWNrKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59XG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xudmFyIHRpdGxlID0gJ2Jyb3dzZXInO1xudmFyIHBsYXRmb3JtID0gJ2Jyb3dzZXInO1xudmFyIGJyb3dzZXIgPSB0cnVlO1xudmFyIGVudiA9IHt9O1xudmFyIGFyZ3YgPSBbXTtcbnZhciB2ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG52YXIgdmVyc2lvbnMgPSB7fTtcbnZhciByZWxlYXNlID0ge307XG52YXIgY29uZmlnID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgb24gPSBub29wO1xudmFyIGFkZExpc3RlbmVyID0gbm9vcDtcbnZhciBvbmNlID0gbm9vcDtcbnZhciBvZmYgPSBub29wO1xudmFyIHJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnZhciByZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xudmFyIGVtaXQgPSBub29wO1xuXG5mdW5jdGlvbiBiaW5kaW5nKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbmZ1bmN0aW9uIGN3ZCAoKSB7IHJldHVybiAnLycgfVxuZnVuY3Rpb24gY2hkaXIgKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59ZnVuY3Rpb24gdW1hc2soKSB7IHJldHVybiAwOyB9XG5cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2t1bWF2aXMvYnJvd3Nlci1wcm9jZXNzLWhydGltZS9ibG9iL21hc3Rlci9pbmRleC5qc1xudmFyIHBlcmZvcm1hbmNlID0gZ2xvYmFsLnBlcmZvcm1hbmNlIHx8IHt9O1xudmFyIHBlcmZvcm1hbmNlTm93ID1cbiAgcGVyZm9ybWFuY2Uubm93ICAgICAgICB8fFxuICBwZXJmb3JtYW5jZS5tb3pOb3cgICAgIHx8XG4gIHBlcmZvcm1hbmNlLm1zTm93ICAgICAgfHxcbiAgcGVyZm9ybWFuY2Uub05vdyAgICAgICB8fFxuICBwZXJmb3JtYW5jZS53ZWJraXROb3cgIHx8XG4gIGZ1bmN0aW9uKCl7IHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpIH07XG5cbi8vIGdlbmVyYXRlIHRpbWVzdGFtcCBvciBkZWx0YVxuLy8gc2VlIGh0dHA6Ly9ub2RlanMub3JnL2FwaS9wcm9jZXNzLmh0bWwjcHJvY2Vzc19wcm9jZXNzX2hydGltZVxuZnVuY3Rpb24gaHJ0aW1lKHByZXZpb3VzVGltZXN0YW1wKXtcbiAgdmFyIGNsb2NrdGltZSA9IHBlcmZvcm1hbmNlTm93LmNhbGwocGVyZm9ybWFuY2UpKjFlLTM7XG4gIHZhciBzZWNvbmRzID0gTWF0aC5mbG9vcihjbG9ja3RpbWUpO1xuICB2YXIgbmFub3NlY29uZHMgPSBNYXRoLmZsb29yKChjbG9ja3RpbWUlMSkqMWU5KTtcbiAgaWYgKHByZXZpb3VzVGltZXN0YW1wKSB7XG4gICAgc2Vjb25kcyA9IHNlY29uZHMgLSBwcmV2aW91c1RpbWVzdGFtcFswXTtcbiAgICBuYW5vc2Vjb25kcyA9IG5hbm9zZWNvbmRzIC0gcHJldmlvdXNUaW1lc3RhbXBbMV07XG4gICAgaWYgKG5hbm9zZWNvbmRzPDApIHtcbiAgICAgIHNlY29uZHMtLTtcbiAgICAgIG5hbm9zZWNvbmRzICs9IDFlOTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtzZWNvbmRzLG5hbm9zZWNvbmRzXVxufVxuXG52YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbmZ1bmN0aW9uIHVwdGltZSgpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgdmFyIGRpZiA9IGN1cnJlbnRUaW1lIC0gc3RhcnRUaW1lO1xuICByZXR1cm4gZGlmIC8gMTAwMDtcbn1cblxudmFyIGJyb3dzZXIkMSA9IHtcbiAgbmV4dFRpY2s6IG5leHRUaWNrLFxuICB0aXRsZTogdGl0bGUsXG4gIGJyb3dzZXI6IGJyb3dzZXIsXG4gIGVudjogZW52LFxuICBhcmd2OiBhcmd2LFxuICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICB2ZXJzaW9uczogdmVyc2lvbnMsXG4gIG9uOiBvbixcbiAgYWRkTGlzdGVuZXI6IGFkZExpc3RlbmVyLFxuICBvbmNlOiBvbmNlLFxuICBvZmY6IG9mZixcbiAgcmVtb3ZlTGlzdGVuZXI6IHJlbW92ZUxpc3RlbmVyLFxuICByZW1vdmVBbGxMaXN0ZW5lcnM6IHJlbW92ZUFsbExpc3RlbmVycyxcbiAgZW1pdDogZW1pdCxcbiAgYmluZGluZzogYmluZGluZyxcbiAgY3dkOiBjd2QsXG4gIGNoZGlyOiBjaGRpcixcbiAgdW1hc2s6IHVtYXNrLFxuICBocnRpbWU6IGhydGltZSxcbiAgcGxhdGZvcm06IHBsYXRmb3JtLFxuICByZWxlYXNlOiByZWxlYXNlLFxuICBjb25maWc6IGNvbmZpZyxcbiAgdXB0aW1lOiB1cHRpbWVcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGJyb3dzZXIkMTtcbmV4cG9ydCB7IGFkZExpc3RlbmVyLCBhcmd2LCBiaW5kaW5nLCBicm93c2VyLCBjaGRpciwgY29uZmlnLCBjd2QsIGVtaXQsIGVudiwgaHJ0aW1lLCBuZXh0VGljaywgb2ZmLCBvbiwgb25jZSwgcGxhdGZvcm0sIHJlbGVhc2UsIHJlbW92ZUFsbExpc3RlbmVycywgcmVtb3ZlTGlzdGVuZXIsIHRpdGxlLCB1bWFzaywgdXB0aW1lLCB2ZXJzaW9uLCB2ZXJzaW9ucyB9O1xuIiwgIlxudmFyIGluaGVyaXRzO1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKXtcbiAgaW5oZXJpdHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgaW5oZXJpdHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgaW5oZXJpdHM7XG4iLCAiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5pbXBvcnQgcHJvY2VzcyBmcm9tICdwcm9jZXNzJztcbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdChmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGUoZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydCBmdW5jdGlvbiBkZWJ1Z2xvZyhzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSAwO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5leHBvcnQgZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIF9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCdWZmZXIobWF5YmVCdWYpIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihtYXliZUJ1Zik7XG59XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydCBmdW5jdGlvbiBsb2coKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGZvcm1hdC5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbn1cblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuaW1wb3J0IGluaGVyaXRzIGZyb20gJy4vaW5oZXJpdHMnO1xuZXhwb3J0IHtpbmhlcml0c31cblxuZXhwb3J0IGZ1bmN0aW9uIF9leHRlbmQob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgaW5oZXJpdHM6IGluaGVyaXRzLFxuICBfZXh0ZW5kOiBfZXh0ZW5kLFxuICBsb2c6IGxvZyxcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc1ByaW1pdGl2ZTogaXNQcmltaXRpdmUsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzRXJyb3I6IGlzRXJyb3IsXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzUmVnRXhwOiBpc1JlZ0V4cCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc1N5bWJvbDogaXNTeW1ib2wsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc051bGxPclVuZGVmaW5lZDogaXNOdWxsT3JVbmRlZmluZWQsXG4gIGlzTnVsbDogaXNOdWxsLFxuICBpc0Jvb2xlYW46IGlzQm9vbGVhbixcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaW5zcGVjdDogaW5zcGVjdCxcbiAgZGVwcmVjYXRlOiBkZXByZWNhdGUsXG4gIGZvcm1hdDogZm9ybWF0LFxuICBkZWJ1Z2xvZzogZGVidWdsb2dcbn1cbiIsICJ2YXIgbG9va3VwID0gW107XG52YXIgcmV2TG9va3VwID0gW107XG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5O1xudmFyIGluaXRlZCA9IGZhbHNlO1xuZnVuY3Rpb24gaW5pdCAoKSB7XG4gIGluaXRlZCA9IHRydWU7XG4gIHZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGxvb2t1cFtpXSA9IGNvZGVbaV07XG4gICAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpO1xuICB9XG5cbiAgcmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyO1xuICByZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjM7XG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgaWYgKCFpbml0ZWQpIHtcbiAgICBpbml0KCk7XG4gIH1cbiAgdmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnI7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoO1xuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICBwbGFjZUhvbGRlcnMgPSBiNjRbbGVuIC0gMl0gPT09ICc9JyA/IDIgOiBiNjRbbGVuIC0gMV0gPT09ICc9JyA/IDEgOiAwO1xuXG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICBhcnIgPSBuZXcgQXJyKGxlbiAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKTtcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlbjtcblxuICB2YXIgTCA9IDA7XG5cbiAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXTtcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRjtcbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gOCkgJiAweEZGO1xuICAgIGFycltMKytdID0gdG1wICYgMHhGRjtcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KTtcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkY7XG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpO1xuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkY7XG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXA7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pO1xuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIGlmICghaW5pdGVkKSB7XG4gICAgaW5pdCgpO1xuICB9XG4gIHZhciB0bXA7XG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGg7XG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMzsgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnO1xuICB2YXIgcGFydHMgPSBbXTtcbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODM7IC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpO1xuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdO1xuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdO1xuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdO1xuICAgIG91dHB1dCArPSAnPT0nO1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pO1xuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXTtcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXTtcbiAgICBvdXRwdXQgKz0gJz0nO1xuICB9XG5cbiAgcGFydHMucHVzaChvdXRwdXQpO1xuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiByZWFkIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIG5CaXRzID0gLTc7XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDA7XG4gIHZhciBkID0gaXNMRSA/IC0xIDogMTtcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV07XG5cbiAgaSArPSBkO1xuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBzID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gZUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pO1xuICAgIGUgPSBlIC0gZUJpYXM7XG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZnVuY3Rpb24gd3JpdGUgKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjO1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMTtcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKTtcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKTtcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xO1xuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtO1xuICBlTGVuICs9IG1MZW47XG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBJTlNQRUNUX01BWF9CWVRFUyA9IDUwO1xuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHRydWU7XG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbnZhciBfa01heExlbmd0aCA9IGtNYXhMZW5ndGgoKTtcblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpO1xuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MjsgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIHJldHVybiBhcnJcbn07XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufTtcblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGU7XG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5O1xufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn07XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSk7XG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59O1xuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufTtcblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4JztcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwO1xuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aCk7XG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZyk7XG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpO1xuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMDtcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1O1xuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoOyAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpO1xuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCk7XG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheTtcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKGludGVybmFsSXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMDtcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbik7XG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKTtcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMDtcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5CdWZmZXIuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbmZ1bmN0aW9uIGludGVybmFsSXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihhKSB8fCAhaW50ZXJuYWxJc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59O1xuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaTtcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKTtcbiAgdmFyIHBvcyA9IDA7XG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV07XG4gICAgaWYgKCFpbnRlcm5hbElzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKTtcbiAgICBwb3MgKz0gYnVmLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59O1xuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChpbnRlcm5hbElzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZztcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoO1xuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZTtcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlO1xuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwO1xuICBzdGFydCA+Pj49IDA7XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlO1xuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXTtcbiAgYltuXSA9IGJbbV07XG4gIGJbbV0gPSBpO1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMyk7XG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpO1xuICB9XG4gIHJldHVybiB0aGlzXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aDtcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KTtcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNik7XG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpO1xuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KTtcbiAgfVxuICByZXR1cm4gdGhpc1xufTtcblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMDtcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgbWF4ID0gSU5TUEVDVF9NQVhfQllURVM7XG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnO1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIWludGVybmFsSXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDA7XG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMDtcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMDtcbiAgZW5kID4+Pj0gMDtcbiAgdGhpc1N0YXJ0ID4+Pj0gMDtcbiAgdGhpc0VuZCA+Pj49IDA7XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnQ7XG4gIHZhciB5ID0gZW5kIC0gc3RhcnQ7XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KTtcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZCk7XG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXTtcbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59O1xuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXQ7XG4gICAgYnl0ZU9mZnNldCA9IDA7XG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZjtcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDA7XG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0OyAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXQ7XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMTtcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwO1xuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKGludGVybmFsSXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGOyAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxO1xuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGg7XG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyO1xuICAgICAgYXJyTGVuZ3RoIC89IDI7XG4gICAgICB2YWxMZW5ndGggLz0gMjtcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGk7XG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xO1xuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpO1xuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXg7XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGg7XG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWU7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn07XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMDtcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nO1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpO1xuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZztcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyO1xuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KTtcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWQ7XG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgb2Zmc2V0ID0gMDtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldDtcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBvZmZzZXQgPSAwO1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwO1xuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aDtcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmc7XG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCc7XG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2U7XG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBmcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKTtcbiAgdmFyIHJlcyA9IFtdO1xuXG4gIHZhciBpID0gc3RhcnQ7XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXTtcbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbDtcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDE7XG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50O1xuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXTtcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdO1xuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV07XG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXTtcbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXTtcbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpO1xuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRDtcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkY7XG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KTtcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2U7XG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDA7XG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGg7XG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJyc7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZCk7XG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpO1xuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7XG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlbjtcblxuICB2YXIgb3V0ID0gJyc7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSk7XG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG4gIHN0YXJ0ID0gfn5zdGFydDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuO1xuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMDtcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuO1xuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuO1xuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwO1xuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlbjtcbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cbiAgdmFyIG5ld0J1ZjtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKTtcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydDtcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn07XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XTtcbiAgdmFyIG11bCA9IDE7XG4gIHZhciBpID0gMDtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bDtcbiAgfVxuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdO1xuICB2YXIgbXVsID0gMTtcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bDtcbiAgfVxuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpO1xuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKTtcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsO1xuICB9XG4gIG11bCAqPSAweDgwO1xuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpO1xuXG4gIHJldHVybiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aCk7XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXTtcbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bDtcbiAgfVxuICBtdWwgKj0gMHg4MDtcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKTtcblxuICByZXR1cm4gdmFsXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aCk7XG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aCk7XG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KTtcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpO1xuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOCk7XG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKTtcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpO1xuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aCk7XG4gIHJldHVybiByZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKTtcbiAgcmV0dXJuIHJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59O1xuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghaW50ZXJuYWxJc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMTtcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMCk7XG4gIH1cblxuICB2YXIgbXVsID0gMTtcbiAgdmFyIGkgPSAwO1xuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDE7XG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApO1xuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMTtcbiAgdmFyIG11bCA9IDE7XG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMCk7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICByZXR1cm4gb2Zmc2V0ICsgMVxufTtcblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogODtcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZik7XG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDE7XG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmO1xuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKTtcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpO1xuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpO1xuICB9XG5cbiAgdmFyIGkgPSAwO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHN1YiA9IDA7XG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRjtcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMTtcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRjtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSk7XG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdCk7XG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxO1xuICB2YXIgbXVsID0gMTtcbiAgdmFyIHN1YiA9IDA7XG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkY7XG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxO1xuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApO1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpO1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDE7XG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICByZXR1cm4gb2Zmc2V0ICsgMVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlO1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwO1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpO1xuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSk7XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZTtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMDtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KTtcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59O1xuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWU7XG4gIG9mZnNldCA9IG9mZnNldCB8IDA7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKTtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxO1xuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KTtcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNik7XG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOCk7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufTtcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCk7XG4gIH1cbiAgd3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KTtcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufTtcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn07XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgpO1xuICB9XG4gIHdyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOCk7XG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn07XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59O1xuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMDtcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aDtcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aDtcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwO1xuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnQ7XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoO1xuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydDtcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydDtcbiAgdmFyIGk7XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBsZW5cbn07XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kO1xuICAgICAgZW5kID0gdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApO1xuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTU7XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDA7XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDA7XG5cbiAgaWYgKCF2YWwpIHZhbCA9IDA7XG5cbiAgdmFyIGk7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IGludGVybmFsSXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKTtcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufTtcblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2c7XG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJyk7XG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9JztcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eTtcbiAgdmFyIGNvZGVQb2ludDtcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbDtcbiAgdmFyIGJ5dGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpO1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKTtcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludDtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDA7XG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRCk7XG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGw7XG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG87XG4gIHZhciBieXRlQXJyYXkgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoaSA9IGMgPj4gODtcbiAgICBsbyA9IGMgJSAyNTY7XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pO1xuICAgIGJ5dGVBcnJheS5wdXNoKGhpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIHRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXTtcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG5cbi8vIHRoZSBmb2xsb3dpbmcgaXMgZnJvbSBpcy1idWZmZXIsIGFsc28gYnkgRmVyb3NzIEFib3VraGFkaWplaCBhbmQgd2l0aCBzYW1lIGxpc2VuY2Vcbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbmZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKCEhb2JqLl9pc0J1ZmZlciB8fCBpc0Zhc3RCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSlcbn1cblxuZnVuY3Rpb24gaXNGYXN0QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNGYXN0QnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cblxuZXhwb3J0IHsgQnVmZmVyLCBJTlNQRUNUX01BWF9CWVRFUywgU2xvd0J1ZmZlciwgaXNCdWZmZXIsIF9rTWF4TGVuZ3RoIGFzIGtNYXhMZW5ndGggfTtcbiIsICJpbXBvcnQge0J1ZmZlcn0gZnJvbSAnYnVmZmVyJztcblxuZXhwb3J0IGRlZmF1bHQgQnVmZmVyTGlzdDtcblxuZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5sZW5ndGggPSAwO1xufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgdGhpcy50YWlsID0gZW50cnk7XG4gICsrdGhpcy5sZW5ndGg7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgdGhpcy5oZWFkID0gZW50cnk7XG4gICsrdGhpcy5sZW5ndGg7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm47XG4gIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gIC0tdGhpcy5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIChzKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHJldCArPSBzICsgcC5kYXRhO1xuICB9cmV0dXJuIHJldDtcbn07XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChuKSB7XG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gIHZhciBwID0gdGhpcy5oZWFkO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlIChwKSB7XG4gICAgcC5kYXRhLmNvcHkocmV0LCBpKTtcbiAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuICByZXR1cm4gcmV0O1xufTtcbiIsICIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuaW1wb3J0IHtCdWZmZXJ9IGZyb20gJ2J1ZmZlcic7XG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxuZXhwb3J0IGZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IChlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvWy1fXS8sICcnKTtcbiAgYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIC8vIENFU1UtOCByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMy1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgLy8gVVRGLTE2IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAyLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAyO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgLy8gQmFzZS02NCBzdG9yZXMgMyBieXRlcyBpbiA0IGNoYXJzLCBhbmQgcGFkcyB0aGUgcmVtYWluZGVyLlxuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMztcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gcGFzc1Rocm91Z2hXcml0ZTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEVub3VnaCBzcGFjZSB0byBzdG9yZSBhbGwgYnl0ZXMgb2YgYSBzaW5nbGUgY2hhcmFjdGVyLiBVVEYtOCBuZWVkcyA0XG4gIC8vIGJ5dGVzLCBidXQgQ0VTVS04IG1heSByZXF1aXJlIHVwIHRvIDYgKDMgYnl0ZXMgcGVyIHN1cnJvZ2F0ZSkuXG4gIHRoaXMuY2hhckJ1ZmZlciA9IG5ldyBCdWZmZXIoNik7XG4gIC8vIE51bWJlciBvZiBieXRlcyByZWNlaXZlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSAwO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgZXhwZWN0ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhckxlbmd0aCA9IDA7XG59O1xuXG5cbi8vIHdyaXRlIGRlY29kZXMgdGhlIGdpdmVuIGJ1ZmZlciBhbmQgcmV0dXJucyBpdCBhcyBKUyBzdHJpbmcgdGhhdCBpc1xuLy8gZ3VhcmFudGVlZCB0byBub3QgY29udGFpbiBhbnkgcGFydGlhbCBtdWx0aS1ieXRlIGNoYXJhY3RlcnMuIEFueSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIgZm91bmQgYXQgdGhlIGVuZCBvZiB0aGUgYnVmZmVyIGlzIGJ1ZmZlcmVkIHVwLCBhbmQgd2lsbCBiZVxuLy8gcmV0dXJuZWQgd2hlbiBjYWxsaW5nIHdyaXRlIGFnYWluIHdpdGggdGhlIHJlbWFpbmluZyBieXRlcy5cbi8vXG4vLyBOb3RlOiBDb252ZXJ0aW5nIGEgQnVmZmVyIGNvbnRhaW5pbmcgYW4gb3JwaGFuIHN1cnJvZ2F0ZSB0byBhIFN0cmluZ1xuLy8gY3VycmVudGx5IHdvcmtzLCBidXQgY29udmVydGluZyBhIFN0cmluZyB0byBhIEJ1ZmZlciAodmlhIGBuZXcgQnVmZmVyYCwgb3Jcbi8vIEJ1ZmZlciN3cml0ZSkgd2lsbCByZXBsYWNlIGluY29tcGxldGUgc3Vycm9nYXRlcyB3aXRoIHRoZSB1bmljb2RlXG4vLyByZXBsYWNlbWVudCBjaGFyYWN0ZXIuIFNlZSBodHRwczovL2NvZGVyZXZpZXcuY2hyb21pdW0ub3JnLzEyMTE3MzAwOS8gLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIGNoYXJTdHIgPSAnJztcbiAgLy8gaWYgb3VyIGxhc3Qgd3JpdGUgZW5kZWQgd2l0aCBhbiBpbmNvbXBsZXRlIG11bHRpYnl0ZSBjaGFyYWN0ZXJcbiAgd2hpbGUgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGRldGVybWluZSBob3cgbWFueSByZW1haW5pbmcgYnl0ZXMgdGhpcyBidWZmZXIgaGFzIHRvIG9mZmVyIGZvciB0aGlzIGNoYXJcbiAgICB2YXIgYXZhaWxhYmxlID0gKGJ1ZmZlci5sZW5ndGggPj0gdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQpID9cbiAgICAgICAgdGhpcy5jaGFyTGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQgOlxuICAgICAgICBidWZmZXIubGVuZ3RoO1xuXG4gICAgLy8gYWRkIHRoZSBuZXcgYnl0ZXMgdG8gdGhlIGNoYXIgYnVmZmVyXG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCB0aGlzLmNoYXJSZWNlaXZlZCwgMCwgYXZhaWxhYmxlKTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBhdmFpbGFibGU7XG5cbiAgICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQgPCB0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAgIC8vIHN0aWxsIG5vdCBlbm91Z2ggY2hhcnMgaW4gdGhpcyBidWZmZXI/IHdhaXQgZm9yIG1vcmUgLi4uXG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGJ5dGVzIGJlbG9uZ2luZyB0byB0aGUgY3VycmVudCBjaGFyYWN0ZXIgZnJvbSB0aGUgYnVmZmVyXG4gICAgYnVmZmVyID0gYnVmZmVyLnNsaWNlKGF2YWlsYWJsZSwgYnVmZmVyLmxlbmd0aCk7XG5cbiAgICAvLyBnZXQgdGhlIGNoYXJhY3RlciB0aGF0IHdhcyBzcGxpdFxuICAgIGNoYXJTdHIgPSB0aGlzLmNoYXJCdWZmZXIuc2xpY2UoMCwgdGhpcy5jaGFyTGVuZ3RoKS50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcblxuICAgIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoY2hhclN0ci5sZW5ndGggLSAxKTtcbiAgICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoICs9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICAgIGNoYXJTdHIgPSAnJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0aGlzLmNoYXJSZWNlaXZlZCA9IHRoaXMuY2hhckxlbmd0aCA9IDA7XG5cbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gbW9yZSBieXRlcyBpbiB0aGlzIGJ1ZmZlciwganVzdCBlbWl0IG91ciBjaGFyXG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBjaGFyU3RyO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuXG4gIC8vIGRldGVybWluZSBhbmQgc2V0IGNoYXJMZW5ndGggLyBjaGFyUmVjZWl2ZWRcbiAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpO1xuXG4gIHZhciBlbmQgPSBidWZmZXIubGVuZ3RoO1xuICBpZiAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gYnVmZmVyIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlciBieXRlcyB3ZSBnb3RcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIGJ1ZmZlci5sZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCwgZW5kKTtcbiAgICBlbmQgLT0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gIH1cblxuICBjaGFyU3RyICs9IGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCBlbmQpO1xuXG4gIHZhciBlbmQgPSBjaGFyU3RyLmxlbmd0aCAtIDE7XG4gIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChlbmQpO1xuICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgdmFyIHNpemUgPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgdGhpcy5jaGFyTGVuZ3RoICs9IHNpemU7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJCdWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHNpemUsIDAsIHNpemUpO1xuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgMCwgc2l6ZSk7XG4gICAgcmV0dXJuIGNoYXJTdHIuc3Vic3RyaW5nKDAsIGVuZCk7XG4gIH1cblxuICAvLyBvciBqdXN0IGVtaXQgdGhlIGNoYXJTdHJcbiAgcmV0dXJuIGNoYXJTdHI7XG59O1xuXG4vLyBkZXRlY3RJbmNvbXBsZXRlQ2hhciBkZXRlcm1pbmVzIGlmIHRoZXJlIGlzIGFuIGluY29tcGxldGUgVVRGLTggY2hhcmFjdGVyIGF0XG4vLyB0aGUgZW5kIG9mIHRoZSBnaXZlbiBidWZmZXIuIElmIHNvLCBpdCBzZXRzIHRoaXMuY2hhckxlbmd0aCB0byB0aGUgYnl0ZVxuLy8gbGVuZ3RoIHRoYXQgY2hhcmFjdGVyLCBhbmQgc2V0cyB0aGlzLmNoYXJSZWNlaXZlZCB0byB0aGUgbnVtYmVyIG9mIGJ5dGVzXG4vLyB0aGF0IGFyZSBhdmFpbGFibGUgZm9yIHRoaXMgY2hhcmFjdGVyLlxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IGJ5dGVzIHdlIGhhdmUgdG8gY2hlY2sgYXQgdGhlIGVuZCBvZiB0aGlzIGJ1ZmZlclxuICB2YXIgaSA9IChidWZmZXIubGVuZ3RoID49IDMpID8gMyA6IGJ1ZmZlci5sZW5ndGg7XG5cbiAgLy8gRmlndXJlIG91dCBpZiBvbmUgb2YgdGhlIGxhc3QgaSBieXRlcyBvZiBvdXIgYnVmZmVyIGFubm91bmNlcyBhblxuICAvLyBpbmNvbXBsZXRlIGNoYXIuXG4gIGZvciAoOyBpID4gMDsgaS0tKSB7XG4gICAgdmFyIGMgPSBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIGldO1xuXG4gICAgLy8gU2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVVRGLTgjRGVzY3JpcHRpb25cblxuICAgIC8vIDExMFhYWFhYXG4gICAgaWYgKGkgPT0gMSAmJiBjID4+IDUgPT0gMHgwNikge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMjtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTBYWFhYXG4gICAgaWYgKGkgPD0gMiAmJiBjID4+IDQgPT0gMHgwRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gMztcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIDExMTEwWFhYXG4gICAgaWYgKGkgPD0gMyAmJiBjID4+IDMgPT0gMHgxRSkge1xuICAgICAgdGhpcy5jaGFyTGVuZ3RoID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGk7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBpZiAoYnVmZmVyICYmIGJ1ZmZlci5sZW5ndGgpXG4gICAgcmVzID0gdGhpcy53cml0ZShidWZmZXIpO1xuXG4gIGlmICh0aGlzLmNoYXJSZWNlaXZlZCkge1xuICAgIHZhciBjciA9IHRoaXMuY2hhclJlY2VpdmVkO1xuICAgIHZhciBidWYgPSB0aGlzLmNoYXJCdWZmZXI7XG4gICAgdmFyIGVuYyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgcmVzICs9IGJ1Zi5zbGljZSgwLCBjcikudG9TdHJpbmcoZW5jKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBwYXNzVGhyb3VnaFdyaXRlKGJ1ZmZlcikge1xuICByZXR1cm4gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAyO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDIgOiAwO1xufVxuXG5mdW5jdGlvbiBiYXNlNjREZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMztcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAzIDogMDtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge2luaGVyaXRzLCBkZWJ1Z2xvZ30gZnJvbSAndXRpbCc7XG5pbXBvcnQgQnVmZmVyTGlzdCBmcm9tICcuL2J1ZmZlci1saXN0JztcbmltcG9ydCB7U3RyaW5nRGVjb2Rlcn0gZnJvbSAnc3RyaW5nX2RlY29kZXInO1xuaW1wb3J0IHtEdXBsZXh9IGZyb20gJy4vZHVwbGV4JztcbmltcG9ydCB7bmV4dFRpY2t9IGZyb20gJ3Byb2Nlc3MnO1xuXG52YXIgZGVidWcgPSBkZWJ1Z2xvZygnc3RyZWFtJyk7XG5pbmhlcml0cyhSZWFkYWJsZSwgRXZlbnRFbWl0dGVyKTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gICAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICAgIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKVxuICAgICAgZW1pdHRlci5vbihldmVudCwgZm4pO1xuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpXG4gICAgICBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO1xuICAgIGVsc2VcbiAgICAgIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xuICB9XG59XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50IChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+IH50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gd2hlbiBwaXBpbmcsIHdlIG9ubHkgY2FyZSBhYm91dCAncmVhZGFibGUnIGV2ZW50cyB0aGF0IGhhcHBlblxuICAvLyBhZnRlciByZWFkKClpbmcgYWxsIHRoZSBieXRlcyBhbmQgbm90IGdldHRpbmcgYW55IHB1c2hiYWNrLlxuICB0aGlzLnJhbk91dCA9IGZhbHNlO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFJlYWRhYmxlO1xuZXhwb3J0IGZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssICcnLCB0cnVlKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCkge1xuICB2YXIgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2UgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgaWYgKHN0YXRlLmVuZGVkICYmICFhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgZSA9IG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kRW1pdHRlZCAmJiBhZGRUb0Zyb250KSB7XG4gICAgICB2YXIgX2UgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBfZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBza2lwQWRkO1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgIHNraXBBZGQgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBjaHVuay5sZW5ndGggPT09IDA7XG4gICAgICB9XG5cbiAgICAgIGlmICghYWRkVG9Gcm9udCkgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAvLyBEb24ndCBhZGQgdG8gdGhlIGJ1ZmZlciBpZiB3ZSd2ZSBkZWNvZGVkIHRvIGFuIGVtcHR5IHN0cmluZyBjaHVuayBhbmRcbiAgICAgIC8vIHdlJ3JlIG5vdCBpbiBvYmplY3QgbW9kZVxuICAgICAgaWYgKCFza2lwQWRkKSB7XG4gICAgICAgIC8vIGlmIHdlIHdhbnQgdGhlIGRhdGEgbm93LCBqdXN0IGVtaXQgaXQuXG4gICAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICAgIHN0cmVhbS5yZWFkKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyID0gbnVsbDtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBuZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgbmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKTtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogY2xlYW51cDtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIG5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSkge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIHNyYy5saXN0ZW5lcnMoJ2RhdGEnKS5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbjsgX2krKykge1xuICAgICAgZGVzdHNbX2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGksIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgbmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIG5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24gKGV2KSB7XG4gICAgc3RyZWFtLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICB9KTtcblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICBzZWxmLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gc2VsZjtcbn07XG5cbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblJlYWRhYmxlLl9mcm9tTGlzdCA9IGZyb21MaXN0O1xuXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXG4vLyBMZW5ndGggaXMgdGhlIGNvbWJpbmVkIGxlbmd0aHMgb2YgYWxsIHRoZSBidWZmZXJzIGluIHRoZSBsaXN0LlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuXG4gIHZhciByZXQ7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgbGlzdFxuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSByZXQgPSBzdGF0ZS5idWZmZXIuam9pbignJyk7ZWxzZSBpZiAoc3RhdGUuYnVmZmVyLmxlbmd0aCA9PT0gMSkgcmV0ID0gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xuICB2YXIgcmV0O1xuICBpZiAobiA8IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXG4gICAgcmV0ID0gbGlzdC5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgbGlzdC5oZWFkLmRhdGEgPSBsaXN0LmhlYWQuZGF0YS5zbGljZShuKTtcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBmaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICByZXQgPSBsaXN0LnNoaWZ0KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyXG4gICAgcmV0ID0gaGFzU3RyaW5ncyA/IGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIDogY29weUZyb21CdWZmZXIobiwgbGlzdCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YVxuLy8gY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSB7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHZhciByZXQgPSBwLmRhdGE7XG4gIG4gLT0gcmV0Lmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XG4gICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuLy8gQ29waWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGEgY2h1bmtzLlxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KSB7XG4gIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobik7XG4gIHZhciBwID0gbGlzdC5oZWFkO1xuICB2YXIgYyA9IDE7XG4gIHAuZGF0YS5jb3B5KHJldCk7XG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcbiAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XG4gICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcImVuZFJlYWRhYmxlKClcIiBjYWxsZWQgb24gbm9uLWVtcHR5IHN0cmVhbScpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBuZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cbiIsICIvLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cblxuaW1wb3J0IHtpbmhlcml0cywgZGVwcmVjYXRlfSBmcm9tICd1dGlsJztcbmltcG9ydCB7QnVmZmVyfSBmcm9tICdidWZmZXInO1xuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5pbXBvcnQge0V2ZW50RW1pdHRlcn0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7RHVwbGV4fSBmcm9tICcuL2R1cGxleCc7XG5pbXBvcnQge25leHRUaWNrfSBmcm9tICdwcm9jZXNzJztcbmluaGVyaXRzKFdyaXRhYmxlLCBFdmVudEVtaXR0ZXIpO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYnVmZmVyJywge1xuICAgIGdldDogZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJylcbiAgfSk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IH4gfnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFdyaXRhYmxlO1xuZXhwb3J0IGZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBuZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBJZiB3ZSBnZXQgc29tZXRoaW5nIHRoYXQgaXMgbm90IGEgYnVmZmVyLCBzdHJpbmcsIG51bGwsIG9yIHVuZGVmaW5lZCxcbi8vIGFuZCB3ZSdyZSBub3QgaW4gb2JqZWN0TW9kZSwgdGhlbiB0aGF0J3MgYW4gZXJyb3IuXG4vLyBPdGhlcndpc2Ugc3RyZWFtIGNodW5rcyBhcmUgYWxsIGNvbnNpZGVyZWQgdG8gYmUgb2YgbGVuZ3RoPTEsIGFuZCB0aGVcbi8vIHdhdGVybWFya3MgZGV0ZXJtaW5lIGhvdyBtYW55IG9iamVjdHMgdG8ga2VlcCBpbiB0aGUgYnVmZmVyLCByYXRoZXIgdGhhblxuLy8gaG93IG1hbnkgYnl0ZXMgb3IgY2hhcmFjdGVycy5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuICAvLyBBbHdheXMgdGhyb3cgZXJyb3IgaWYgYSBudWxsIGlzIHdyaXR0ZW5cbiAgLy8gaWYgd2UgYXJlIG5vdCBpbiBvYmplY3QgbW9kZSB0aGVuIHRocm93XG4gIC8vIGlmIGl0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBvciB1bmRlZmluZWQuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgbmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXG4vLyBpbiB0aGUgcXVldWUsIGFuZCB3YWl0IG91ciB0dXJuLiAgT3RoZXJ3aXNlLCBjYWxsIF93cml0ZVxuLy8gSWYgd2UgcmV0dXJuIGZhbHNlLCB0aGVuIHdlIG5lZWQgYSBkcmFpbiBldmVudCwgc28gc2V0IHRoYXQgZmxhZy5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbmV3IFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSBuZXh0VGljayhjYiwgZXIpO2Vsc2UgY2IoZXIpO1xuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICAgIG5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5uZWVkRHJhaW4pIHtcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcbiAgfVxufVxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuXG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCkge1xuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgbmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKGVycikge1xuICAgIHZhciBlbnRyeSA9IF90aGlzLmVudHJ5O1xuICAgIF90aGlzLmVudHJ5ID0gbnVsbDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgICBjYihlcnIpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgIH1cbiAgICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IF90aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBfdGhpcztcbiAgICB9XG4gIH07XG59XG4iLCAiXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICd1dGlsJztcbmltcG9ydCB7bmV4dFRpY2t9IGZyb20gJ3Byb2Nlc3MnO1xuaW1wb3J0IHtSZWFkYWJsZX0gZnJvbSAnLi9yZWFkYWJsZSc7XG5pbXBvcnQge1dyaXRhYmxlfSBmcm9tICcuL3dyaXRhYmxlJztcblxuXG5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBPYmplY3Qua2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XG59XG5leHBvcnQgZGVmYXVsdCBEdXBsZXg7XG5leHBvcnQgZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgbmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuIiwgIi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuXG5pbXBvcnQge0R1cGxleH0gZnJvbSAnLi9kdXBsZXgnO1xuXG5cbmltcG9ydCB7aW5oZXJpdHN9IGZyb20gJ3V0aWwnO1xuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBUcmFuc2Zvcm07XG5leHBvcnQgZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlcikge1xuICAgICAgZG9uZShzdHJlYW0sIGVyKTtcbiAgICB9KTtlbHNlIGRvbmUoc3RyZWFtKTtcbiAgfSk7XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59XG4iLCAiXG5pbXBvcnQge1RyYW5zZm9ybX0gZnJvbSAnLi90cmFuc2Zvcm0nO1xuXG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICd1dGlsJztcbmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuZXhwb3J0IGRlZmF1bHQgUGFzc1Rocm91Z2g7XG5leHBvcnQgZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07XG4iLCAiaW1wb3J0IEVFIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge2luaGVyaXRzfSBmcm9tICd1dGlsJztcblxuaW1wb3J0IHtEdXBsZXh9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyc7XG5pbXBvcnQge1JlYWRhYmxlfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyc7XG5pbXBvcnQge1dyaXRhYmxlfSBmcm9tICcuL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyc7XG5pbXBvcnQge1RyYW5zZm9ybX0gZnJvbSAnLi9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJztcbmltcG9ydCB7UGFzc1Rocm91Z2h9IGZyb20gJy4vcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJztcbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gUmVhZGFibGU7XG5TdHJlYW0uV3JpdGFibGUgPSBXcml0YWJsZTtcblN0cmVhbS5EdXBsZXggPSBEdXBsZXg7XG5TdHJlYW0uVHJhbnNmb3JtID0gVHJhbnNmb3JtO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gUGFzc1Rocm91Z2g7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5leHBvcnQgZGVmYXVsdCBTdHJlYW07XG5leHBvcnQge1JlYWRhYmxlLFdyaXRhYmxlLER1cGxleCxUcmFuc2Zvcm0sUGFzc1Rocm91Z2gsU3RyZWFtfVxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwgIlxuY29uc3QgcG9seWZpbGwgPSByZXF1aXJlKCdzdHJlYW0nKVxuXG5pZiAocG9seWZpbGwgJiYgcG9seWZpbGwuZGVmYXVsdCkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcG9seWZpbGwuZGVmYXVsdFxuICAgIGZvciAobGV0IGsgaW4gcG9seWZpbGwpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHNba10gPSBwb2x5ZmlsbFtrXVxuICAgIH1cbn0gZWxzZSBpZiAocG9seWZpbGwpICB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwb2x5ZmlsbFxufVxuXG5cbiIsICIvKiogQGxpY2Vuc2UgUmVhY3QgdjE3LjAuMlxuICogcmVhY3QtZG9tLXNlcnZlci5ub2RlLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vLyBUT0RPOiB0aGlzIGlzIHNwZWNpYWwgYmVjYXVzZSBpdCBnZXRzIGltcG9ydGVkIGR1cmluZyBidWlsZC5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTcuMC4yJztcblxuLy8gRG8gbm90IHJlcXVpcmUgdGhpcyBtb2R1bGUgZGlyZWN0bHkhIFVzZSBub3JtYWwgYGludmFyaWFudGAgY2FsbHMgd2l0aFxuLy8gdGVtcGxhdGUgbGl0ZXJhbCBzdHJpbmdzLiBUaGUgbWVzc2FnZXMgd2lsbCBiZSByZXBsYWNlZCB3aXRoIGVycm9yIGNvZGVzXG4vLyBkdXJpbmcgYnVpbGQuXG5mdW5jdGlvbiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKGNvZGUpIHtcbiAgdmFyIHVybCA9ICdodHRwczovL3JlYWN0anMub3JnL2RvY3MvZXJyb3ItZGVjb2Rlci5odG1sP2ludmFyaWFudD0nICsgY29kZTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHVybCArPSAnJmFyZ3NbXT0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tpXSk7XG4gIH1cblxuICByZXR1cm4gXCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIgKyBjb2RlICsgXCI7IHZpc2l0IFwiICsgdXJsICsgXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgXCIgKyAndXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCAnICsgJ2hlbHBmdWwgd2FybmluZ3MuJztcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbi8vIGJ5IGNhbGxzIHRvIHRoZXNlIG1ldGhvZHMgYnkgYSBCYWJlbCBwbHVnaW4uXG4vL1xuLy8gSW4gUFJPRCAob3IgaW4gcGFja2FnZXMgd2l0aG91dCBhY2Nlc3MgdG8gUmVhY3QgaW50ZXJuYWxzKSxcbi8vIHRoZXkgYXJlIGxlZnQgYXMgdGhleSBhcmUgaW5zdGVhZC5cblxuZnVuY3Rpb24gd2Fybihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVN1c3BlbnNlU2VydmVyUmVuZGVyZXIgPSBmYWxzZTtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlO1xuXG57XG4gIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcbn1cblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIG1hc2tDb250ZXh0KHR5cGUsIGNvbnRleHQpIHtcbiAgdmFyIGNvbnRleHRUeXBlcyA9IHR5cGUuY29udGV4dFR5cGVzO1xuXG4gIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgdmFyIG1hc2tlZENvbnRleHQgPSB7fTtcblxuICBmb3IgKHZhciBjb250ZXh0TmFtZSBpbiBjb250ZXh0VHlwZXMpIHtcbiAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICB9XG5cbiAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ29udGV4dFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbikge1xuICB7XG4gICAgY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCAnQ29tcG9uZW50Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHQsIHRocmVhZElEKSB7XG4gIC8vIElmIHdlIGRvbid0IGhhdmUgZW5vdWdoIHNsb3RzIGluIHRoaXMgY29udGV4dCB0byBzdG9yZSB0aGlzIHRocmVhZElELFxuICAvLyBmaWxsIGl0IGluIHdpdGhvdXQgbGVhdmluZyBhbnkgaG9sZXMgdG8gZW5zdXJlIHRoYXQgdGhlIFZNIG9wdGltaXplc1xuICAvLyB0aGlzIGFzIG5vbi1ob2xleSBpbmRleCBwcm9wZXJ0aWVzLlxuICAvLyAoTm90ZTogSWYgYHJlYWN0YCBwYWNrYWdlIGlzIDwgMTYuNiwgX3RocmVhZENvdW50IGlzIHVuZGVmaW5lZC4pXG4gIGZvciAodmFyIGkgPSBjb250ZXh0Ll90aHJlYWRDb3VudCB8IDA7IGkgPD0gdGhyZWFkSUQ7IGkrKykge1xuICAgIC8vIFdlIGFzc3VtZSB0aGF0IHRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIGRlZmF1bHRWYWx1ZSB3aGljaCBtaWdodCBub3QgYmVcbiAgICAvLyB0cnVlIGlmIHdlJ3JlIHJlbmRlcmluZyBpbnNpZGUgYSBzZWNvbmRhcnkgcmVuZGVyZXIgYnV0IHRoZXkgYXJlXG4gICAgLy8gc2Vjb25kYXJ5IGJlY2F1c2UgdGhlc2UgdXNlIGNhc2VzIGFyZSB2ZXJ5IHJhcmUuXG4gICAgY29udGV4dFtpXSA9IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG4gICAgY29udGV4dC5fdGhyZWFkQ291bnQgPSBpICsgMTtcbiAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc0NvbnRleHQodHlwZSwgY29udGV4dCwgdGhyZWFkSUQsIGlzQ2xhc3MpIHtcbiAgaWYgKGlzQ2xhc3MpIHtcbiAgICB2YXIgY29udGV4dFR5cGUgPSB0eXBlLmNvbnRleHRUeXBlO1xuXG4gICAge1xuICAgICAgaWYgKCdjb250ZXh0VHlwZScgaW4gdHlwZSkge1xuICAgICAgICB2YXIgaXNWYWxpZCA9IC8vIEFsbG93IG51bGwgZm9yIGNvbmRpdGlvbmFsIGRlY2xhcmF0aW9uXG4gICAgICAgIGNvbnRleHRUeXBlID09PSBudWxsIHx8IGNvbnRleHRUeXBlICE9PSB1bmRlZmluZWQgJiYgY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSAmJiBjb250ZXh0VHlwZS5fY29udGV4dCA9PT0gdW5kZWZpbmVkOyAvLyBOb3QgYSA8Q29udGV4dC5Db25zdW1lcj5cblxuICAgICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXModHlwZSkpIHtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuYWRkKHR5cGUpO1xuICAgICAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gdW5kZWZpbmVkLiAnICsgJ1RoaXMgY2FuIGJlIGNhdXNlZCBieSBhIHR5cG8gb3IgYnkgbWl4aW5nIHVwIG5hbWVkIGFuZCBkZWZhdWx0IGltcG9ydHMuICcgKyAnVGhpcyBjYW4gYWxzbyBoYXBwZW4gZHVlIHRvIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSwgc28gJyArICd0cnkgbW92aW5nIHRoZSBjcmVhdGVDb250ZXh0KCkgY2FsbCB0byBhIHNlcGFyYXRlIGZpbGUuJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUpIHtcbiAgICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LlByb3ZpZGVyIGluc3RlYWQ/JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLl9jb250ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIDxDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD8nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbignLCAnKSArICd9Lic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IoJyVzIGRlZmluZXMgYW4gaW52YWxpZCBjb250ZXh0VHlwZS4gJyArICdjb250ZXh0VHlwZSBzaG91bGQgcG9pbnQgdG8gdGhlIENvbnRleHQgb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZUNvbnRleHQoKS4lcycsIGdldENvbXBvbmVudE5hbWUodHlwZSkgfHwgJ0NvbXBvbmVudCcsIGFkZGVuZHVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgICB2YWxpZGF0ZUNvbnRleHRCb3VuZHMoY29udGV4dFR5cGUsIHRocmVhZElEKTtcbiAgICAgIHJldHVybiBjb250ZXh0VHlwZVt0aHJlYWRJRF07XG4gICAgfVxuXG4gICAge1xuICAgICAgdmFyIG1hc2tlZENvbnRleHQgPSBtYXNrQ29udGV4dCh0eXBlLCBjb250ZXh0KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZS5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgICBjaGVja0NvbnRleHRUeXBlcyh0eXBlLmNvbnRleHRUeXBlcywgbWFza2VkQ29udGV4dCwgJ2NvbnRleHQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgdmFyIF9tYXNrZWRDb250ZXh0ID0gbWFza0NvbnRleHQodHlwZSwgY29udGV4dCk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGUuY29udGV4dFR5cGVzKSB7XG4gICAgICAgICAgY2hlY2tDb250ZXh0VHlwZXModHlwZS5jb250ZXh0VHlwZXMsIF9tYXNrZWRDb250ZXh0LCAnY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfbWFza2VkQ29udGV4dDtcbiAgICB9XG4gIH1cbn1cblxudmFyIG5leHRBdmFpbGFibGVUaHJlYWRJRHMgPSBuZXcgVWludDE2QXJyYXkoMTYpO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpKyspIHtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1tpXSA9IGkgKyAxO1xufVxuXG5uZXh0QXZhaWxhYmxlVGhyZWFkSURzWzE1XSA9IDA7XG5cbmZ1bmN0aW9uIGdyb3dUaHJlYWRDb3VudEFuZFJldHVybk5leHRBdmFpbGFibGUoKSB7XG4gIHZhciBvbGRBcnJheSA9IG5leHRBdmFpbGFibGVUaHJlYWRJRHM7XG4gIHZhciBvbGRTaXplID0gb2xkQXJyYXkubGVuZ3RoO1xuICB2YXIgbmV3U2l6ZSA9IG9sZFNpemUgKiAyO1xuXG4gIGlmICghKG5ld1NpemUgPD0gMHgxMDAwMCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJNYXhpbXVtIG51bWJlciBvZiBjb25jdXJyZW50IFJlYWN0IHJlbmRlcmVycyBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBhcmUgbm90IHByb3Blcmx5IGRlc3Ryb3lpbmcgdGhlIFJlYWRhYmxlIHByb3ZpZGVkIGJ5IFJlYWN0LiBFbnN1cmUgdGhhdCB5b3UgY2FsbCAuZGVzdHJveSgpIG9uIGl0IGlmIHlvdSBubyBsb25nZXIgd2FudCB0byByZWFkIGZyb20gaXQsIGFuZCBkaWQgbm90IHJlYWQgdG8gdGhlIGVuZC4gSWYgeW91IHVzZSAucGlwZSgpIHRoaXMgc2hvdWxkIGJlIGF1dG9tYXRpYy5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdBcnJheSA9IG5ldyBVaW50MTZBcnJheShuZXdTaXplKTtcbiAgbmV3QXJyYXkuc2V0KG9sZEFycmF5KTtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEcyA9IG5ld0FycmF5O1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdID0gb2xkU2l6ZSArIDE7XG5cbiAgZm9yICh2YXIgX2kgPSBvbGRTaXplOyBfaSA8IG5ld1NpemUgLSAxOyBfaSsrKSB7XG4gICAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1tfaV0gPSBfaSArIDE7XG4gIH1cblxuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW25ld1NpemUgLSAxXSA9IDA7XG4gIHJldHVybiBvbGRTaXplO1xufVxuXG5mdW5jdGlvbiBhbGxvY1RocmVhZElEKCkge1xuICB2YXIgbmV4dElEID0gbmV4dEF2YWlsYWJsZVRocmVhZElEc1swXTtcblxuICBpZiAobmV4dElEID09PSAwKSB7XG4gICAgcmV0dXJuIGdyb3dUaHJlYWRDb3VudEFuZFJldHVybk5leHRBdmFpbGFibGUoKTtcbiAgfVxuXG4gIG5leHRBdmFpbGFibGVUaHJlYWRJRHNbMF0gPSBuZXh0QXZhaWxhYmxlVGhyZWFkSURzW25leHRJRF07XG4gIHJldHVybiBuZXh0SUQ7XG59XG5mdW5jdGlvbiBmcmVlVGhyZWFkSUQoaWQpIHtcbiAgbmV4dEF2YWlsYWJsZVRocmVhZElEc1tpZF0gPSBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdO1xuICBuZXh0QXZhaWxhYmxlVGhyZWFkSURzWzBdID0gaWQ7XG59XG5cbi8vIEEgcmVzZXJ2ZWQgYXR0cmlidXRlLlxuLy8gSXQgaXMgaGFuZGxlZCBieSBSZWFjdCBzZXBhcmF0ZWx5IGFuZCBzaG91bGRuJ3QgYmUgd3JpdHRlbiB0byB0aGUgRE9NLlxudmFyIFJFU0VSVkVEID0gMDsgLy8gQSBzaW1wbGUgc3RyaW5nIGF0dHJpYnV0ZS5cbi8vIEF0dHJpYnV0ZXMgdGhhdCBhcmVuJ3QgaW4gdGhlIGZpbHRlciBhcmUgcHJlc3VtZWQgdG8gaGF2ZSB0aGlzIHR5cGUuXG5cbnZhciBTVFJJTkcgPSAxOyAvLyBBIHN0cmluZyBhdHRyaWJ1dGUgdGhhdCBhY2NlcHRzIGJvb2xlYW5zIGluIFJlYWN0LiBJbiBIVE1MLCB0aGVzZSBhcmUgY2FsbGVkXG4vLyBcImVudW1lcmF0ZWRcIiBhdHRyaWJ1dGVzIHdpdGggXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIiBhcyBwb3NzaWJsZSB2YWx1ZXMuXG4vLyBXaGVuIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gYSBcInRydWVcIiBzdHJpbmcuXG4vLyBXaGVuIGZhbHNlLCBpdCBzaG91bGQgYmUgc2V0IHRvIGEgXCJmYWxzZVwiIHN0cmluZy5cblxudmFyIEJPT0xFQU5JU0hfU1RSSU5HID0gMjsgLy8gQSByZWFsIGJvb2xlYW4gYXR0cmlidXRlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG5cbnZhciBCT09MRUFOID0gMzsgLy8gQW4gYXR0cmlidXRlIHRoYXQgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuLy8gV2hlbiB0cnVlLCBpdCBzaG91bGQgYmUgcHJlc2VudCAoc2V0IGVpdGhlciB0byBhbiBlbXB0eSBzdHJpbmcgb3IgaXRzIG5hbWUpLlxuLy8gV2hlbiBmYWxzZSwgaXQgc2hvdWxkIGJlIG9taXR0ZWQuXG4vLyBGb3IgYW55IG90aGVyIHZhbHVlLCBzaG91bGQgYmUgcHJlc2VudCB3aXRoIHRoYXQgdmFsdWUuXG5cbnZhciBPVkVSTE9BREVEX0JPT0xFQU4gPSA0OyAvLyBBbiBhdHRyaWJ1dGUgdGhhdCBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljLlxuLy8gV2hlbiBmYWxzeSwgaXQgc2hvdWxkIGJlIHJlbW92ZWQuXG5cbnZhciBOVU1FUklDID0gNTsgLy8gQW4gYXR0cmlidXRlIHRoYXQgbXVzdCBiZSBwb3NpdGl2ZSBudW1lcmljIG9yIHBhcnNlIGFzIGEgcG9zaXRpdmUgbnVtZXJpYy5cbi8vIFdoZW4gZmFsc3ksIGl0IHNob3VsZCBiZSByZW1vdmVkLlxuXG52YXIgUE9TSVRJVkVfTlVNRVJJQyA9IDY7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gXCI6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xudmFyIFJPT1RfQVRUUklCVVRFX05BTUUgPSAnZGF0YS1yZWFjdHJvb3QnO1xudmFyIFZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYID0gbmV3IFJlZ0V4cCgnXlsnICsgQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArICddWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlLCBhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSwgYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcblxuICB7XG4gICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIG5hbWU6IGAlc2AnLCBhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNob3VsZElnbm9yZUF0dHJpYnV0ZShuYW1lLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLnR5cGUgPT09IFJFU0VSVkVEO1xuICB9XG5cbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnZnVuY3Rpb24nOiAvLyAkRmxvd0lzc3VlIHN5bWJvbCBpcyBwZXJmZWN0bHkgdmFsaWQgaGVyZVxuXG4gICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICB7XG4gICAgICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gIXByb3BlcnR5SW5mby5hY2NlcHRzQm9vbGVhbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHByZWZpeCA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgwLCA1KTtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICE9PSAnZGF0YS0nICYmIHByZWZpeCAhPT0gJ2FyaWEtJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gc2hvdWxkUmVtb3ZlQXR0cmlidXRlKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoc2hvdWxkUmVtb3ZlQXR0cmlidXRlV2l0aFdhcm5pbmcobmFtZSwgdmFsdWUsIHByb3BlcnR5SW5mbywgaXNDdXN0b21Db21wb25lbnRUYWcpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG5cbiAgICBzd2l0Y2ggKHByb3BlcnR5SW5mby50eXBlKSB7XG4gICAgICBjYXNlIEJPT0xFQU46XG4gICAgICAgIHJldHVybiAhdmFsdWU7XG5cbiAgICAgIGNhc2UgT1ZFUkxPQURFRF9CT09MRUFOOlxuICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZhbHNlO1xuXG4gICAgICBjYXNlIE5VTUVSSUM6XG4gICAgICAgIHJldHVybiBpc05hTih2YWx1ZSk7XG5cbiAgICAgIGNhc2UgUE9TSVRJVkVfTlVNRVJJQzpcbiAgICAgICAgcmV0dXJuIGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA8IDE7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0UHJvcGVydHlJbmZvKG5hbWUpIHtcbiAgcmV0dXJuIHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9wZXJ0aWVzW25hbWVdIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIHR5cGUsIG11c3RVc2VQcm9wZXJ0eSwgYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlTmFtZXNwYWNlLCBzYW5pdGl6ZVVSTCwgcmVtb3ZlRW1wdHlTdHJpbmcpIHtcbiAgdGhpcy5hY2NlcHRzQm9vbGVhbnMgPSB0eXBlID09PSBCT09MRUFOSVNIX1NUUklORyB8fCB0eXBlID09PSBCT09MRUFOIHx8IHR5cGUgPT09IE9WRVJMT0FERURfQk9PTEVBTjtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgdGhpcy5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBhdHRyaWJ1dGVOYW1lc3BhY2U7XG4gIHRoaXMubXVzdFVzZVByb3BlcnR5ID0gbXVzdFVzZVByb3BlcnR5O1xuICB0aGlzLnByb3BlcnR5TmFtZSA9IG5hbWU7XG4gIHRoaXMudHlwZSA9IHR5cGU7XG4gIHRoaXMuc2FuaXRpemVVUkwgPSBzYW5pdGl6ZVVSTDtcbiAgdGhpcy5yZW1vdmVFbXB0eVN0cmluZyA9IHJlbW92ZUVtcHR5U3RyaW5nO1xufSAvLyBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4vLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuLy8gbmFtZSB3YXJuaW5ncy5cblxuXG52YXIgcHJvcGVydGllcyA9IHt9OyAvLyBUaGVzZSBwcm9wcyBhcmUgcmVzZXJ2ZWQgYnkgUmVhY3QuIFRoZXkgc2hvdWxkbid0IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cblxudmFyIHJlc2VydmVkUHJvcHMgPSBbJ2NoaWxkcmVuJywgJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJywgLy8gVE9ETzogVGhpcyBwcmV2ZW50cyB0aGUgYXNzaWdubWVudCBvZiBkZWZhdWx0VmFsdWUgdG8gcmVndWxhclxuLy8gZWxlbWVudHMgKG5vdCBqdXN0IGlucHV0cykuIE5vdyB0aGF0IFJlYWN0RE9NSW5wdXQgYXNzaWducyB0byB0aGVcbi8vIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eSAtLSBkbyB3ZSBuZWVkIHRoaXM/XG4nZGVmYXVsdFZhbHVlJywgJ2RlZmF1bHRDaGVja2VkJywgJ2lubmVySFRNTCcsICdzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcnLCAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJywgJ3N0eWxlJ107XG5yZXNlcnZlZFByb3BzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgUkVTRVJWRUQsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBBIGZldyBSZWFjdCBzdHJpbmcgYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5hbWUuXG4vLyBUaGlzIGlzIGEgbWFwcGluZyBmcm9tIFJlYWN0IHByb3AgbmFtZXMgdG8gdGhlIGF0dHJpYnV0ZSBuYW1lcy5cblxuW1snYWNjZXB0Q2hhcnNldCcsICdhY2NlcHQtY2hhcnNldCddLCBbJ2NsYXNzTmFtZScsICdjbGFzcyddLCBbJ2h0bWxGb3InLCAnZm9yJ10sIFsnaHR0cEVxdWl2JywgJ2h0dHAtZXF1aXYnXV0uZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICB2YXIgbmFtZSA9IF9yZWZbMF0sXG4gICAgICBhdHRyaWJ1dGVOYW1lID0gX3JlZlsxXTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIFwiZW51bWVyYXRlZFwiIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFjY2VwdCBcInRydWVcIiBhbmQgXCJmYWxzZVwiLlxuLy8gSW4gUmVhY3QsIHdlIGxldCB1c2VycyBwYXNzIGB0cnVlYCBhbmQgYGZhbHNlYCBldmVuIHRob3VnaCB0ZWNobmljYWxseVxuLy8gdGhlc2UgYXJlbid0IGJvb2xlYW4gYXR0cmlidXRlcyAodGhleSBhcmUgY29lcmNlZCB0byBzdHJpbmdzKS5cblxuWydjb250ZW50RWRpdGFibGUnLCAnZHJhZ2dhYmxlJywgJ3NwZWxsQ2hlY2snLCAndmFsdWUnXS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gIHByb3BlcnRpZXNbbmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKG5hbWUsIEJPT0xFQU5JU0hfU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgXCJlbnVtZXJhdGVkXCIgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBhY2NlcHQgXCJ0cnVlXCIgYW5kIFwiZmFsc2VcIi5cbi8vIEluIFJlYWN0LCB3ZSBsZXQgdXNlcnMgcGFzcyBgdHJ1ZWAgYW5kIGBmYWxzZWAgZXZlbiB0aG91Z2ggdGVjaG5pY2FsbHlcbi8vIHRoZXNlIGFyZW4ndCBib29sZWFuIGF0dHJpYnV0ZXMgKHRoZXkgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncykuXG4vLyBTaW5jZSB0aGVzZSBhcmUgU1ZHIGF0dHJpYnV0ZXMsIHRoZWlyIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZS1zZW5zaXRpdmUuXG5cblsnYXV0b1JldmVyc2UnLCAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsICdmb2N1c2FibGUnLCAncHJlc2VydmVBbHBoYSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTklTSF9TVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgbmFtZSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMuXG5cblsnYWxsb3dGdWxsU2NyZWVuJywgJ2FzeW5jJywgLy8gTm90ZTogdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBwcmV2ZW50cyBpdCBmcm9tIGJlaW5nIHdyaXR0ZW4gdG8gdGhlIERPTVxuLy8gb24gdGhlIGNsaWVudCBzaWRlIGJlY2F1c2UgdGhlIGJyb3dzZXJzIGFyZSBpbmNvbnNpc3RlbnQuIEluc3RlYWQgd2UgY2FsbCBmb2N1cygpLlxuJ2F1dG9Gb2N1cycsICdhdXRvUGxheScsICdjb250cm9scycsICdkZWZhdWx0JywgJ2RlZmVyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVQaWN0dXJlSW5QaWN0dXJlJywgJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsICdmb3JtTm9WYWxpZGF0ZScsICdoaWRkZW4nLCAnbG9vcCcsICdub01vZHVsZScsICdub1ZhbGlkYXRlJywgJ29wZW4nLCAncGxheXNJbmxpbmUnLCAncmVhZE9ubHknLCAncmVxdWlyZWQnLCAncmV2ZXJzZWQnLCAnc2NvcGVkJywgJ3NlYW1sZXNzJywgLy8gTWljcm9kYXRhXG4naXRlbVNjb3BlJ10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBCT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBUaGVzZSBhcmUgdGhlIGZldyBSZWFjdCBwcm9wcyB0aGF0IHdlIHNldCBhcyBET00gcHJvcGVydGllc1xuLy8gcmF0aGVyIHRoYW4gYXR0cmlidXRlcy4gVGhlc2UgYXJlIGFsbCBib29sZWFucy5cblxuWydjaGVja2VkJywgLy8gTm90ZTogYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbi8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuIFdlIGhhdmUgc3BlY2lhbCBsb2dpYyBmb3IgaGFuZGxpbmcgdGhpcy5cbidtdWx0aXBsZScsICdtdXRlZCcsICdzZWxlY3RlZCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgQk9PTEVBTiwgdHJ1ZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IGFyZSBcIm92ZXJsb2FkZWQgYm9vbGVhbnNcIjogdGhleSBiZWhhdmUgbGlrZVxuLy8gYm9vbGVhbnMsIGJ1dCBjYW4gYWxzbyBhY2NlcHQgYSBzdHJpbmcgdmFsdWUuXG5cblsnY2FwdHVyZScsICdkb3dubG9hZCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgT1ZFUkxPQURFRF9CT09MRUFOLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgcG9zaXRpdmUgbnVtYmVycy5cblxuWydjb2xzJywgJ3Jvd3MnLCAnc2l6ZScsICdzcGFuJyAvLyBOT1RFOiBpZiB5b3UgYWRkIGEgY2FtZWxDYXNlZCBwcm9wIHRvIHRoaXMgbGlzdCxcbi8vIHlvdSdsbCBuZWVkIHRvIHNldCBhdHRyaWJ1dGVOYW1lIHRvIG5hbWUudG9Mb3dlckNhc2UoKVxuLy8gaW5zdGVhZCBpbiB0aGUgYXNzaWdubWVudCBiZWxvdy5cbl0uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBQT1NJVElWRV9OVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUsIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gVGhlc2UgYXJlIEhUTUwgYXR0cmlidXRlcyB0aGF0IG11c3QgYmUgbnVtYmVycy5cblxuWydyb3dTcGFuJywgJ3N0YXJ0J10uZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBOVU1FUklDLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIG5hbWUudG9Mb3dlckNhc2UoKSwgLy8gYXR0cmlidXRlTmFtZVxuICBudWxsLCAvLyBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pO1xudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xuXG52YXIgY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICByZXR1cm4gdG9rZW5bMV0udG9VcHBlckNhc2UoKTtcbn07IC8vIFRoaXMgaXMgYSBsaXN0IG9mIGFsbCBTVkcgYXR0cmlidXRlcyB0aGF0IG5lZWQgc3BlY2lhbCBjYXNpbmcsIG5hbWVzcGFjaW5nLFxuLy8gb3IgYm9vbGVhbiB2YWx1ZSBhc3NpZ25tZW50LiBSZWd1bGFyIGF0dHJpYnV0ZXMgdGhhdCBqdXN0IGFjY2VwdCBzdHJpbmdzXG4vLyBhbmQgaGF2ZSB0aGUgc2FtZSBuYW1lcyBhcmUgb21pdHRlZCwganVzdCBsaWtlIGluIHRoZSBIVE1MIGF0dHJpYnV0ZSBmaWx0ZXIuXG4vLyBTb21lIG9mIHRoZXNlIGF0dHJpYnV0ZXMgY2FuIGJlIGhhcmQgdG8gZmluZC4gVGhpcyBsaXN0IHdhcyBjcmVhdGVkIGJ5XG4vLyBzY3JhcGluZyB0aGUgTUROIGRvY3VtZW50YXRpb24uXG5cblxuWydhY2NlbnQtaGVpZ2h0JywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhcmFiaWMtZm9ybScsICdiYXNlbGluZS1zaGlmdCcsICdjYXAtaGVpZ2h0JywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnZW5hYmxlLWJhY2tncm91bmQnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdnbHlwaC1uYW1lJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCAnaG9yaXotYWR2LXgnLCAnaG9yaXotb3JpZ2luLXgnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2xldHRlci1zcGFjaW5nJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnb3ZlcmxpbmUtcG9zaXRpb24nLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJywgJ3BhaW50LW9yZGVyJywgJ3Bhbm9zZS0xJywgJ3BvaW50ZXItZXZlbnRzJywgJ3JlbmRlcmluZy1pbnRlbnQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd1bmRlcmxpbmUtcG9zaXRpb24nLCAndW5kZXJsaW5lLXRoaWNrbmVzcycsICd1bmljb2RlLWJpZGknLCAndW5pY29kZS1yYW5nZScsICd1bml0cy1wZXItZW0nLCAndi1hbHBoYWJldGljJywgJ3YtaGFuZ2luZycsICd2LWlkZW9ncmFwaGljJywgJ3YtbWF0aGVtYXRpY2FsJywgJ3ZlY3Rvci1lZmZlY3QnLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd29yZC1zcGFjaW5nJywgJ3dyaXRpbmctbW9kZScsICd4bWxuczp4bGluaycsICd4LWhlaWdodCcgLy8gTk9URTogaWYgeW91IGFkZCBhIGNhbWVsQ2FzZWQgcHJvcCB0byB0aGlzIGxpc3QsXG4vLyB5b3UnbGwgbmVlZCB0byBzZXQgYXR0cmlidXRlTmFtZSB0byBuYW1lLnRvTG93ZXJDYXNlKClcbi8vIGluc3RlYWQgaW4gdGhlIGFzc2lnbm1lbnQgYmVsb3cuXG5dLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVOYW1lLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuICBwcm9wZXJ0aWVzW25hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChuYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZSwgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIGZhbHNlLCAvLyBzYW5pdGl6ZVVSTFxuICBmYWxzZSk7XG59KTsgLy8gU3RyaW5nIFNWRyBhdHRyaWJ1dGVzIHdpdGggdGhlIHhsaW5rIG5hbWVzcGFjZS5cblxuWyd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6cm9sZScsICd4bGluazpzaG93JywgJ3hsaW5rOnRpdGxlJywgJ3hsaW5rOnR5cGUnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgZmFsc2UsIC8vIHNhbml0aXplVVJMXG4gIGZhbHNlKTtcbn0pOyAvLyBTdHJpbmcgU1ZHIGF0dHJpYnV0ZXMgd2l0aCB0aGUgeG1sIG5hbWVzcGFjZS5cblxuWyd4bWw6YmFzZScsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnIC8vIE5PVEU6IGlmIHlvdSBhZGQgYSBjYW1lbENhc2VkIHByb3AgdG8gdGhpcyBsaXN0LFxuLy8geW91J2xsIG5lZWQgdG8gc2V0IGF0dHJpYnV0ZU5hbWUgdG8gbmFtZS50b0xvd2VyQ2FzZSgpXG4vLyBpbnN0ZWFkIGluIHRoZSBhc3NpZ25tZW50IGJlbG93LlxuXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHZhciBuYW1lID0gYXR0cmlidXRlTmFtZS5yZXBsYWNlKENBTUVMSVpFLCBjYXBpdGFsaXplKTtcbiAgcHJvcGVydGllc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eUluZm9SZWNvcmQobmFtZSwgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4gIGF0dHJpYnV0ZU5hbWUsICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLCBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZSBleGlzdHMgYm90aCBpbiBIVE1MIGFuZCBTVkcuXG4vLyBUaGUgYXR0cmlidXRlIG5hbWUgaXMgY2FzZS1zZW5zaXRpdmUgaW4gU1ZHIHNvIHdlIGNhbid0IGp1c3QgdXNlXG4vLyB0aGUgUmVhY3QgbmFtZSBsaWtlIHdlIGRvIGZvciBhdHRyaWJ1dGVzIHRoYXQgZXhpc3Qgb25seSBpbiBIVE1MLlxuXG5bJ3RhYkluZGV4JywgJ2Nyb3NzT3JpZ2luJ10uZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlTmFtZSkge1xuICBwcm9wZXJ0aWVzW2F0dHJpYnV0ZU5hbWVdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZChhdHRyaWJ1dGVOYW1lLCBTVFJJTkcsIGZhbHNlLCAvLyBtdXN0VXNlUHJvcGVydHlcbiAgYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpLCAvLyBhdHRyaWJ1dGVOYW1lXG4gIG51bGwsIC8vIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICBmYWxzZSwgLy8gc2FuaXRpemVVUkxcbiAgZmFsc2UpO1xufSk7IC8vIFRoZXNlIGF0dHJpYnV0ZXMgYWNjZXB0IFVSTHMuIFRoZXNlIG11c3Qgbm90IGFsbG93IGphdmFzY3JpcHQ6IFVSTFMuXG4vLyBUaGVzZSB3aWxsIGFsc28gbmVlZCB0byBhY2NlcHQgVHJ1c3RlZCBUeXBlcyBvYmplY3QgaW4gdGhlIGZ1dHVyZS5cblxudmFyIHhsaW5rSHJlZiA9ICd4bGlua0hyZWYnO1xucHJvcGVydGllc1t4bGlua0hyZWZdID0gbmV3IFByb3BlcnR5SW5mb1JlY29yZCgneGxpbmtIcmVmJywgU1RSSU5HLCBmYWxzZSwgLy8gbXVzdFVzZVByb3BlcnR5XG4neGxpbms6aHJlZicsICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgdHJ1ZSwgLy8gc2FuaXRpemVVUkxcbmZhbHNlKTtcblsnc3JjJywgJ2hyZWYnLCAnYWN0aW9uJywgJ2Zvcm1BY3Rpb24nXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lKSB7XG4gIHByb3BlcnRpZXNbYXR0cmlidXRlTmFtZV0gPSBuZXcgUHJvcGVydHlJbmZvUmVjb3JkKGF0dHJpYnV0ZU5hbWUsIFNUUklORywgZmFsc2UsIC8vIG11c3RVc2VQcm9wZXJ0eVxuICBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCksIC8vIGF0dHJpYnV0ZU5hbWVcbiAgbnVsbCwgLy8gYXR0cmlidXRlTmFtZXNwYWNlXG4gIHRydWUsIC8vIHNhbml0aXplVVJMXG4gIHRydWUpO1xufSk7XG5cbi8vIGFuZCBhbnkgbmV3bGluZSBvciB0YWIgYXJlIGZpbHRlcmVkIG91dCBhcyBpZiB0aGV5J3JlIG5vdCBwYXJ0IG9mIHRoZSBVUkwuXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybC1wYXJzaW5nXG4vLyBUYWIgb3IgbmV3bGluZSBhcmUgZGVmaW5lZCBhcyBcXHJcXG5cXHQ6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYXNjaWktdGFiLW9yLW5ld2xpbmVcbi8vIEEgQzAgY29udHJvbCBpcyBhIGNvZGUgcG9pbnQgaW4gdGhlIHJhbmdlIFxcdTAwMDAgTlVMTCB0byBcXHUwMDFGXG4vLyBJTkZPUk1BVElPTiBTRVBBUkFUT1IgT05FLCBpbmNsdXNpdmU6XG4vLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jYzAtY29udHJvbC1vci1zcGFjZVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cbnZhciBpc0phdmFTY3JpcHRQcm90b2NvbCA9IC9eW1xcdTAwMDAtXFx1MDAxRiBdKmpbXFxyXFxuXFx0XSphW1xcclxcblxcdF0qdltcXHJcXG5cXHRdKmFbXFxyXFxuXFx0XSpzW1xcclxcblxcdF0qY1tcXHJcXG5cXHRdKnJbXFxyXFxuXFx0XSppW1xcclxcblxcdF0qcFtcXHJcXG5cXHRdKnRbXFxyXFxuXFx0XSpcXDovaTtcbnZhciBkaWRXYXJuID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHNhbml0aXplVVJMKHVybCkge1xuICB7XG4gICAgaWYgKCFkaWRXYXJuICYmIGlzSmF2YVNjcmlwdFByb3RvY29sLnRlc3QodXJsKSkge1xuICAgICAgZGlkV2FybiA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdBIGZ1dHVyZSB2ZXJzaW9uIG9mIFJlYWN0IHdpbGwgYmxvY2sgamF2YXNjcmlwdDogVVJMcyBhcyBhIHNlY3VyaXR5IHByZWNhdXRpb24uICcgKyAnVXNlIGV2ZW50IGhhbmRsZXJzIGluc3RlYWQgaWYgeW91IGNhbi4gSWYgeW91IG5lZWQgdG8gZ2VuZXJhdGUgdW5zYWZlIEhUTUwgdHJ5ICcgKyAndXNpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgaW5zdGVhZC4gUmVhY3Qgd2FzIHBhc3NlZCAlcy4nLCBKU09OLnN0cmluZ2lmeSh1cmwpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xudmFyIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS87XG4vKipcbiAqIEVzY2FwZXMgc3BlY2lhbCBjaGFyYWN0ZXJzIGFuZCBIVE1MIGVudGl0aWVzIGluIGEgZ2l2ZW4gaHRtbCBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgSFRNTCBzdHJpbmcgdG8gZXNjYXBlIGZvciBsYXRlciBpbnNlcnRpb25cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICB2YXIgc3RyID0gJycgKyBzdHJpbmc7XG4gIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHN0cik7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgZXNjYXBlO1xuICB2YXIgaHRtbCA9ICcnO1xuICB2YXIgaW5kZXg7XG4gIHZhciBsYXN0SW5kZXggPSAwO1xuXG4gIGZvciAoaW5kZXggPSBtYXRjaC5pbmRleDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgc3dpdGNoIChzdHIuY2hhckNvZGVBdChpbmRleCkpIHtcbiAgICAgIGNhc2UgMzQ6XG4gICAgICAgIC8vIFwiXG4gICAgICAgIGVzY2FwZSA9ICcmcXVvdDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAzOTpcbiAgICAgICAgLy8gJ1xuICAgICAgICBlc2NhcGUgPSAnJiN4Mjc7JzsgLy8gbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbDsgdXNlZCB0byBiZSAnJiMzOSdcblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDYyOlxuICAgICAgICAvLyA+XG4gICAgICAgIGVzY2FwZSA9ICcmZ3Q7JztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChsYXN0SW5kZXggIT09IGluZGV4KSB7XG4gICAgICBodG1sICs9IHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCk7XG4gICAgfVxuXG4gICAgbGFzdEluZGV4ID0gaW5kZXggKyAxO1xuICAgIGh0bWwgKz0gZXNjYXBlO1xuICB9XG5cbiAgcmV0dXJuIGxhc3RJbmRleCAhPT0gaW5kZXggPyBodG1sICsgc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KSA6IGh0bWw7XG59IC8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cblxuXG5mdW5jdGlvbiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB0ZXh0ID09PSAnbnVtYmVyJykge1xuICAgIC8vIHRoaXMgc2hvcnRjaXJjdWl0IGhlbHBzIHBlcmYgZm9yIHR5cGVzIHRoYXQgd2Uga25vdyB3aWxsIG5ldmVyIGhhdmVcbiAgICAvLyBzcGVjaWFsIGNoYXJhY3RlcnMsIGVzcGVjaWFsbHkgZ2l2ZW4gdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgb2Z0ZW5cbiAgICAvLyBmb3IgbnVtZXJpYyBkb20gaWRzLlxuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH1cblxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxuLyoqXG4gKiBFc2NhcGVzIGF0dHJpYnV0ZSB2YWx1ZSB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSkge1xuICByZXR1cm4gJ1wiJyArIGVzY2FwZVRleHRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEZvclJvb3QoKSB7XG4gIHJldHVybiBST09UX0FUVFJJQlVURV9OQU1FICsgJz1cIlwiJztcbn1cbi8qKlxuICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4gez9zdHJpbmd9IE1hcmt1cCBzdHJpbmcsIG9yIG51bGwgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG5cbiAgaWYgKG5hbWUgIT09ICdzdHlsZScgJiYgc2hvdWxkSWdub3JlQXR0cmlidXRlKG5hbWUsIHByb3BlcnR5SW5mbywgZmFsc2UpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAocHJvcGVydHlJbmZvICE9PSBudWxsKSB7XG4gICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICB2YXIgdHlwZSA9IHByb3BlcnR5SW5mby50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IEJPT0xFQU4gfHwgdHlwZSA9PT0gT1ZFUkxPQURFRF9CT09MRUFOICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gYXR0cmlidXRlTmFtZSArICc9XCJcIic7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uc2FuaXRpemVVUkwpIHtcbiAgICAgICAgdmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgICBzYW5pdGl6ZVVSTCh2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhdHRyaWJ1dGVOYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG4vKipcbiAqIENyZWF0ZXMgbWFya3VwIGZvciBhIGN1c3RvbSBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBlbXB0eSBzdHJpbmcgaWYgdGhlIHByb3BlcnR5IHdhcyBpbnZhbGlkLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIodmFsdWUpO1xufVxuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIDtcbn1cblxudmFyIG9iamVjdElzID0gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gbnVsbDtcbnZhciBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG52YXIgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDsgLy8gV2hldGhlciB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rIGlzIGEgcmUtcmVuZGVyZWQgaG9va1xuXG52YXIgaXNSZVJlbmRlciA9IGZhbHNlOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGR1cmluZyB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyByZW5kZXIgcGFzcy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gTGF6aWx5IGNyZWF0ZWQgbWFwIG9mIHJlbmRlci1waGFzZSB1cGRhdGVzXG5cbnZhciByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsOyAvLyBDb3VudGVyIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMuXG5cbnZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG52YXIgUkVfUkVOREVSX0xJTUlUID0gMjU7XG52YXIgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7IC8vIEluIERFViwgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBwcmltaXRpdmUgaG9va1xuXG52YXIgY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbmZ1bmN0aW9uIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKSB7XG4gIGlmICghKGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCAhPT0gbnVsbCkpIHtcbiAgICB7XG4gICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIGhvb2sgY2FsbC4gSG9va3MgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBvZiB0aGUgYm9keSBvZiBhIGZ1bmN0aW9uIGNvbXBvbmVudC4gVGhpcyBjb3VsZCBoYXBwZW4gZm9yIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuMi4gWW91IG1pZ2h0IGJlIGJyZWFraW5nIHRoZSBSdWxlcyBvZiBIb29rc1xcbjMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG5TZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS5cIiApO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoaXNJbkhvb2tVc2VyQ29kZUluRGV2KSB7XG4gICAgICBlcnJvcignRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiAnICsgJ1lvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3J1bGVzLW9mLWhvb2tzJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICBpZiAocHJldkRlcHMgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCBkdXJpbmcgdGhpcyByZW5kZXIsIGJ1dCBub3QgZHVyaW5nICcgKyAndGhlIHByZXZpb3VzIHJlbmRlci4gRXZlbiB0aG91Z2ggdGhlIGZpbmFsIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCAnICsgJ2l0cyB0eXBlIGNhbm5vdCBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzLicsIGN1cnJlbnRIb29rTmFtZUluRGV2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB7XG4gICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZyBsZW5ndGhzIGluIHByb2QgYmVjYXVzZSB0aGVzZSBhcnJheXMgc2hvdWxkIGJlXG4gICAgLy8gcGFzc2VkIGlubGluZS5cbiAgICBpZiAobmV4dERlcHMubGVuZ3RoICE9PSBwcmV2RGVwcy5sZW5ndGgpIHtcbiAgICAgIGVycm9yKCdUaGUgZmluYWwgYXJndW1lbnQgcGFzc2VkIHRvICVzIGNoYW5nZWQgc2l6ZSBiZXR3ZWVuIHJlbmRlcnMuIFRoZSAnICsgJ29yZGVyIGFuZCBzaXplIG9mIHRoaXMgYXJyYXkgbXVzdCByZW1haW4gY29uc3RhbnQuXFxuXFxuJyArICdQcmV2aW91czogJXNcXG4nICsgJ0luY29taW5nOiAlcycsIGN1cnJlbnRIb29rTmFtZUluRGV2LCBcIltcIiArIG5leHREZXBzLmpvaW4oJywgJykgKyBcIl1cIiwgXCJbXCIgKyBwcmV2RGVwcy5qb2luKCcsICcpICsgXCJdXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkRlcHMubGVuZ3RoICYmIGkgPCBuZXh0RGVwcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChvYmplY3RJcyhuZXh0RGVwc1tpXSwgcHJldkRlcHNbaV0pKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSG9vaygpIHtcbiAgaWYgKG51bWJlck9mUmVSZW5kZXJzID4gMCkge1xuICAgIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiUmVuZGVyZWQgbW9yZSBob29rcyB0aGFuIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyXCIgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG1lbW9pemVkU3RhdGU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgaWYgKGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgICBpc1JlUmVuZGVyID0gZmFsc2U7XG4gICAgICBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZUhvb2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUncyBhbHJlYWR5IGEgd29yay1pbi1wcm9ncmVzcy4gUmV1c2UgaXQuXG4gICAgICBpc1JlUmVuZGVyID0gdHJ1ZTtcbiAgICAgIHdvcmtJblByb2dyZXNzSG9vayA9IGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPT09IG51bGwpIHtcbiAgICAgIGlzUmVSZW5kZXIgPSBmYWxzZTsgLy8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RcblxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBjcmVhdGVIb29rKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgICAgaXNSZVJlbmRlciA9IHRydWU7XG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9Vc2VIb29rcyhjb21wb25lbnRJZGVudGl0eSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBjb21wb25lbnRJZGVudGl0eTtcblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH0gLy8gVGhlIGZvbGxvd2luZyBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzZXRcbiAgLy8gZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAvLyBmaXJzdFdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIC8vIG51bWJlck9mUmVSZW5kZXJzID0gMDtcbiAgLy8gcmVuZGVyUGhhc2VVcGRhdGVzID0gbnVsbDtcbiAgLy8gd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxufVxuZnVuY3Rpb24gZmluaXNoSG9va3MoQ29tcG9uZW50LCBwcm9wcywgY2hpbGRyZW4sIHJlZk9yQ29udGV4dCkge1xuICAvLyBUaGlzIG11c3QgYmUgY2FsbGVkIGFmdGVyIGV2ZXJ5IGZ1bmN0aW9uIGNvbXBvbmVudCB0byBwcmV2ZW50IGhvb2tzIGZyb21cbiAgLy8gYmVpbmcgdXNlZCBpbiBjbGFzc2VzLlxuICB3aGlsZSAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgIC8vIFVwZGF0ZXMgd2VyZSBzY2hlZHVsZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIFRoZXkgYXJlIHN0b3JlZCBpblxuICAgIC8vIHRoZSBgcmVuZGVyUGhhc2VVcGRhdGVzYCBtYXAuIENhbGwgdGhlIGNvbXBvbmVudCBhZ2FpbiwgcmV1c2luZyB0aGVcbiAgICAvLyB3b3JrLWluLXByb2dyZXNzIGhvb2tzIGFuZCBhcHBseWluZyB0aGUgYWRkaXRpb25hbCB1cGRhdGVzIG9uIHRvcC4gS2VlcFxuICAgIC8vIHJlc3RhcnRpbmcgdW50aWwgbm8gbW9yZSB1cGRhdGVzIGFyZSBzY2hlZHVsZWQuXG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuICAgIG51bWJlck9mUmVSZW5kZXJzICs9IDE7IC8vIFN0YXJ0IG92ZXIgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCByZWZPckNvbnRleHQpO1xuICB9XG5cbiAgcmVzZXRIb29rc1N0YXRlKCk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn0gLy8gUmVzZXQgdGhlIGludGVybmFsIGhvb2tzIHN0YXRlIGlmIGFuIGVycm9yIG9jY3VycyB3aGlsZSByZW5kZXJpbmcgYSBjb21wb25lbnRcblxuZnVuY3Rpb24gcmVzZXRIb29rc1N0YXRlKCkge1xuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH1cblxuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSBudWxsO1xuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIGZpcnN0V29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICByZW5kZXJQaGFzZVVwZGF0ZXMgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAgdmFyIHRocmVhZElEID0gY3VycmVudFBhcnRpYWxSZW5kZXJlci50aHJlYWRJRDtcbiAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHQsIHRocmVhZElEKTtcblxuICB7XG4gICAgaWYgKGlzSW5Ib29rVXNlckNvZGVJbkRldikge1xuICAgICAgZXJyb3IoJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcgKyAnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJyArICdJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJyArICdpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb250ZXh0W3RocmVhZElEXTtcbn1cblxuZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0LCBvYnNlcnZlZEJpdHMpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICB9XG5cbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB2YXIgdGhyZWFkSUQgPSBjdXJyZW50UGFydGlhbFJlbmRlcmVyLnRocmVhZElEO1xuICB2YWxpZGF0ZUNvbnRleHRCb3VuZHMoY29udGV4dCwgdGhyZWFkSUQpO1xuICByZXR1cm4gY29udGV4dFt0aHJlYWRJRF07XG59XG5cbmZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgLy8gJEZsb3dGaXhNZTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicgPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xufVxuXG5mdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgfVxuXG4gIHJldHVybiB1c2VSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyLCAvLyB1c2VSZWR1Y2VyIGhhcyBhIHNwZWNpYWwgY2FzZSB0byBzdXBwb3J0IGxhenkgdXNlU3RhdGUgaW5pdGlhbGl6ZXJzXG4gIGluaXRpYWxTdGF0ZSk7XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAge1xuICAgIGlmIChyZWR1Y2VyICE9PSBiYXNpY1N0YXRlUmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgfVxuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcblxuICBpZiAoaXNSZVJlbmRlcikge1xuICAgIC8vIFRoaXMgaXMgYSByZS1yZW5kZXIuIEFwcGx5IHRoZSBuZXcgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgdG8gdGhlIHByZXZpb3VzXG4gICAgLy8gY3VycmVudCBob29rLlxuICAgIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzSG9vay5xdWV1ZTtcbiAgICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcblxuICAgIGlmIChyZW5kZXJQaGFzZVVwZGF0ZXMgIT09IG51bGwpIHtcbiAgICAgIC8vIFJlbmRlciBwaGFzZSB1cGRhdGVzIGFyZSBzdG9yZWQgaW4gYSBtYXAgb2YgcXVldWUgLT4gbGlua2VkIGxpc3RcbiAgICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gcmVuZGVyUGhhc2VVcGRhdGVzLmdldChxdWV1ZSk7XG5cbiAgICAgIGlmIChmaXJzdFJlbmRlclBoYXNlVXBkYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLmRlbGV0ZShxdWV1ZSk7XG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgdXBkYXRlID0gZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgLy8gUHJvY2VzcyB0aGlzIHJlbmRlciBwaGFzZSB1cGRhdGUuIFdlIGRvbid0IGhhdmUgdG8gY2hlY2sgdGhlXG4gICAgICAgICAgLy8gcHJpb3JpdHkgYmVjYXVzZSBpdCB3aWxsIGFsd2F5cyBiZSB0aGUgc2FtZSBhcyB0aGUgY3VycmVudFxuICAgICAgICAgIC8vIHJlbmRlcidzLlxuICAgICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsKTtcblxuICAgICAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICByZXR1cm4gW25ld1N0YXRlLCBkaXNwYXRjaF07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFt3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlzSW5Ib29rVXNlckNvZGVJbkRldiA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGluaXRpYWxTdGF0ZTtcblxuICAgIGlmIChyZWR1Y2VyID09PSBiYXNpY1N0YXRlUmVkdWNlcikge1xuICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBgdXNlU3RhdGVgLlxuICAgICAgaW5pdGlhbFN0YXRlID0gdHlwZW9mIGluaXRpYWxBcmcgPT09ICdmdW5jdGlvbicgPyBpbml0aWFsQXJnKCkgOiBpbml0aWFsQXJnO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbml0aWFsU3RhdGUgPSBpbml0ICE9PSB1bmRlZmluZWQgPyBpbml0KGluaXRpYWxBcmcpIDogaW5pdGlhbEFyZztcbiAgICB9XG5cbiAgICB7XG4gICAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcblxuICAgIHZhciBfcXVldWUgPSB3b3JrSW5Qcm9ncmVzc0hvb2sucXVldWUgPSB7XG4gICAgICBsYXN0OiBudWxsLFxuICAgICAgZGlzcGF0Y2g6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIF9kaXNwYXRjaCA9IF9xdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoQWN0aW9uLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50LCBfcXVldWUpO1xuXG4gICAgcmV0dXJuIFt3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSwgX2Rpc3BhdGNoXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50ID0gcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpc0luSG9va1VzZXJDb2RlSW5EZXYgPSB0cnVlO1xuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcblxuICB7XG4gICAgaXNJbkhvb2tVc2VyQ29kZUluRGV2ID0gZmFsc2U7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuICBjdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQgPSByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IGNyZWF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcHJldmlvdXNSZWYgPSB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAocHJldmlvdXNSZWYgPT09IG51bGwpIHtcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogaW5pdGlhbFZhbHVlXG4gICAgfTtcblxuICAgIHtcbiAgICAgIE9iamVjdC5zZWFsKHJlZik7XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUgPSByZWY7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJldmlvdXNSZWY7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgaW5wdXRzKSB7XG4gIHtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuXG4gICAgZXJyb3IoJ3VzZUxheW91dEVmZmVjdCBkb2VzIG5vdGhpbmcgb24gdGhlIHNlcnZlciwgYmVjYXVzZSBpdHMgZWZmZWN0IGNhbm5vdCAnICsgXCJiZSBlbmNvZGVkIGludG8gdGhlIHNlcnZlciByZW5kZXJlcidzIG91dHB1dCBmb3JtYXQuIFRoaXMgd2lsbCBsZWFkIFwiICsgJ3RvIGEgbWlzbWF0Y2ggYmV0d2VlbiB0aGUgaW5pdGlhbCwgbm9uLWh5ZHJhdGVkIFVJIGFuZCB0aGUgaW50ZW5kZWQgJyArICdVSS4gVG8gYXZvaWQgdGhpcywgdXNlTGF5b3V0RWZmZWN0IHNob3VsZCBvbmx5IGJlIHVzZWQgaW4gJyArICdjb21wb25lbnRzIHRoYXQgcmVuZGVyIGV4Y2x1c2l2ZWx5IG9uIHRoZSBjbGllbnQuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay91c2VsYXlvdXRlZmZlY3Qtc3NyIGZvciBjb21tb24gZml4ZXMuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb24oY29tcG9uZW50SWRlbnRpdHksIHF1ZXVlLCBhY3Rpb24pIHtcbiAgaWYgKCEobnVtYmVyT2ZSZVJlbmRlcnMgPCBSRV9SRU5ERVJfTElNSVQpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AuXCIgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY29tcG9uZW50SWRlbnRpdHkgPT09IGN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCkge1xuICAgIC8vIFRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBTdGFzaCBpdCBpbiBhIGxhemlseS1jcmVhdGVkIG1hcCBvZlxuICAgIC8vIHF1ZXVlIC0+IGxpbmtlZCBsaXN0IG9mIHVwZGF0ZXMuIEFmdGVyIHRoaXMgcmVuZGVyIHBhc3MsIHdlJ2xsIHJlc3RhcnRcbiAgICAvLyBhbmQgYXBwbHkgdGhlIHN0YXNoZWQgdXBkYXRlcyBvbiB0b3Agb2YgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgaG9vay5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gdHJ1ZTtcbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChyZW5kZXJQaGFzZVVwZGF0ZXMgPT09IG51bGwpIHtcbiAgICAgIHJlbmRlclBoYXNlVXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IHJlbmRlclBoYXNlVXBkYXRlcy5nZXQocXVldWUpO1xuXG4gICAgaWYgKGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVuZGVyUGhhc2VVcGRhdGVzLnNldChxdWV1ZSwgdXBkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgICAgIHZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgICB3aGlsZSAobGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQ7XG4gICAgICB9XG5cbiAgICAgIGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrO1xuICB9LCBkZXBzKTtcbn0gLy8gVE9ETyBEZWNpZGUgb24gaG93IHRvIGltcGxlbWVudCB0aGlzIGhvb2sgZm9yIHNlcnZlciByZW5kZXJpbmcuXG4vLyBJZiBhIG11dGF0aW9uIG9jY3VycyBkdXJpbmcgcmVuZGVyLCBjb25zaWRlciB0cmlnZ2VyaW5nIGEgU3VzcGVuc2UgYm91bmRhcnlcbi8vIGFuZCBmYWxsaW5nIGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy5cblxuZnVuY3Rpb24gdXNlTXV0YWJsZVNvdXJjZShzb3VyY2UsIGdldFNuYXBzaG90LCBzdWJzY3JpYmUpIHtcbiAgcmVzb2x2ZUN1cnJlbnRseVJlbmRlcmluZ0NvbXBvbmVudCgpO1xuICByZXR1cm4gZ2V0U25hcHNob3Qoc291cmNlLl9zb3VyY2UpO1xufVxuXG5mdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKHZhbHVlKSB7XG4gIHJlc29sdmVDdXJyZW50bHlSZW5kZXJpbmdDb21wb25lbnQoKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uKCkge1xuICByZXNvbHZlQ3VycmVudGx5UmVuZGVyaW5nQ29tcG9uZW50KCk7XG5cbiAgdmFyIHN0YXJ0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKCk7XG4gIH07XG5cbiAgcmV0dXJuIFtzdGFydFRyYW5zaXRpb24sIGZhbHNlXTtcbn1cblxuZnVuY3Rpb24gdXNlT3BhcXVlSWRlbnRpZmllcigpIHtcbiAgcmV0dXJuIChjdXJyZW50UGFydGlhbFJlbmRlcmVyLmlkZW50aWZpZXJQcmVmaXggfHwgJycpICsgJ1I6JyArIChjdXJyZW50UGFydGlhbFJlbmRlcmVyLnVuaXF1ZUlEKyspLnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBjdXJyZW50UGFydGlhbFJlbmRlcmVyID0gbnVsbDtcbmZ1bmN0aW9uIHNldEN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIocmVuZGVyZXIpIHtcbiAgY3VycmVudFBhcnRpYWxSZW5kZXJlciA9IHJlbmRlcmVyO1xufVxudmFyIERpc3BhdGNoZXIgPSB7XG4gIHJlYWRDb250ZXh0OiByZWFkQ29udGV4dCxcbiAgdXNlQ29udGV4dDogdXNlQ29udGV4dCxcbiAgdXNlTWVtbzogdXNlTWVtbyxcbiAgdXNlUmVkdWNlcjogdXNlUmVkdWNlcixcbiAgdXNlUmVmOiB1c2VSZWYsXG4gIHVzZVN0YXRlOiB1c2VTdGF0ZSxcbiAgdXNlTGF5b3V0RWZmZWN0OiB1c2VMYXlvdXRFZmZlY3QsXG4gIHVzZUNhbGxiYWNrOiB1c2VDYWxsYmFjayxcbiAgLy8gdXNlSW1wZXJhdGl2ZUhhbmRsZSBpcyBub3QgcnVuIGluIHRoZSBzZXJ2ZXIgZW52aXJvbm1lbnRcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogbm9vcCxcbiAgLy8gRWZmZWN0cyBhcmUgbm90IHJ1biBpbiB0aGUgc2VydmVyIGVudmlyb25tZW50LlxuICB1c2VFZmZlY3Q6IG5vb3AsXG4gIC8vIERlYnVnZ2luZyBlZmZlY3RcbiAgdXNlRGVidWdWYWx1ZTogbm9vcCxcbiAgdXNlRGVmZXJyZWRWYWx1ZTogdXNlRGVmZXJyZWRWYWx1ZSxcbiAgdXNlVHJhbnNpdGlvbjogdXNlVHJhbnNpdGlvbixcbiAgdXNlT3BhcXVlSWRlbnRpZmllcjogdXNlT3BhcXVlSWRlbnRpZmllcixcbiAgLy8gU3Vic2NyaXB0aW9ucyBhcmUgbm90IHNldHVwIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICB1c2VNdXRhYmxlU291cmNlOiB1c2VNdXRhYmxlU291cmNlXG59O1xuXG52YXIgSFRNTF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG52YXIgTUFUSF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG52YXIgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG52YXIgTmFtZXNwYWNlcyA9IHtcbiAgaHRtbDogSFRNTF9OQU1FU1BBQ0UsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTsgLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuXG5mdW5jdGlvbiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdzdmcnOlxuICAgICAgcmV0dXJuIFNWR19OQU1FU1BBQ0U7XG5cbiAgICBjYXNlICdtYXRoJzpcbiAgICAgIHJldHVybiBNQVRIX05BTUVTUEFDRTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0U7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSkge1xuICBpZiAocGFyZW50TmFtZXNwYWNlID09IG51bGwgfHwgcGFyZW50TmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuXG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT09IFNWR19OQU1FU1BBQ0UgJiYgdHlwZSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gV2UncmUgbGVhdmluZyBTVkcuXG4gICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFO1xuICB9IC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuXG5cbiAgcmV0dXJuIHBhcmVudE5hbWVzcGFjZTtcbn1cblxudmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gIGJ1dHRvbjogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGltYWdlOiB0cnVlLFxuICBoaWRkZW46IHRydWUsXG4gIHJhZGlvOiB0cnVlLFxuICByZXNldDogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlXG59O1xuZnVuY3Rpb24gY2hlY2tDb250cm9sbGVkVmFsdWVQcm9wcyh0YWdOYW1lLCBwcm9wcykge1xuICB7XG4gICAgaWYgKCEoaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5vbklucHV0IHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkIHx8IHByb3BzLnZhbHVlID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIShwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCB8fCBwcm9wcy5jaGVja2VkID09IG51bGwpKSB7XG4gICAgICBlcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9XG59XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgbGlzdCBmb3Jcbi8vIHRob3NlIHNwZWNpYWwtY2FzZSB0YWdzLlxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlIC8vIE5PVEU6IG1lbnVpdGVtJ3MgY2xvc2UgdGFnIHNob3VsZCBiZSBvbWl0dGVkLCBidXQgdGhhdCBjYXVzZXMgcHJvYmxlbXMuXG5cbn07XG5cbi8vIGBvbWl0dGVkQ2xvc2VUYWdzYCBleGNlcHQgdGhhdCBgbWVudWl0ZW1gIHNob3VsZCBzdGlsbCBoYXZlIGl0cyBjbG9zaW5nIHRhZy5cblxudmFyIHZvaWRFbGVtZW50VGFncyA9IF9hc3NpZ24oe1xuICBtZW51aXRlbTogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbnZhciBIVE1MID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcykge1xuICBpZiAoIXByb3BzKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIE5vdGUgdGhlIHVzZSBvZiBgPT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG5cblxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICBpZiAoIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpKSB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCB0YWcgKyBcIiBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICBpZiAoIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC5cIiApO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkpIHtcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoIFwiYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gUGxlYXNlIHZpc2l0IGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIiApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBpZiAoIXByb3BzLnN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyAmJiBwcm9wcy5jb250ZW50RWRpdGFibGUgJiYgcHJvcHMuY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpKSB7XG4gICAge1xuICAgICAgdGhyb3cgRXJyb3IoIFwiVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgJ2VtJ319IHdoZW4gdXNpbmcgSlNYLlwiICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGJvcmRlckltYWdlT3V0c2V0OiB0cnVlLFxuICBib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuICBib3JkZXJJbWFnZVdpZHRoOiB0cnVlLFxuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGJveE9yZGluYWxHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGNvbHVtbnM6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZmxleE9yZGVyOiB0cnVlLFxuICBncmlkQXJlYTogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZFJvd0VuZDogdHJ1ZSxcbiAgZ3JpZFJvd1NwYW46IHRydWUsXG4gIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZ3JpZENvbHVtbkVuZDogdHJ1ZSxcbiAgZ3JpZENvbHVtblNwYW46IHRydWUsXG4gIGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IHRydWUsXG4gIGZsb29kT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hhcnJheTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogdHJ1ZSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogdHJ1ZSxcbiAgc3Ryb2tlT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlV2lkdGg6IHRydWVcbn07XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuXG5mdW5jdGlvbiBwcmVmaXhLZXkocHJlZml4LCBrZXkpIHtcbiAgcmV0dXJuIHByZWZpeCArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSk7XG59XG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG5cblxudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTsgLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5cbmZ1bmN0aW9uIGRhbmdlcm91c1N0eWxlVmFsdWUobmFtZSwgdmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgLy8gTm90ZSB0aGF0IHdlJ3ZlIHJlbW92ZWQgZXNjYXBlVGV4dEZvckJyb3dzZXIoKSBjYWxscyBoZXJlIHNpbmNlIHRoZVxuICAvLyB3aG9sZSBzdHJpbmcgd2lsbCBiZSBlc2NhcGVkIHdoZW4gdGhlIGF0dHJpYnV0ZSBpcyBpbmplY3RlZCBpbnRvXG4gIC8vIHRoZSBtYXJrdXAuIElmIHlvdSBwcm92aWRlIHVuc2FmZSB1c2VyIGRhdGEgaGVyZSB0aGV5IGNhbiBpbmplY3RcbiAgLy8gYXJiaXRyYXJ5IENTUyB3aGljaCBtYXkgYmUgcHJvYmxlbWF0aWMgKEkgY291bGRuJ3QgcmVwcm8gdGhpcyk6XG4gIC8vIGh0dHBzOi8vd3d3Lm93YXNwLm9yZy9pbmRleC5waHAvWFNTX0ZpbHRlcl9FdmFzaW9uX0NoZWF0X1NoZWV0XG4gIC8vIGh0dHA6Ly93d3cudGhlc3Bhbm5lci5jby51ay8yMDA3LzExLzI2L3VsdGltYXRlLXhzcy1jc3MtaW5qZWN0aW9uL1xuICAvLyBUaGlzIGlzIG5vdCBhbiBYU1MgaG9sZSBidXQgaW5zdGVhZCBhIHBvdGVudGlhbCBDU1MgaW5qZWN0aW9uIGlzc3VlXG4gIC8vIHdoaWNoIGhhcyBsZWFkIHRvIGEgZ3JlYXRlciBkaXNjdXNzaW9uIGFib3V0IGhvdyB3ZSdyZSBnb2luZyB0b1xuICAvLyB0cnVzdCBVUkxzIG1vdmluZyBmb3J3YXJkLiBTZWUgIzIxMTU5MDFcbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcblxuICBpZiAoaXNFbXB0eSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICghaXNDdXN0b21Qcm9wZXJ0eSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwICYmICEoaXNVbml0bGVzc051bWJlci5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBpc1VuaXRsZXNzTnVtYmVyW25hbWVdKSkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7IC8vIFByZXN1bWVzIGltcGxpY2l0ICdweCcgc3VmZml4IGZvciB1bml0bGVzcyBudW1iZXJzXG4gIH1cblxuICByZXR1cm4gKCcnICsgdmFsdWUpLnRyaW0oKTtcbn1cblxudmFyIHVwcGVyY2FzZVBhdHRlcm4gPSAvKFtBLVpdKS9nO1xudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICovXG5cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShuYW1lKSB7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbmZ1bmN0aW9uIGlzQ3VzdG9tQ29tcG9uZW50KHRhZ05hbWUsIHByb3BzKSB7XG4gIGlmICh0YWdOYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gdHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJztcbiAgfVxuXG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbiAgICAvLyBXZSBkb24ndCBtaW5kIHRoaXMgbGlzdCB0b28gbXVjaCBiZWNhdXNlIHdlIGV4cGVjdCBpdCB0byBuZXZlciBncm93LlxuICAgIC8vIFRoZSBhbHRlcm5hdGl2ZSBpcyB0byB0cmFjayB0aGUgbmFtZXNwYWNlIGluIGEgZmV3IHBsYWNlcyB3aGljaCBpcyBjb252b2x1dGVkLlxuICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvY3VzdG9tLyNjdXN0b20tZWxlbWVudHMtY29yZS1jb25jZXB0c1xuICAgIGNhc2UgJ2Fubm90YXRpb24teG1sJzpcbiAgICBjYXNlICdjb2xvci1wcm9maWxlJzpcbiAgICBjYXNlICdmb250LWZhY2UnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1zcmMnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS11cmknOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1mb3JtYXQnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZS1uYW1lJzpcbiAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG4gIHZhciBtc1BhdHRlcm4kMSA9IC9eLW1zLS87XG4gIHZhciBoeXBoZW5QYXR0ZXJuID0gLy0oLikvZzsgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG5cbiAgdmFyIGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiA9IC87XFxzKiQvO1xuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIGNhbWVsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShoeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgICByZXR1cm4gY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG5cbiAgICBlcnJvcignVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCAvLyBBcyBBbmRpIFNtaXRoIHN1Z2dlc3RzXG4gICAgLy8gKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICAgIC8vIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAgICBjYW1lbGl6ZShuYW1lLnJlcGxhY2UobXNQYXR0ZXJuJDEsICdtcy0nKSkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKCdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8nLCBuYW1lLCBuYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcblxuICAgIGVycm9yKFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLicsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJykpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuXG4gICAgZXJyb3IoJ2BOYU5gIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZEZvckluZmluaXR5VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gdHJ1ZTtcblxuICAgIGVycm9yKCdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4nLCBuYW1lKTtcbiAgfTtcblxuICB3YXJuVmFsaWRTdHlsZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSk7XG4gICAgfSBlbHNlIGlmIChiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHdhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSQxID0gd2FyblZhbGlkU3R5bGU7XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsXG4gIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLFxuICAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5JDEuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgICB2YXIgYXJpYU5hbWUgPSAnYXJpYS0nICsgbmFtZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIGNvcnJlY3ROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsOyAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAgIC8vIERPTSBwcm9wZXJ0aWVzLCB0aGVuIGl0IGlzIGFuIGludmFsaWQgYXJpYS0qIGF0dHJpYnV0ZS5cblxuICAgICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgQVJJQSBhdHRyaWJ1dGUgYCVzYC4gQVJJQSBhdHRyaWJ1dGVzIGZvbGxvdyB0aGUgcGF0dGVybiBhcmlhLSogYW5kIG11c3QgYmUgbG93ZXJjYXNlLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IGNvcnJlY3ROYW1lKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIGNvcnJlY3ROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJBUklBLnRlc3QobmFtZSkpIHtcbiAgICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7IC8vIElmIHRoaXMgaXMgYW4gYXJpYS0qIGF0dHJpYnV0ZSwgYnV0IGlzIG5vdCBsaXN0ZWQgaW4gdGhlIGtub3duIERPTVxuICAgICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuXG4gICAgICBpZiAoc3RhbmRhcmROYW1lID09IG51bGwpIHtcbiAgICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG5cblxuICAgICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgICBlcnJvcignVW5rbm93biBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8nLCBuYW1lLCBzdGFuZGFyZE5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpIHtcbiAge1xuICAgIHZhciBpbnZhbGlkUHJvcHMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG5cbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICAgIH0pLmpvaW4oJywgJyk7XG5cbiAgICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgYXJpYSBwcm9wICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgICBlcnJvcignSW52YWxpZCBhcmlhIHByb3BzICVzIG9uIDwlcz4gdGFnLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2ludmFsaWQtYXJpYS1wcm9wcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcyk7XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICB7XG4gICAgaWYgKHR5cGUgIT09ICdpbnB1dCcgJiYgdHlwZSAhPT0gJ3RleHRhcmVhJyAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnICYmIHByb3BzLm11bHRpcGxlKSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4nLCB0eXBlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIGFsbG93ZWQgYXR0cmlidXRlIGxpc3QsIGJlIHN1cmUgdG9cbi8vIGFsc28gYWRkIHRoZW0gdG8gdGhpcyBtb2R1bGUgdG8gZW5zdXJlIGNhc2luZyBhbmQgaW5jb3JyZWN0IG5hbWVcbi8vIHdhcm5pbmdzLlxudmFyIHBvc3NpYmxlU3RhbmRhcmROYW1lcyA9IHtcbiAgLy8gSFRNTFxuICBhY2NlcHQ6ICdhY2NlcHQnLFxuICBhY2NlcHRjaGFyc2V0OiAnYWNjZXB0Q2hhcnNldCcsXG4gICdhY2NlcHQtY2hhcnNldCc6ICdhY2NlcHRDaGFyc2V0JyxcbiAgYWNjZXNza2V5OiAnYWNjZXNzS2V5JyxcbiAgYWN0aW9uOiAnYWN0aW9uJyxcbiAgYWxsb3dmdWxsc2NyZWVuOiAnYWxsb3dGdWxsU2NyZWVuJyxcbiAgYWx0OiAnYWx0JyxcbiAgYXM6ICdhcycsXG4gIGFzeW5jOiAnYXN5bmMnLFxuICBhdXRvY2FwaXRhbGl6ZTogJ2F1dG9DYXBpdGFsaXplJyxcbiAgYXV0b2NvbXBsZXRlOiAnYXV0b0NvbXBsZXRlJyxcbiAgYXV0b2NvcnJlY3Q6ICdhdXRvQ29ycmVjdCcsXG4gIGF1dG9mb2N1czogJ2F1dG9Gb2N1cycsXG4gIGF1dG9wbGF5OiAnYXV0b1BsYXknLFxuICBhdXRvc2F2ZTogJ2F1dG9TYXZlJyxcbiAgY2FwdHVyZTogJ2NhcHR1cmUnLFxuICBjZWxscGFkZGluZzogJ2NlbGxQYWRkaW5nJyxcbiAgY2VsbHNwYWNpbmc6ICdjZWxsU3BhY2luZycsXG4gIGNoYWxsZW5nZTogJ2NoYWxsZW5nZScsXG4gIGNoYXJzZXQ6ICdjaGFyU2V0JyxcbiAgY2hlY2tlZDogJ2NoZWNrZWQnLFxuICBjaGlsZHJlbjogJ2NoaWxkcmVuJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjbGFzczogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gIGRlZmF1bHQ6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZGlzYWJsZXBpY3R1cmVpbnBpY3R1cmU6ICdkaXNhYmxlUGljdHVyZUluUGljdHVyZScsXG4gIGRpc2FibGVyZW1vdGVwbGF5YmFjazogJ2Rpc2FibGVSZW1vdGVQbGF5YmFjaycsXG4gIGRvd25sb2FkOiAnZG93bmxvYWQnLFxuICBkcmFnZ2FibGU6ICdkcmFnZ2FibGUnLFxuICBlbmN0eXBlOiAnZW5jVHlwZScsXG4gIGVudGVya2V5aGludDogJ2VudGVyS2V5SGludCcsXG4gIGZvcjogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub21vZHVsZTogJ25vTW9kdWxlJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcbiAgLy8gU1ZHXG4gIGFib3V0OiAnYWJvdXQnLFxuICBhY2NlbnRoZWlnaHQ6ICdhY2NlbnRIZWlnaHQnLFxuICAnYWNjZW50LWhlaWdodCc6ICdhY2NlbnRIZWlnaHQnLFxuICBhY2N1bXVsYXRlOiAnYWNjdW11bGF0ZScsXG4gIGFkZGl0aXZlOiAnYWRkaXRpdmUnLFxuICBhbGlnbm1lbnRiYXNlbGluZTogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgJ2FsaWdubWVudC1iYXNlbGluZSc6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gIGFsbG93cmVvcmRlcjogJ2FsbG93UmVvcmRlcicsXG4gIGFscGhhYmV0aWM6ICdhbHBoYWJldGljJyxcbiAgYW1wbGl0dWRlOiAnYW1wbGl0dWRlJyxcbiAgYXJhYmljZm9ybTogJ2FyYWJpY0Zvcm0nLFxuICAnYXJhYmljLWZvcm0nOiAnYXJhYmljRm9ybScsXG4gIGFzY2VudDogJ2FzY2VudCcsXG4gIGF0dHJpYnV0ZW5hbWU6ICdhdHRyaWJ1dGVOYW1lJyxcbiAgYXR0cmlidXRldHlwZTogJ2F0dHJpYnV0ZVR5cGUnLFxuICBhdXRvcmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgYXppbXV0aDogJ2F6aW11dGgnLFxuICBiYXNlZnJlcXVlbmN5OiAnYmFzZUZyZXF1ZW5jeScsXG4gIGJhc2VsaW5lc2hpZnQ6ICdiYXNlbGluZVNoaWZ0JyxcbiAgJ2Jhc2VsaW5lLXNoaWZ0JzogJ2Jhc2VsaW5lU2hpZnQnLFxuICBiYXNlcHJvZmlsZTogJ2Jhc2VQcm9maWxlJyxcbiAgYmJveDogJ2Jib3gnLFxuICBiZWdpbjogJ2JlZ2luJyxcbiAgYmlhczogJ2JpYXMnLFxuICBieTogJ2J5JyxcbiAgY2FsY21vZGU6ICdjYWxjTW9kZScsXG4gIGNhcGhlaWdodDogJ2NhcEhlaWdodCcsXG4gICdjYXAtaGVpZ2h0JzogJ2NhcEhlaWdodCcsXG4gIGNsaXA6ICdjbGlwJyxcbiAgY2xpcHBhdGg6ICdjbGlwUGF0aCcsXG4gICdjbGlwLXBhdGgnOiAnY2xpcFBhdGgnLFxuICBjbGlwcGF0aHVuaXRzOiAnY2xpcFBhdGhVbml0cycsXG4gIGNsaXBydWxlOiAnY2xpcFJ1bGUnLFxuICAnY2xpcC1ydWxlJzogJ2NsaXBSdWxlJyxcbiAgY29sb3I6ICdjb2xvcicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbjogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uJzogJ2NvbG9ySW50ZXJwb2xhdGlvbicsXG4gIGNvbG9yaW50ZXJwb2xhdGlvbmZpbHRlcnM6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyc6ICdjb2xvckludGVycG9sYXRpb25GaWx0ZXJzJyxcbiAgY29sb3Jwcm9maWxlOiAnY29sb3JQcm9maWxlJyxcbiAgJ2NvbG9yLXByb2ZpbGUnOiAnY29sb3JQcm9maWxlJyxcbiAgY29sb3JyZW5kZXJpbmc6ICdjb2xvclJlbmRlcmluZycsXG4gICdjb2xvci1yZW5kZXJpbmcnOiAnY29sb3JSZW5kZXJpbmcnLFxuICBjb250ZW50c2NyaXB0dHlwZTogJ2NvbnRlbnRTY3JpcHRUeXBlJyxcbiAgY29udGVudHN0eWxldHlwZTogJ2NvbnRlbnRTdHlsZVR5cGUnLFxuICBjdXJzb3I6ICdjdXJzb3InLFxuICBjeDogJ2N4JyxcbiAgY3k6ICdjeScsXG4gIGQ6ICdkJyxcbiAgZGF0YXR5cGU6ICdkYXRhdHlwZScsXG4gIGRlY2VsZXJhdGU6ICdkZWNlbGVyYXRlJyxcbiAgZGVzY2VudDogJ2Rlc2NlbnQnLFxuICBkaWZmdXNlY29uc3RhbnQ6ICdkaWZmdXNlQ29uc3RhbnQnLFxuICBkaXJlY3Rpb246ICdkaXJlY3Rpb24nLFxuICBkaXNwbGF5OiAnZGlzcGxheScsXG4gIGRpdmlzb3I6ICdkaXZpc29yJyxcbiAgZG9taW5hbnRiYXNlbGluZTogJ2RvbWluYW50QmFzZWxpbmUnLFxuICAnZG9taW5hbnQtYmFzZWxpbmUnOiAnZG9taW5hbnRCYXNlbGluZScsXG4gIGR1cjogJ2R1cicsXG4gIGR4OiAnZHgnLFxuICBkeTogJ2R5JyxcbiAgZWRnZW1vZGU6ICdlZGdlTW9kZScsXG4gIGVsZXZhdGlvbjogJ2VsZXZhdGlvbicsXG4gIGVuYWJsZWJhY2tncm91bmQ6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgJ2VuYWJsZS1iYWNrZ3JvdW5kJzogJ2VuYWJsZUJhY2tncm91bmQnLFxuICBlbmQ6ICdlbmQnLFxuICBleHBvbmVudDogJ2V4cG9uZW50JyxcbiAgZXh0ZXJuYWxyZXNvdXJjZXNyZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICBmaWxsOiAnZmlsbCcsXG4gIGZpbGxvcGFjaXR5OiAnZmlsbE9wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgZmlsbHJ1bGU6ICdmaWxsUnVsZScsXG4gICdmaWxsLXJ1bGUnOiAnZmlsbFJ1bGUnLFxuICBmaWx0ZXI6ICdmaWx0ZXInLFxuICBmaWx0ZXJyZXM6ICdmaWx0ZXJSZXMnLFxuICBmaWx0ZXJ1bml0czogJ2ZpbHRlclVuaXRzJyxcbiAgZmxvb2RvcGFjaXR5OiAnZmxvb2RPcGFjaXR5JyxcbiAgJ2Zsb29kLW9wYWNpdHknOiAnZmxvb2RPcGFjaXR5JyxcbiAgZmxvb2Rjb2xvcjogJ2Zsb29kQ29sb3InLFxuICAnZmxvb2QtY29sb3InOiAnZmxvb2RDb2xvcicsXG4gIGZvY3VzYWJsZTogJ2ZvY3VzYWJsZScsXG4gIGZvbnRmYW1pbHk6ICdmb250RmFtaWx5JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICBmb250c2l6ZTogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc2l6ZSc6ICdmb250U2l6ZScsXG4gIGZvbnRzaXplYWRqdXN0OiAnZm9udFNpemVBZGp1c3QnLFxuICAnZm9udC1zaXplLWFkanVzdCc6ICdmb250U2l6ZUFkanVzdCcsXG4gIGZvbnRzdHJldGNoOiAnZm9udFN0cmV0Y2gnLFxuICAnZm9udC1zdHJldGNoJzogJ2ZvbnRTdHJldGNoJyxcbiAgZm9udHN0eWxlOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgZm9udHZhcmlhbnQ6ICdmb250VmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQnOiAnZm9udFZhcmlhbnQnLFxuICBmb250d2VpZ2h0OiAnZm9udFdlaWdodCcsXG4gICdmb250LXdlaWdodCc6ICdmb250V2VpZ2h0JyxcbiAgZm9ybWF0OiAnZm9ybWF0JyxcbiAgZnJvbTogJ2Zyb20nLFxuICBmeDogJ2Z4JyxcbiAgZnk6ICdmeScsXG4gIGcxOiAnZzEnLFxuICBnMjogJ2cyJyxcbiAgZ2x5cGhuYW1lOiAnZ2x5cGhOYW1lJyxcbiAgJ2dseXBoLW5hbWUnOiAnZ2x5cGhOYW1lJyxcbiAgZ2x5cGhvcmllbnRhdGlvbmhvcml6b250YWw6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsJzogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgZ2x5cGhvcmllbnRhdGlvbnZlcnRpY2FsOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsJzogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gIGdseXBocmVmOiAnZ2x5cGhSZWYnLFxuICBncmFkaWVudHRyYW5zZm9ybTogJ2dyYWRpZW50VHJhbnNmb3JtJyxcbiAgZ3JhZGllbnR1bml0czogJ2dyYWRpZW50VW5pdHMnLFxuICBoYW5naW5nOiAnaGFuZ2luZycsXG4gIGhvcml6YWR2eDogJ2hvcml6QWR2WCcsXG4gICdob3Jpei1hZHYteCc6ICdob3JpekFkdlgnLFxuICBob3Jpem9yaWdpbng6ICdob3Jpek9yaWdpblgnLFxuICAnaG9yaXotb3JpZ2luLXgnOiAnaG9yaXpPcmlnaW5YJyxcbiAgaWRlb2dyYXBoaWM6ICdpZGVvZ3JhcGhpYycsXG4gIGltYWdlcmVuZGVyaW5nOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICAnaW1hZ2UtcmVuZGVyaW5nJzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgaW4yOiAnaW4yJyxcbiAgaW46ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gIHR5cGVvZjogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG52YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9O1xuICB2YXIgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uLi87XG4gIHZhciBJTlZBTElEX0VWRU5UX05BTUVfUkVHRVggPSAvXm9uW15BLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUsIGV2ZW50UmVnaXN0cnkpIHtcbiAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcyQxLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgZXJyb3IoJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIFdlIGNhbid0IHJlbHkgb24gdGhlIGV2ZW50IHN5c3RlbSBiZWluZyBpbmplY3RlZCBvbiB0aGUgc2VydmVyLlxuXG5cbiAgICBpZiAoZXZlbnRSZWdpc3RyeSAhPSBudWxsKSB7XG4gICAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IGV2ZW50UmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyxcbiAgICAgICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0gZXZlbnRSZWdpc3RyeS5wb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzO1xuXG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgIT0gbnVsbCkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPycsIG5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLicsIG5hbWUpO1xuXG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgYXJlIGluIGEgc2VydmVyIGVudmlyb25tZW50LlxuICAgICAgLy8gU28gd2UgY2FuJ3QgdGVsbCBpZiB0aGUgZXZlbnQgbmFtZSBpcyBjb3JyZWN0IGZvciBzdXJlLCBidXQgd2UgY2FuIGZpbHRlclxuICAgICAgLy8gb3V0IGtub3duIGJhZCBvbmVzIGxpa2UgYG9uY2xpY2tgLiBXZSBjYW4ndCBzdWdnZXN0IGEgc3BlY2lmaWMgcmVwbGFjZW1lbnQgdGhvdWdoLlxuICAgICAgaWYgKElOVkFMSURfRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gJyArICdSZWFjdCBldmVudHMgdXNlIHRoZSBjYW1lbENhc2UgbmFtaW5nIGNvbnZlbnRpb24sIGZvciBleGFtcGxlIGBvbkNsaWNrYC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuXG5cbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICBlcnJvcignRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIGVycm9yKCdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4nLCB0eXBlb2YgdmFsdWUpO1xuXG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJywgbmFtZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICAgIHZhciBpc1Jlc2VydmVkID0gcHJvcGVydHlJbmZvICE9PSBudWxsICYmIHByb3BlcnR5SW5mby50eXBlID09PSBSRVNFUlZFRDsgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cblxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcblxuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICBlcnJvcignSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JywgbmFtZSwgc3RhbmRhcmROYW1lKTtcblxuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIGVycm9yKCdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LicsIG5hbWUsIGxvd2VyQ2FzZWROYW1lKTtcblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiBzaG91bGRSZW1vdmVBdHRyaWJ1dGVXaXRoV2FybmluZyhuYW1lLCB2YWx1ZSwgcHJvcGVydHlJbmZvLCBmYWxzZSkpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LicsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcblxuXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcblxuXG4gICAgaWYgKHNob3VsZFJlbW92ZUF0dHJpYnV0ZVdpdGhXYXJuaW5nKG5hbWUsIHZhbHVlLCBwcm9wZXJ0eUluZm8sIGZhbHNlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFdhcm4gd2hlbiBwYXNzaW5nIHRoZSBzdHJpbmdzICdmYWxzZScgb3IgJ3RydWUnIGludG8gYSBib29sZWFuIHByb3BcblxuXG4gICAgaWYgKCh2YWx1ZSA9PT0gJ2ZhbHNlJyB8fCB2YWx1ZSA9PT0gJ3RydWUnKSAmJiBwcm9wZXJ0eUluZm8gIT09IG51bGwgJiYgcHJvcGVydHlJbmZvLnR5cGUgPT09IEJPT0xFQU4pIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCB0aGUgc3RyaW5nIGAlc2AgZm9yIHRoZSBib29sZWFuIGF0dHJpYnV0ZSBgJXNgLiAnICsgJyVzICcgKyAnRGlkIHlvdSBtZWFuICVzPXslc30/JywgdmFsdWUsIG5hbWUsIHZhbHVlID09PSAnZmFsc2UnID8gJ1RoZSBicm93c2VyIHdpbGwgaW50ZXJwcmV0IGl0IGFzIGEgdHJ1dGh5IHZhbHVlLicgOiAnQWx0aG91Z2ggdGhpcyB3b3JrcywgaXQgd2lsbCBub3Qgd29yayBhcyBleHBlY3RlZCBpZiB5b3UgcGFzcyB0aGUgc3RyaW5nIFwiZmFsc2VcIi4nLCBuYW1lLCB2YWx1ZSk7XG5cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgZXZlbnRSZWdpc3RyeSkge1xuICB7XG4gICAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGV2ZW50UmVnaXN0cnkpO1xuXG4gICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgICB9KS5qb2luKCcsICcpO1xuXG4gICAgaWYgKHVua25vd25Qcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2F0dHJpYnV0ZS1iZWhhdmlvciAnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSk7XG4gICAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgICAgZXJyb3IoJ0ludmFsaWQgdmFsdWVzIGZvciBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gRWl0aGVyIHJlbW92ZSB0aGVtIGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCB0aGVtIGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvYXR0cmlidXRlLWJlaGF2aW9yICcsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBldmVudFJlZ2lzdHJ5KSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGV2ZW50UmVnaXN0cnkpO1xufVxuXG52YXIgdG9BcnJheSA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXk7IC8vIFRoaXMgaXMgb25seSB1c2VkIGluIERFVi5cbi8vIEVhY2ggZW50cnkgaXMgYHRoaXMuc3RhY2tgIGZyb20gYSBjdXJyZW50bHkgZXhlY3V0aW5nIHJlbmRlcmVyIGluc3RhbmNlLlxuLy8gKFRoZXJlIG1heSBiZSBtb3JlIHRoYW4gb25lIGJlY2F1c2UgUmVhY3RET01TZXJ2ZXIgaXMgcmVlbnRyYW50KS5cbi8vIEVhY2ggc3RhY2sgaXMgYW4gYXJyYXkgb2YgZnJhbWVzIHdoaWNoIG1heSBjb250YWluIG5lc3RlZCBzdGFja3Mgb2YgZWxlbWVudHMuXG5cbnZhciBjdXJyZW50RGVidWdTdGFja3MgPSBbXTtcbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMTtcbnZhciBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCA9IG51bGw7XG5cbnZhciBnZXRDdXJyZW50U2VydmVyU3RhY2tJbXBsID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJyc7XG59O1xuXG52YXIgZGVzY3JpYmVTdGFja0ZyYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgcmV0dXJuICcnO1xufTtcblxudmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHt9O1xuXG52YXIgcHVzaEN1cnJlbnREZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKHN0YWNrKSB7fTtcblxudmFyIHB1c2hFbGVtZW50VG9EZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKGVsZW1lbnQpIHt9O1xuXG52YXIgcG9wQ3VycmVudERlYnVnU3RhY2sgPSBmdW5jdGlvbiAoKSB7fTtcblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdDb250ZXh0QXNDb25zdW1lciA9IGZhbHNlO1xuXG57XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbiAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzLCBudWxsKTtcbiAgfTtcblxuICBkZXNjcmliZVN0YWNrRnJhbWUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG51bGwpO1xuICB9O1xuXG4gIHB1c2hDdXJyZW50RGVidWdTdGFjayA9IGZ1bmN0aW9uIChzdGFjaykge1xuICAgIGN1cnJlbnREZWJ1Z1N0YWNrcy5wdXNoKHN0YWNrKTtcblxuICAgIGlmIChjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBXZSBhcmUgZW50ZXJpbmcgYSBzZXJ2ZXIgcmVuZGVyZXIuXG4gICAgICAvLyBSZW1lbWJlciB0aGUgcHJldmlvdXMgKGUuZy4gY2xpZW50KSBnbG9iYWwgc3RhY2sgaW1wbGVtZW50YXRpb24uXG4gICAgICBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5nZXRDdXJyZW50U3RhY2s7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0Q3VycmVudFN0YWNrID0gZ2V0Q3VycmVudFNlcnZlclN0YWNrSW1wbDtcbiAgICB9XG4gIH07XG5cbiAgcHVzaEVsZW1lbnRUb0RlYnVnU3RhY2sgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIC8vIEZvciB0aGUgaW5uZXJtb3N0IGV4ZWN1dGluZyBSZWFjdERPTVNlcnZlciBjYWxsLFxuICAgIHZhciBzdGFjayA9IGN1cnJlbnREZWJ1Z1N0YWNrc1tjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoIC0gMV07IC8vIFRha2UgdGhlIGlubmVybW9zdCBleGVjdXRpbmcgZnJhbWUgKGUuZy4gPEZvbz4pLFxuXG4gICAgdmFyIGZyYW1lID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07IC8vIGFuZCByZWNvcmQgdGhhdCBpdCBoYXMgb25lIG1vcmUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggaXQuXG5cbiAgICBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjay5wdXNoKGVsZW1lbnQpOyAvLyBXZSBvbmx5IG5lZWQgdGhpcyBiZWNhdXNlIHdlIHRhaWwtb3B0aW1pemUgc2luZ2xlLWVsZW1lbnRcbiAgICAvLyBjaGlsZHJlbiBhbmQgZGlyZWN0bHkgaGFuZGxlIHRoZW0gaW4gYW4gaW5uZXIgbG9vcCBpbnN0ZWFkIG9mXG4gICAgLy8gY3JlYXRpbmcgc2VwYXJhdGUgZnJhbWVzIGZvciB0aGVtLlxuICB9O1xuXG4gIHBvcEN1cnJlbnREZWJ1Z1N0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnREZWJ1Z1N0YWNrcy5wb3AoKTtcblxuICAgIGlmIChjdXJyZW50RGVidWdTdGFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBXZSBhcmUgZXhpdGluZyB0aGUgc2VydmVyIHJlbmRlcmVyLlxuICAgICAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgKGUuZy4gY2xpZW50KSBnbG9iYWwgc3RhY2sgaW1wbGVtZW50YXRpb24uXG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFja0ltcGw7XG4gICAgICBwcmV2R2V0Q3VycmVudFN0YWNrSW1wbCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGdldEN1cnJlbnRTZXJ2ZXJTdGFja0ltcGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGN1cnJlbnREZWJ1Z1N0YWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vdGhpbmcgaXMgY3VycmVudGx5IHJlbmRlcmluZy5cbiAgICAgIHJldHVybiAnJztcbiAgICB9IC8vIFJlYWN0RE9NU2VydmVyIGlzIHJlZW50cmFudCBzbyB0aGVyZSBtYXkgYmUgbXVsdGlwbGUgY2FsbHMgYXQgdGhlIHNhbWUgdGltZS5cbiAgICAvLyBUYWtlIHRoZSBmcmFtZXMgZnJvbSB0aGUgaW5uZXJtb3N0IGNhbGwgd2hpY2ggaXMgdGhlIGxhc3QgaW4gdGhlIGFycmF5LlxuXG5cbiAgICB2YXIgZnJhbWVzID0gY3VycmVudERlYnVnU3RhY2tzW2N1cnJlbnREZWJ1Z1N0YWNrcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgc3RhY2sgPSAnJzsgLy8gR28gdGhyb3VnaCBldmVyeSBmcmFtZSBpbiB0aGUgc3RhY2sgZnJvbSB0aGUgaW5uZXJtb3N0IG9uZS5cblxuICAgIGZvciAodmFyIGkgPSBmcmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmcmFtZSA9IGZyYW1lc1tpXTsgLy8gRXZlcnkgZnJhbWUgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGRlYnVnIGVsZW1lbnQgc3RhY2sgZW50cnkgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHNpbmdsZS1jaGlsZCBuZXN0aW5nIGRvZXNuJ3QgY3JlYXRlIG1hdGVyaWFsaXplZCBmcmFtZXMuXG4gICAgICAvLyBJbnN0ZWFkIGl0IHdvdWxkIHB1c2ggdGhlbSB0aHJvdWdoIGBwdXNoRWxlbWVudFRvRGVidWdTdGFjaygpYC5cblxuICAgICAgdmFyIGRlYnVnRWxlbWVudFN0YWNrID0gZnJhbWUuZGVidWdFbGVtZW50U3RhY2s7XG5cbiAgICAgIGZvciAodmFyIGlpID0gZGVidWdFbGVtZW50U3RhY2subGVuZ3RoIC0gMTsgaWkgPj0gMDsgaWktLSkge1xuICAgICAgICBzdGFjayArPSBkZXNjcmliZVN0YWNrRnJhbWUoZGVidWdFbGVtZW50U3RhY2tbaWldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG59XG5cbnZhciBkaWRXYXJuRGVmYXVsdElucHV0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuRGVmYXVsdENoZWNrZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkludmFsaWRPcHRpb25DaGlsZHJlbiA9IGZhbHNlO1xudmFyIGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xudmFyIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnQgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXREZXByZWNhdGVkV2lsbE1vdW50ID0ge307XG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlID0ge307XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0ge307XG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xudmFyIG5ld2xpbmVFYXRpbmdUYWdzID0ge1xuICBsaXN0aW5nOiB0cnVlLFxuICBwcmU6IHRydWUsXG4gIHRleHRhcmVhOiB0cnVlXG59OyAvLyBXZSBhY2NlcHQgYW55IHRhZyB0byBiZSByZW5kZXJlZCBidXQgc2luY2UgdGhpcyBnZXRzIGluamVjdGVkIGludG8gYXJiaXRyYXJ5XG4vLyBIVE1MLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IGl0J3MgYSBzYWZlIHRhZy5cbi8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1JFQy14bWwvI05ULU5hbWVcblxudmFyIFZBTElEX1RBR19SRUdFWCA9IC9eW2EtekEtWl1bYS16QS1aOl9cXC5cXC1cXGRdKiQvOyAvLyBTaW1wbGlmaWVkIHN1YnNldFxuXG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcblxuZnVuY3Rpb24gdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKSB7XG4gIGlmICghdmFsaWRhdGVkVGFnQ2FjaGUuaGFzT3duUHJvcGVydHkodGFnKSkge1xuICAgIGlmICghVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSkge1xuICAgICAge1xuICAgICAgICB0aHJvdyBFcnJvciggXCJJbnZhbGlkIHRhZzogXCIgKyB0YWcgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZWRUYWdDYWNoZVt0YWddID0gdHJ1ZTtcbiAgfVxufVxuXG52YXIgc3R5bGVOYW1lQ2FjaGUgPSB7fTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSBmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gIGlmIChzdHlsZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgcmV0dXJuIHN0eWxlTmFtZUNhY2hlW3N0eWxlTmFtZV07XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSk7XG4gIHN0eWxlTmFtZUNhY2hlW3N0eWxlTmFtZV0gPSByZXN1bHQ7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVNYXJrdXBGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHZhciBzZXJpYWxpemVkID0gJyc7XG4gIHZhciBkZWxpbWl0ZXIgPSAnJztcblxuICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICB2YXIgc3R5bGVWYWx1ZSA9IHN0eWxlc1tzdHlsZU5hbWVdO1xuXG4gICAge1xuICAgICAgaWYgKCFpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlJDEoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBzZXJpYWxpemVkICs9IGRlbGltaXRlciArIChpc0N1c3RvbVByb3BlcnR5ID8gc3R5bGVOYW1lIDogcHJvY2Vzc1N0eWxlTmFtZShzdHlsZU5hbWUpKSArICc6JztcbiAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG59XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgX2NvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBfY29uc3RydWN0b3IgJiYgZ2V0Q29tcG9uZW50TmFtZShfY29uc3RydWN0b3IpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuXG4gICAgaWYgKGRpZFdhcm5BYm91dE5vb3BVcGRhdGVGb3JDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlcnJvcignJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb3V0c2lkZSBjb21wb25lbnRXaWxsTW91bnQoKSBvbiB0aGUgc2VydmVyLiAnICsgJ1RoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICBkaWRXYXJuQWJvdXROb29wVXBkYXRlRm9yQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QkMShDb21wb25lbnQpIHtcbiAgcmV0dXJuIENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBnZXROb25DaGlsZHJlbklubmVyTWFya3VwKHByb3BzKSB7XG4gIHZhciBpbm5lckhUTUwgPSBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblxuICBpZiAoaW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gaW5uZXJIVE1MLl9faHRtbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvbnRlbnQgPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNvbnRlbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gZXNjYXBlVGV4dEZvckJyb3dzZXIoY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5Ub3BMZXZlbENoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGlmICghUmVhY3QuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoY2hpbGRyZW4pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjaGlsZHJlbjtcblxuICBpZiAoZWxlbWVudC50eXBlICE9PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgcmV0dXJuIFtlbGVtZW50XTtcbiAgfVxuXG4gIHZhciBmcmFnbWVudENoaWxkcmVuID0gZWxlbWVudC5wcm9wcy5jaGlsZHJlbjtcblxuICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGZyYWdtZW50Q2hpbGRyZW4pKSB7XG4gICAgcmV0dXJuIHRvQXJyYXkoZnJhZ21lbnRDaGlsZHJlbik7XG4gIH1cblxuICB2YXIgZnJhZ21lbnRDaGlsZEVsZW1lbnQgPSBmcmFnbWVudENoaWxkcmVuO1xuICByZXR1cm4gW2ZyYWdtZW50Q2hpbGRFbGVtZW50XTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbk9wdGlvbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbiA9PT0gdW5kZWZpbmVkIHx8IGNoaWxkcmVuID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG5cbiAgdmFyIGNvbnRlbnQgPSAnJzsgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb250ZW50ICs9IGNoaWxkO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuICYmIHR5cGVvZiBjaGlsZCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGNoaWxkICE9PSAnbnVtYmVyJykge1xuICAgICAgICBkaWRXYXJuSW52YWxpZE9wdGlvbkNoaWxkcmVuID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignT25seSBzdHJpbmdzIGFuZCBudW1iZXJzIGFyZSBzdXBwb3J0ZWQgYXMgPG9wdGlvbj4gY2hpbGRyZW4uJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSQyID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBTVFlMRSA9ICdzdHlsZSc7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiBudWxsLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogbnVsbCxcbiAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiBudWxsLFxuICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IG51bGxcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZU9wZW5UYWdNYXJrdXAodGFnVmVyYmF0aW0sIHRhZ0xvd2VyY2FzZSwgcHJvcHMsIG5hbWVzcGFjZSwgbWFrZVN0YXRpY01hcmt1cCwgaXNSb290RWxlbWVudCkge1xuICB2YXIgcmV0ID0gJzwnICsgdGFnVmVyYmF0aW07XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudCQxID0gaXNDdXN0b21Db21wb25lbnQodGFnTG93ZXJjYXNlLCBwcm9wcyk7XG5cbiAgZm9yICh2YXIgcHJvcEtleSBpbiBwcm9wcykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkkMi5jYWxsKHByb3BzLCBwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuXG4gICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHByb3BWYWx1ZSA9IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUpO1xuICAgIH1cblxuICAgIHZhciBtYXJrdXAgPSBudWxsO1xuXG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50JDEpIHtcbiAgICAgIGlmICghUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgbWFya3VwID0gY3JlYXRlTWFya3VwRm9yQ3VzdG9tQXR0cmlidXRlKHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmt1cCA9IGNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKG1hcmt1cCkge1xuICAgICAgcmV0ICs9ICcgJyArIG1hcmt1cDtcbiAgICB9XG4gIH0gLy8gRm9yIHN0YXRpYyBwYWdlcywgbm8gbmVlZCB0byBwdXQgUmVhY3QgSUQgYW5kIGNoZWNrc3VtLiBTYXZlcyBsb3RzIG9mXG4gIC8vIGJ5dGVzLlxuXG5cbiAgaWYgKG1ha2VTdGF0aWNNYXJrdXApIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgaWYgKGlzUm9vdEVsZW1lbnQpIHtcbiAgICByZXQgKz0gJyAnICsgY3JlYXRlTWFya3VwRm9yUm9vdCgpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZW5kZXJSZXN1bHQoY2hpbGQsIHR5cGUpIHtcbiAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICB7XG4gICAgICB7XG4gICAgICAgIHRocm93IEVycm9yKCAoZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB8fCAnQ29tcG9uZW50JykgKyBcIiguLi4pOiBOb3RoaW5nIHdhcyByZXR1cm5lZCBmcm9tIHJlbmRlci4gVGhpcyB1c3VhbGx5IG1lYW5zIGEgcmV0dXJuIHN0YXRlbWVudCBpcyBtaXNzaW5nLiBPciwgdG8gcmVuZGVyIG5vdGhpbmcsIHJldHVybiBudWxsLlwiICk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUoY2hpbGQsIGNvbnRleHQsIHRocmVhZElEKSB7XG4gIHdoaWxlIChSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAvLyBTYWZlIGJlY2F1c2Ugd2UganVzdCBjaGVja2VkIGl0J3MgYW4gZWxlbWVudC5cbiAgICB2YXIgZWxlbWVudCA9IGNoaWxkO1xuICAgIHZhciBDb21wb25lbnQgPSBlbGVtZW50LnR5cGU7XG5cbiAgICB7XG4gICAgICBwdXNoRWxlbWVudFRvRGVidWdTdGFjayhlbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcHJvY2Vzc0NoaWxkKGVsZW1lbnQsIENvbXBvbmVudCk7XG4gIH0gLy8gRXh0cmEgY2xvc3VyZSBzbyBxdWV1ZSBhbmQgcmVwbGFjZSBjYW4gYmUgY2FwdHVyZWQgcHJvcGVybHlcblxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NDaGlsZChlbGVtZW50LCBDb21wb25lbnQpIHtcbiAgICB2YXIgaXNDbGFzcyA9IHNob3VsZENvbnN0cnVjdCQxKENvbXBvbmVudCk7XG4gICAgdmFyIHB1YmxpY0NvbnRleHQgPSBwcm9jZXNzQ29udGV4dChDb21wb25lbnQsIGNvbnRleHQsIHRocmVhZElELCBpc0NsYXNzKTtcbiAgICB2YXIgcXVldWUgPSBbXTtcbiAgICB2YXIgcmVwbGFjZSA9IGZhbHNlO1xuICAgIHZhciB1cGRhdGVyID0ge1xuICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgICAgIGlmIChxdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgICAgICByZXBsYWNlID0gdHJ1ZTtcbiAgICAgICAgcXVldWUgPSBbY29tcGxldGVTdGF0ZV07XG4gICAgICB9LFxuICAgICAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGN1cnJlbnRQYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgaWYgKHF1ZXVlID09PSBudWxsKSB7XG4gICAgICAgICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcXVldWUucHVzaChjdXJyZW50UGFydGlhbFN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpbnN0O1xuXG4gICAgaWYgKGlzQ2xhc3MpIHtcbiAgICAgIGluc3QgPSBuZXcgQ29tcG9uZW50KGVsZW1lbnQucHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZXIpO1xuXG4gICAgICBpZiAodHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChpbnN0LnN0YXRlID09PSBudWxsIHx8IGluc3Quc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZVtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgICAgICBlcnJvcignYCVzYCB1c2VzIGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGJ1dCBpdHMgaW5pdGlhbCBzdGF0ZSBpcyAnICsgJyVzLiBUaGlzIGlzIG5vdCByZWNvbW1lbmRlZC4gSW5zdGVhZCwgZGVmaW5lIHRoZSBpbml0aWFsIHN0YXRlIGJ5ICcgKyAnYXNzaWduaW5nIGFuIG9iamVjdCB0byBgdGhpcy5zdGF0ZWAgaW4gdGhlIGNvbnN0cnVjdG9yIG9mIGAlc2AuICcgKyAnVGhpcyBlbnN1cmVzIHRoYXQgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYXJndW1lbnRzIGhhdmUgYSBjb25zaXN0ZW50IHNoYXBlLicsIGNvbXBvbmVudE5hbWUsIGluc3Quc3RhdGUgPT09IG51bGwgPyAnbnVsbCcgOiAndW5kZWZpbmVkJywgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFydGlhbFN0YXRlID0gQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy5jYWxsKG51bGwsIGVsZW1lbnQucHJvcHMsIGluc3Quc3RhdGUpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocGFydGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlW19jb21wb25lbnROYW1lXSkge1xuICAgICAgICAgICAgICBlcnJvcignJXMuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCk6IEEgdmFsaWQgc3RhdGUgb2JqZWN0IChvciBudWxsKSBtdXN0IGJlIHJldHVybmVkLiAnICsgJ1lvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBfY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlW19jb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgaW5zdC5zdGF0ZSA9IF9hc3NpZ24oe30sIGluc3Quc3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBpZiAoQ29tcG9uZW50LnByb3RvdHlwZSAmJiB0eXBlb2YgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUyID0gZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0QmFkQ2xhc3NbX2NvbXBvbmVudE5hbWUyXSkge1xuICAgICAgICAgICAgZXJyb3IoXCJUaGUgPCVzIC8+IGNvbXBvbmVudCBhcHBlYXJzIHRvIGhhdmUgYSByZW5kZXIgbWV0aG9kLCBidXQgZG9lc24ndCBleHRlbmQgUmVhY3QuQ29tcG9uZW50LiBcIiArICdUaGlzIGlzIGxpa2VseSB0byBjYXVzZSBlcnJvcnMuIENoYW5nZSAlcyB0byBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGluc3RlYWQuJywgX2NvbXBvbmVudE5hbWUyLCBfY29tcG9uZW50TmFtZTIpO1xuXG4gICAgICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBvbmVudElkZW50aXR5ID0ge307XG4gICAgICBwcmVwYXJlVG9Vc2VIb29rcyhjb21wb25lbnRJZGVudGl0eSk7XG4gICAgICBpbnN0ID0gQ29tcG9uZW50KGVsZW1lbnQucHJvcHMsIHB1YmxpY0NvbnRleHQsIHVwZGF0ZXIpO1xuICAgICAgaW5zdCA9IGZpbmlzaEhvb2tzKENvbXBvbmVudCwgZWxlbWVudC5wcm9wcywgaW5zdCwgcHVibGljQ29udGV4dCk7XG5cbiAgICAgIHtcbiAgICAgICAgLy8gU3VwcG9ydCBmb3IgbW9kdWxlIGNvbXBvbmVudHMgaXMgZGVwcmVjYXRlZCBhbmQgaXMgcmVtb3ZlZCBiZWhpbmQgYSBmbGFnLlxuICAgICAgICAvLyBXaGV0aGVyIG9yIG5vdCBpdCB3b3VsZCBjcmFzaCBsYXRlciwgd2Ugd2FudCB0byBzaG93IGEgZ29vZCBtZXNzYWdlIGluIERFViBmaXJzdC5cbiAgICAgICAgaWYgKGluc3QgIT0gbnVsbCAmJiBpbnN0LnJlbmRlciAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9jb21wb25lbnROYW1lMyA9IGdldENvbXBvbmVudE5hbWUoQ29tcG9uZW50KSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSkge1xuICAgICAgICAgICAgZXJyb3IoJ1RoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdGhhdCByZXR1cm5zIGEgY2xhc3MgaW5zdGFuY2UuICcgKyAnQ2hhbmdlICVzIHRvIGEgY2xhc3MgdGhhdCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLiAnICsgXCJJZiB5b3UgY2FuJ3QgdXNlIGEgY2xhc3MgdHJ5IGFzc2lnbmluZyB0aGUgcHJvdG90eXBlIG9uIHRoZSBmdW5jdGlvbiBhcyBhIHdvcmthcm91bmQuIFwiICsgXCJgJXMucHJvdG90eXBlID0gUmVhY3QuQ29tcG9uZW50LnByb3RvdHlwZWAuIERvbid0IHVzZSBhbiBhcnJvdyBmdW5jdGlvbiBzaW5jZSBpdCBcIiArICdjYW5ub3QgYmUgY2FsbGVkIHdpdGggYG5ld2AgYnkgUmVhY3QuJywgX2NvbXBvbmVudE5hbWUzLCBfY29tcG9uZW50TmFtZTMsIF9jb21wb25lbnROYW1lMyk7XG5cbiAgICAgICAgICAgIGRpZFdhcm5BYm91dE1vZHVsZVBhdHRlcm5Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIElmIHRoZSBmbGFnIGlzIG9uLCBldmVyeXRoaW5nIGlzIGFzc3VtZWQgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQuXG4gICAgICAvLyBPdGhlcndpc2UsIHdlIGFsc28gZG8gdGhlIHVuZm9ydHVuYXRlIGR5bmFtaWMgY2hlY2tzLlxuXG5cbiAgICAgIGlmICggaW5zdCA9PSBudWxsIHx8IGluc3QucmVuZGVyID09IG51bGwpIHtcbiAgICAgICAgY2hpbGQgPSBpbnN0O1xuICAgICAgICB2YWxpZGF0ZVJlbmRlclJlc3VsdChjaGlsZCwgQ29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QucHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICAgIGluc3QuY29udGV4dCA9IHB1YmxpY0NvbnRleHQ7XG4gICAgaW5zdC51cGRhdGVyID0gdXBkYXRlcjtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdC5zdGF0ZTtcblxuICAgIGlmIChpbml0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5zdC5zdGF0ZSA9IGluaXRpYWxTdGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0LlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3QuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3QuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIGluc3QuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfY29tcG9uZW50TmFtZTQgPSBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnRbX2NvbXBvbmVudE5hbWU0XSkge1xuICAgICAgICAgICAgICB3YXJuKCAvLyBrZWVwIHRoaXMgd2FybmluZyBpbiBzeW5jIHdpdGggUmVhY3RTdHJpY3RNb2RlV2FybmluZy5qc1xuICAgICAgICAgICAgICAnY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBjb2RlIGZyb20gY29tcG9uZW50V2lsbE1vdW50IHRvIGNvbXBvbmVudERpZE1vdW50IChwcmVmZXJyZWQgaW4gbW9zdCBjYXNlcykgJyArICdvciB0aGUgY29uc3RydWN0b3IuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfY29tcG9uZW50TmFtZTQpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dERlcHJlY2F0ZWRXaWxsTW91bnRbX2NvbXBvbmVudE5hbWU0XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgICAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGFueSBjb21wb25lbnQgd2l0aCB0aGUgbmV3IGdEU0ZQLlxuXG5cbiAgICAgICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaW5zdC5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3QuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAgICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBhbnkgY29tcG9uZW50IHdpdGggdGhlIG5ldyBnRFNGUC5cbiAgICAgICAgaW5zdC5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG9sZFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHZhciBvbGRSZXBsYWNlID0gcmVwbGFjZTtcbiAgICAgICAgcXVldWUgPSBudWxsO1xuICAgICAgICByZXBsYWNlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKG9sZFJlcGxhY2UgJiYgb2xkUXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgaW5zdC5zdGF0ZSA9IG9sZFF1ZXVlWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSBvbGRSZXBsYWNlID8gb2xkUXVldWVbMF0gOiBpbnN0LnN0YXRlO1xuICAgICAgICAgIHZhciBkb250TXV0YXRlID0gdHJ1ZTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSBvbGRSZXBsYWNlID8gMSA6IDA7IGkgPCBvbGRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSBvbGRRdWV1ZVtpXTtcblxuICAgICAgICAgICAgdmFyIF9wYXJ0aWFsU3RhdGUgPSB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcnRpYWwuY2FsbChpbnN0LCBuZXh0U3RhdGUsIGVsZW1lbnQucHJvcHMsIHB1YmxpY0NvbnRleHQpIDogcGFydGlhbDtcblxuICAgICAgICAgICAgaWYgKF9wYXJ0aWFsU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoZG9udE11dGF0ZSkge1xuICAgICAgICAgICAgICAgIGRvbnRNdXRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXh0U3RhdGUgPSBfYXNzaWduKHt9LCBuZXh0U3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9hc3NpZ24obmV4dFN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGluc3Quc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjaGlsZCA9IGluc3QucmVuZGVyKCk7XG5cbiAgICB7XG4gICAgICBpZiAoY2hpbGQgPT09IHVuZGVmaW5lZCAmJiBpbnN0LnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgY2hpbGQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhbGlkYXRlUmVuZGVyUmVzdWx0KGNoaWxkLCBDb21wb25lbnQpO1xuICAgIHZhciBjaGlsZENvbnRleHQ7XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGluc3QuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBfY2hpbGRDb250ZXh0VHlwZXMgPSBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXM7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBfY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcblxuICAgICAgICAgIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoIShjb250ZXh0S2V5IGluIF9jaGlsZENvbnRleHRUeXBlcykpIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCAoZ2V0Q29tcG9uZW50TmFtZShDb21wb25lbnQpIHx8ICdVbmtub3duJykgKyBcIi5nZXRDaGlsZENvbnRleHQoKToga2V5IFxcXCJcIiArIGNvbnRleHRLZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgaW4gY2hpbGRDb250ZXh0VHlwZXMuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvcignJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBnZXRDb21wb25lbnROYW1lKENvbXBvbmVudCkgfHwgJ1Vua25vd24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoaWxkQ29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gX2Fzc2lnbih7fSwgY29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNoaWxkOiBjaGlsZCxcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH07XG59XG5cbnZhciBSZWFjdERPTVNlcnZlclJlbmRlcmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLy8gVE9ETzogdHlwZSB0aGlzIG1vcmUgc3RyaWN0bHk6XG4gIC8vIERFVi1vbmx5XG4gIGZ1bmN0aW9uIFJlYWN0RE9NU2VydmVyUmVuZGVyZXIoY2hpbGRyZW4sIG1ha2VTdGF0aWNNYXJrdXAsIG9wdGlvbnMpIHtcbiAgICB2YXIgZmxhdENoaWxkcmVuID0gZmxhdHRlblRvcExldmVsQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgIHZhciB0b3BGcmFtZSA9IHtcbiAgICAgIHR5cGU6IG51bGwsXG4gICAgICAvLyBBc3N1bWUgYWxsIHRyZWVzIHN0YXJ0IGluIHRoZSBIVE1MIG5hbWVzcGFjZSAobm90IHRvdGFsbHkgdHJ1ZSwgYnV0XG4gICAgICAvLyB0aGlzIGlzIHdoYXQgd2UgZGlkIGhpc3RvcmljYWxseSlcbiAgICAgIGRvbU5hbWVzcGFjZTogTmFtZXNwYWNlcy5odG1sLFxuICAgICAgY2hpbGRyZW46IGZsYXRDaGlsZHJlbixcbiAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICBjb250ZXh0OiBlbXB0eU9iamVjdCxcbiAgICAgIGZvb3RlcjogJydcbiAgICB9O1xuXG4gICAge1xuICAgICAgdG9wRnJhbWUuZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICB9XG5cbiAgICB0aGlzLnRocmVhZElEID0gYWxsb2NUaHJlYWRJRCgpO1xuICAgIHRoaXMuc3RhY2sgPSBbdG9wRnJhbWVdO1xuICAgIHRoaXMuZXhoYXVzdGVkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50U2VsZWN0VmFsdWUgPSBudWxsO1xuICAgIHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSA9IGZhbHNlO1xuICAgIHRoaXMubWFrZVN0YXRpY01hcmt1cCA9IG1ha2VTdGF0aWNNYXJrdXA7XG4gICAgdGhpcy5zdXNwZW5zZURlcHRoID0gMDsgLy8gQ29udGV4dCAobmV3IEFQSSlcblxuICAgIHRoaXMuY29udGV4dEluZGV4ID0gLTE7XG4gICAgdGhpcy5jb250ZXh0U3RhY2sgPSBbXTtcbiAgICB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrID0gW107IC8vIHVzZU9wYXF1ZUlkZW50aWZpZXIgSURcblxuICAgIHRoaXMudW5pcXVlSUQgPSAwO1xuICAgIHRoaXMuaWRlbnRpZmllclByZWZpeCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pZGVudGlmaWVyUHJlZml4IHx8ICcnO1xuXG4gICAge1xuICAgICAgdGhpcy5jb250ZXh0UHJvdmlkZXJTdGFjayA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBSZWFjdERPTVNlcnZlclJlbmRlcmVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLmV4aGF1c3RlZCkge1xuICAgICAgdGhpcy5leGhhdXN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5jbGVhclByb3ZpZGVycygpO1xuICAgICAgZnJlZVRocmVhZElEKHRoaXMudGhyZWFkSUQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogTm90ZTogV2UgdXNlIGp1c3QgdHdvIHN0YWNrcyByZWdhcmRsZXNzIG9mIGhvdyBtYW55IGNvbnRleHQgcHJvdmlkZXJzIHlvdSBoYXZlLlxuICAgKiBQcm92aWRlcnMgYXJlIGFsd2F5cyBwb3BwZWQgaW4gdGhlIHJldmVyc2Ugb3JkZXIgdG8gaG93IHRoZXkgd2VyZSBwdXNoZWRcbiAgICogc28gd2UgYWx3YXlzIGtub3cgb24gdGhlIHdheSBkb3duIHdoaWNoIHByb3ZpZGVyIHlvdSdsbCBlbmNvdW50ZXIgbmV4dCBvbiB0aGUgd2F5IHVwLlxuICAgKiBPbiB0aGUgd2F5IGRvd24sIHdlIHB1c2ggdGhlIGN1cnJlbnQgcHJvdmlkZXIsIGFuZCBpdHMgY29udGV4dCB2YWx1ZSAqYmVmb3JlKlxuICAgKiB3ZSBtdXRhdGVkIGl0LCBvbnRvIHRoZSBzdGFja3MuIFRoZXJlZm9yZSwgb24gdGhlIHdheSB1cCwgd2UgYWx3YXlzIGtub3cgd2hpY2hcbiAgICogcHJvdmlkZXIgbmVlZHMgdG8gYmUgXCJyZXN0b3JlZFwiIHRvIHdoaWNoIHZhbHVlLlxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMjk4NSNpc3N1ZWNvbW1lbnQtMzk2MzAxMjQ4XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnB1c2hQcm92aWRlciA9IGZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlcikge1xuICAgIHZhciBpbmRleCA9ICsrdGhpcy5jb250ZXh0SW5kZXg7XG4gICAgdmFyIGNvbnRleHQgPSBwcm92aWRlci50eXBlLl9jb250ZXh0O1xuICAgIHZhciB0aHJlYWRJRCA9IHRoaXMudGhyZWFkSUQ7XG4gICAgdmFsaWRhdGVDb250ZXh0Qm91bmRzKGNvbnRleHQsIHRocmVhZElEKTtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGNvbnRleHRbdGhyZWFkSURdOyAvLyBSZW1lbWJlciB3aGljaCB2YWx1ZSB0byByZXN0b3JlIHRoaXMgY29udGV4dCB0byBvbiBvdXIgd2F5IHVwLlxuXG4gICAgdGhpcy5jb250ZXh0U3RhY2tbaW5kZXhdID0gY29udGV4dDtcbiAgICB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrW2luZGV4XSA9IHByZXZpb3VzVmFsdWU7XG5cbiAgICB7XG4gICAgICAvLyBPbmx5IHVzZWQgZm9yIHB1c2gvcG9wIG1pc21hdGNoIHdhcm5pbmdzLlxuICAgICAgdGhpcy5jb250ZXh0UHJvdmlkZXJTdGFja1tpbmRleF0gPSBwcm92aWRlcjtcbiAgICB9IC8vIE11dGF0ZSB0aGUgY3VycmVudCB2YWx1ZS5cblxuXG4gICAgY29udGV4dFt0aHJlYWRJRF0gPSBwcm92aWRlci5wcm9wcy52YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8ucG9wUHJvdmlkZXIgPSBmdW5jdGlvbiBwb3BQcm92aWRlcihwcm92aWRlcikge1xuICAgIHZhciBpbmRleCA9IHRoaXMuY29udGV4dEluZGV4O1xuXG4gICAge1xuICAgICAgaWYgKGluZGV4IDwgMCB8fCBwcm92aWRlciAhPT0gdGhpcy5jb250ZXh0UHJvdmlkZXJTdGFja1tpbmRleF0pIHtcbiAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0U3RhY2tbaW5kZXhdO1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gdGhpcy5jb250ZXh0VmFsdWVTdGFja1tpbmRleF07IC8vIFwiSGlkZVwiIHRoZXNlIG51bGwgYXNzaWdubWVudHMgZnJvbSBGbG93IGJ5IHVzaW5nIGBhbnlgXG4gICAgLy8gYmVjYXVzZSBjb25jZXB0dWFsbHkgdGhleSBhcmUgZGVsZXRpb25zLS1hcyBsb25nIGFzIHdlXG4gICAgLy8gcHJvbWlzZSB0byBuZXZlciBhY2Nlc3MgdmFsdWVzIGJleW9uZCBgdGhpcy5jb250ZXh0SW5kZXhgLlxuXG4gICAgdGhpcy5jb250ZXh0U3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAgICB7XG4gICAgICB0aGlzLmNvbnRleHRQcm92aWRlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5jb250ZXh0SW5kZXgtLTsgLy8gUmVzdG9yZSB0byB0aGUgcHJldmlvdXMgdmFsdWUgd2Ugc3RvcmVkIGFzIHdlIHdlcmUgd2Fsa2luZyBkb3duLlxuICAgIC8vIFdlJ3ZlIGFscmVhZHkgdmVyaWZpZWQgdGhhdCB0aGlzIGNvbnRleHQgaGFzIGJlZW4gZXhwYW5kZWQgdG8gYWNjb21tb2RhdGVcbiAgICAvLyB0aGlzIHRocmVhZCBpZCwgc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBpdCBhZ2Fpbi5cblxuICAgIGNvbnRleHRbdGhpcy50aHJlYWRJRF0gPSBwcmV2aW91c1ZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5jbGVhclByb3ZpZGVycyA9IGZ1bmN0aW9uIGNsZWFyUHJvdmlkZXJzKCkge1xuICAgIC8vIFJlc3RvcmUgYW55IHJlbWFpbmluZyBwcm92aWRlcnMgb24gdGhlIHN0YWNrIHRvIHByZXZpb3VzIHZhbHVlc1xuICAgIGZvciAodmFyIGluZGV4ID0gdGhpcy5jb250ZXh0SW5kZXg7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0U3RhY2tbaW5kZXhdO1xuICAgICAgdmFyIHByZXZpb3VzVmFsdWUgPSB0aGlzLmNvbnRleHRWYWx1ZVN0YWNrW2luZGV4XTtcbiAgICAgIGNvbnRleHRbdGhpcy50aHJlYWRJRF0gPSBwcmV2aW91c1ZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVhZCA9IGZ1bmN0aW9uIHJlYWQoYnl0ZXMpIHtcbiAgICBpZiAodGhpcy5leGhhdXN0ZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwcmV2UGFydGlhbFJlbmRlcmVyID0gY3VycmVudFBhcnRpYWxSZW5kZXJlcjtcbiAgICBzZXRDdXJyZW50UGFydGlhbFJlbmRlcmVyKHRoaXMpO1xuICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50O1xuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIkMS5jdXJyZW50ID0gRGlzcGF0Y2hlcjtcblxuICAgIHRyeSB7XG4gICAgICAvLyBNYXJrdXAgZ2VuZXJhdGVkIHdpdGhpbiA8U3VzcGVuc2U+IGVuZHMgdXAgYnVmZmVyZWQgdW50aWwgd2Uga25vd1xuICAgICAgLy8gbm90aGluZyBpbiB0aGF0IGJvdW5kYXJ5IHN1c3BlbmRlZFxuICAgICAgdmFyIG91dCA9IFsnJ107XG4gICAgICB2YXIgc3VzcGVuZGVkID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChvdXRbMF0ubGVuZ3RoIDwgYnl0ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5leGhhdXN0ZWQgPSB0cnVlO1xuICAgICAgICAgIGZyZWVUaHJlYWRJRCh0aGlzLnRocmVhZElEKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmcmFtZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoc3VzcGVuZGVkIHx8IGZyYW1lLmNoaWxkSW5kZXggPj0gZnJhbWUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGZvb3RlciA9IGZyYW1lLmZvb3RlcjtcblxuICAgICAgICAgIGlmIChmb290ZXIgIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgaWYgKGZyYW1lLnR5cGUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChmcmFtZS50eXBlICE9IG51bGwgJiYgZnJhbWUudHlwZS50eXBlICE9IG51bGwgJiYgZnJhbWUudHlwZS50eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBmcmFtZS50eXBlO1xuICAgICAgICAgICAgdGhpcy5wb3BQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgICAgfSBlbHNlIGlmIChmcmFtZS50eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFKSB7XG4gICAgICAgICAgICB0aGlzLnN1c3BlbnNlRGVwdGgtLTtcbiAgICAgICAgICAgIHZhciBidWZmZXJlZCA9IG91dC5wb3AoKTtcblxuICAgICAgICAgICAgaWYgKHN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICBzdXNwZW5kZWQgPSBmYWxzZTsgLy8gSWYgcmVuZGVyaW5nIHdhcyBzdXNwZW5kZWQgYXQgdGhpcyBib3VuZGFyeSwgcmVuZGVyIHRoZSBmYWxsYmFja0ZyYW1lXG5cbiAgICAgICAgICAgICAgdmFyIGZhbGxiYWNrRnJhbWUgPSBmcmFtZS5mYWxsYmFja0ZyYW1lO1xuXG4gICAgICAgICAgICAgIGlmICghZmFsbGJhY2tGcmFtZSkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRydWUgPyBcIlJlYWN0RE9NU2VydmVyIGRpZCBub3QgZmluZCBhbiBpbnRlcm5hbCBmYWxsYmFjayBmcmFtZSBmb3IgU3VzcGVuc2UuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiIDogZm9ybWF0UHJvZEVycm9yTWVzc2FnZSgzMDMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goZmFsbGJhY2tGcmFtZSk7XG4gICAgICAgICAgICAgIG91dFt0aGlzLnN1c3BlbnNlRGVwdGhdICs9ICc8IS0tJCEtLT4nOyAvLyBTa2lwIGZsdXNoaW5nIG91dHB1dCBzaW5jZSB3ZSdyZSBzd2l0Y2hpbmcgdG8gdGhlIGZhbGxiYWNrXG5cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRbdGhpcy5zdXNwZW5zZURlcHRoXSArPSBidWZmZXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIEZsdXNoIG91dHB1dFxuXG5cbiAgICAgICAgICBvdXRbdGhpcy5zdXNwZW5zZURlcHRoXSArPSBmb290ZXI7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hpbGQgPSBmcmFtZS5jaGlsZHJlbltmcmFtZS5jaGlsZEluZGV4KytdO1xuICAgICAgICB2YXIgb3V0QnVmZmVyID0gJyc7XG5cbiAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICBwdXNoQ3VycmVudERlYnVnU3RhY2sodGhpcy5zdGFjayk7IC8vIFdlJ3JlIHN0YXJ0aW5nIHdvcmsgb24gdGhpcyBmcmFtZSwgc28gcmVzZXQgaXRzIGlubmVyIHN0YWNrLlxuXG4gICAgICAgICAgZnJhbWUuZGVidWdFbGVtZW50U3RhY2subGVuZ3RoID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0QnVmZmVyICs9IHRoaXMucmVuZGVyKGNoaWxkLCBmcmFtZS5jb250ZXh0LCBmcmFtZS5kb21OYW1lc3BhY2UpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyICE9IG51bGwgJiYgdHlwZW9mIGVyci50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAoZW5hYmxlU3VzcGVuc2VTZXJ2ZXJSZW5kZXJlcikge1xuICAgICAgICAgICAgICBpZiAoISh0aGlzLnN1c3BlbnNlRGVwdGggPiAwKSkge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKHRydWUgPyBcIkEgUmVhY3QgY29tcG9uZW50IHN1c3BlbmRlZCB3aGlsZSByZW5kZXJpbmcsIGJ1dCBubyBmYWxsYmFjayBVSSB3YXMgc3BlY2lmaWVkLlxcblxcbkFkZCBhIDxTdXNwZW5zZSBmYWxsYmFjaz0uLi4+IGNvbXBvbmVudCBoaWdoZXIgaW4gdGhlIHRyZWUgdG8gcHJvdmlkZSBhIGxvYWRpbmcgaW5kaWNhdG9yIG9yIHBsYWNlaG9sZGVyIHRvIGRpc3BsYXkuXCIgOiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDM0MikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN1c3BlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoIWZhbHNlKSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IodHJ1ZSA/IFwiUmVhY3RET01TZXJ2ZXIgZG9lcyBub3QgeWV0IHN1cHBvcnQgU3VzcGVuc2UuXCIgOiBmb3JtYXRQcm9kRXJyb3JNZXNzYWdlKDI5NCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICBwb3BDdXJyZW50RGVidWdTdGFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvdXQubGVuZ3RoIDw9IHRoaXMuc3VzcGVuc2VEZXB0aCkge1xuICAgICAgICAgIG91dC5wdXNoKCcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dFt0aGlzLnN1c3BlbnNlRGVwdGhdICs9IG91dEJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dFswXTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciQxLmN1cnJlbnQgPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIHNldEN1cnJlbnRQYXJ0aWFsUmVuZGVyZXIocHJldlBhcnRpYWxSZW5kZXJlcik7XG4gICAgICByZXNldEhvb2tzU3RhdGUoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjaGlsZCwgY29udGV4dCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHRleHQgPSAnJyArIGNoaWxkO1xuXG4gICAgICBpZiAodGV4dCA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tYWtlU3RhdGljTWFya3VwKSB7XG4gICAgICAgIHJldHVybiBlc2NhcGVUZXh0Rm9yQnJvd3Nlcih0ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJldmlvdXNXYXNUZXh0Tm9kZSkge1xuICAgICAgICByZXR1cm4gJzwhLS0gLS0+JyArIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByZXZpb3VzV2FzVGV4dE5vZGUgPSB0cnVlO1xuICAgICAgcmV0dXJuIGVzY2FwZVRleHRGb3JCcm93c2VyKHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbmV4dENoaWxkO1xuXG4gICAgICB2YXIgX3Jlc29sdmUgPSByZXNvbHZlKGNoaWxkLCBjb250ZXh0LCB0aGlzLnRocmVhZElEKTtcblxuICAgICAgbmV4dENoaWxkID0gX3Jlc29sdmUuY2hpbGQ7XG4gICAgICBjb250ZXh0ID0gX3Jlc29sdmUuY29udGV4dDtcblxuICAgICAgaWYgKG5leHRDaGlsZCA9PT0gbnVsbCB8fCBuZXh0Q2hpbGQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH0gZWxzZSBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KG5leHRDaGlsZCkpIHtcbiAgICAgICAgaWYgKG5leHRDaGlsZCAhPSBudWxsICYmIG5leHRDaGlsZC4kJHR5cGVvZiAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ2F0Y2ggdW5leHBlY3RlZCBzcGVjaWFsIHR5cGVzIGVhcmx5LlxuICAgICAgICAgIHZhciAkJHR5cGVvZiA9IG5leHRDaGlsZC4kJHR5cGVvZjtcblxuICAgICAgICAgIGlmICghKCQkdHlwZW9mICE9PSBSRUFDVF9QT1JUQUxfVFlQRSkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiUG9ydGFscyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgdGhlIHNlcnZlciByZW5kZXJlci4gUmVuZGVyIHRoZW0gY29uZGl0aW9uYWxseSBzbyB0aGF0IHRoZXkgb25seSBhcHBlYXIgb24gdGhlIGNsaWVudCByZW5kZXIuXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIENhdGNoLWFsbCB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AgaWYgUmVhY3QuQ2hpbGRyZW4udG9BcnJheSgpIHN1cHBvcnRzIHNvbWUgbmV3IHR5cGUuXG5cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiVW5rbm93biBlbGVtZW50LWxpa2Ugb2JqZWN0IHR5cGU6IFwiICsgJCR0eXBlb2YudG9TdHJpbmcoKSArIFwiLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dENoaWxkcmVuID0gdG9BcnJheShuZXh0Q2hpbGQpO1xuICAgICAgICB2YXIgZnJhbWUgPSB7XG4gICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICBkb21OYW1lc3BhY2U6IHBhcmVudE5hbWVzcGFjZSxcbiAgICAgICAgICBjaGlsZHJlbjogbmV4dENoaWxkcmVuLFxuICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgIH07XG5cbiAgICAgICAge1xuICAgICAgICAgIGZyYW1lLmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0YWNrLnB1c2goZnJhbWUpO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9IC8vIFNhZmUgYmVjYXVzZSB3ZSBqdXN0IGNoZWNrZWQgaXQncyBhbiBlbGVtZW50LlxuXG5cbiAgICAgIHZhciBuZXh0RWxlbWVudCA9IG5leHRDaGlsZDtcbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IG5leHRFbGVtZW50LnR5cGU7XG5cbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckRPTShuZXh0RWxlbWVudCwgY29udGV4dCwgcGFyZW50TmFtZXNwYWNlKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChlbGVtZW50VHlwZSkge1xuICAgICAgICAvLyBUT0RPOiBMZWdhY3lIaWRkZW4gYWN0cyB0aGUgc2FtZSBhcyBhIGZyYWdtZW50LiBUaGlzIG9ubHkgd29ya3NcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBjdXJyZW50bHkgYXNzdW1lIHRoYXQgZXZlcnkgaW5zdGFuY2Ugb2YgTGVnYWN5SGlkZGVuIGlzXG4gICAgICAgIC8vIGFjY29tcGFuaWVkIGJ5IGEgaG9zdCBjb21wb25lbnQgd3JhcHBlci4gSW4gdGhlIGhpZGRlbiBtb2RlLCB0aGUgaG9zdFxuICAgICAgICAvLyBjb21wb25lbnQgaXMgZ2l2ZW4gYSBgaGlkZGVuYCBhdHRyaWJ1dGUsIHdoaWNoIGVuc3VyZXMgdGhhdCB0aGVcbiAgICAgICAgLy8gaW5pdGlhbCBIVE1MIGlzIG5vdCB2aXNpYmxlLiBUbyBzdXBwb3J0IHRoZSB1c2Ugb2YgTGVnYWN5SGlkZGVuIGFzIGFcbiAgICAgICAgLy8gdHJ1ZSBmcmFnbWVudCwgd2l0aG91dCBhbiBleHRyYSBET00gbm9kZSwgd2Ugd291bGQgaGF2ZSB0byBoaWRlIHRoZVxuICAgICAgICAvLyBpbml0aWFsIEhUTUwgaW4gc29tZSBvdGhlciB3YXkuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX25leHRDaGlsZHJlbiA9IHRvQXJyYXkobmV4dENoaWxkLnByb3BzLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgdmFyIF9mcmFtZSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogbnVsbCxcbiAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuLFxuICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIF9mcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lKTtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCBcIlJlYWN0RE9NU2VydmVyIGRvZXMgbm90IHlldCBzdXBwb3J0IFN1c3BlbnNlLlwiICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUtbm8tZmFsbHRocm91Z2hcblxuICAgICAgICBjYXNlIFJFQUNUX1NDT1BFX1RZUEU6XG4gICAgICAgICAge1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCBzY29wZSBjb21wb25lbnRzLlwiICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdvYmplY3QnICYmIGVsZW1lbnRUeXBlICE9PSBudWxsKSB7XG4gICAgICAgIHN3aXRjaCAoZWxlbWVudFR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gbmV4dENoaWxkO1xuXG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuNTtcblxuICAgICAgICAgICAgICB2YXIgY29tcG9uZW50SWRlbnRpdHkgPSB7fTtcbiAgICAgICAgICAgICAgcHJlcGFyZVRvVXNlSG9va3MoY29tcG9uZW50SWRlbnRpdHkpO1xuICAgICAgICAgICAgICBfbmV4dENoaWxkcmVuNSA9IGVsZW1lbnRUeXBlLnJlbmRlcihlbGVtZW50LnByb3BzLCBlbGVtZW50LnJlZik7XG4gICAgICAgICAgICAgIF9uZXh0Q2hpbGRyZW41ID0gZmluaXNoSG9va3MoZWxlbWVudFR5cGUucmVuZGVyLCBlbGVtZW50LnByb3BzLCBfbmV4dENoaWxkcmVuNSwgZWxlbWVudC5yZWYpO1xuICAgICAgICAgICAgICBfbmV4dENoaWxkcmVuNSA9IHRvQXJyYXkoX25leHRDaGlsZHJlbjUpO1xuICAgICAgICAgICAgICB2YXIgX2ZyYW1lNSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuNSxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfZnJhbWU1LmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lNSk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgX2VsZW1lbnQgPSBuZXh0Q2hpbGQ7XG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuNiA9IFtSZWFjdC5jcmVhdGVFbGVtZW50KGVsZW1lbnRUeXBlLnR5cGUsIF9hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHJlZjogX2VsZW1lbnQucmVmXG4gICAgICAgICAgICAgIH0sIF9lbGVtZW50LnByb3BzKSldO1xuICAgICAgICAgICAgICB2YXIgX2ZyYW1lNiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBudWxsLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuNixcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfZnJhbWU2LmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2goX2ZyYW1lNik7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV4dENoaWxkO1xuICAgICAgICAgICAgICB2YXIgbmV4dFByb3BzID0gcHJvdmlkZXIucHJvcHM7XG5cbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW43ID0gdG9BcnJheShuZXh0UHJvcHMuY2hpbGRyZW4pO1xuXG4gICAgICAgICAgICAgIHZhciBfZnJhbWU3ID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIGRvbU5hbWVzcGFjZTogcGFyZW50TmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBfbmV4dENoaWxkcmVuNyxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfZnJhbWU3LmRlYnVnRWxlbWVudFN0YWNrID0gW107XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLnB1c2hQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWU3KTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciByZWFjdENvbnRleHQgPSBuZXh0Q2hpbGQudHlwZTsgLy8gVGhlIGxvZ2ljIGJlbG93IGZvciBDb250ZXh0IGRpZmZlcnMgZGVwZW5kaW5nIG9uIFBST0Qgb3IgREVWIG1vZGUuIEluXG4gICAgICAgICAgICAgIC8vIERFViBtb2RlLCB3ZSBjcmVhdGUgYSBzZXBhcmF0ZSBvYmplY3QgZm9yIENvbnRleHQuQ29uc3VtZXIgdGhhdCBhY3RzXG4gICAgICAgICAgICAgIC8vIGxpa2UgYSBwcm94eSB0byBDb250ZXh0LiBUaGlzIHByb3h5IG9iamVjdCBhZGRzIHVubmVjZXNzYXJ5IGNvZGUgaW4gUFJPRFxuICAgICAgICAgICAgICAvLyBzbyB3ZSB1c2UgdGhlIG9sZCBiZWhhdmlvdXIgKENvbnRleHQuQ29uc3VtZXIgcmVmZXJlbmNlcyBDb250ZXh0KSB0b1xuICAgICAgICAgICAgICAvLyByZWR1Y2Ugc2l6ZSBhbmQgb3ZlcmhlYWQuIFRoZSBzZXBhcmF0ZSBvYmplY3QgcmVmZXJlbmNlcyBjb250ZXh0IHZpYVxuICAgICAgICAgICAgICAvLyBhIHByb3BlcnR5IGNhbGxlZCBcIl9jb250ZXh0XCIsIHdoaWNoIGFsc28gZ2l2ZXMgdXMgdGhlIGFiaWxpdHkgdG8gY2hlY2tcbiAgICAgICAgICAgICAgLy8gaW4gREVWIG1vZGUgaWYgdGhpcyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90IGFuZCB3YXJuIGlmIGl0IGRvZXMgbm90LlxuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAocmVhY3RDb250ZXh0Ll9jb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbWF5IGJlIGJlY2F1c2UgaXQncyBhIENvbnRleHQgKHJhdGhlciB0aGFuIGEgQ29uc3VtZXIpLlxuICAgICAgICAgICAgICAgICAgLy8gT3IgaXQgbWF5IGJlIGJlY2F1c2UgaXQncyBvbGRlciBSZWFjdCB3aGVyZSB0aGV5J3JlIHRoZSBzYW1lIHRoaW5nLlxuICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHdhcm4gaWYgd2UncmUgc3VyZSBpdCdzIGEgbmV3IFJlYWN0LlxuICAgICAgICAgICAgICAgICAgaWYgKHJlYWN0Q29udGV4dCAhPT0gcmVhY3RDb250ZXh0LkNvbnN1bWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ0NvbnRleHRBc0NvbnN1bWVyID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdSZW5kZXJpbmcgPENvbnRleHQ+IGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAnICsgJ2EgZnV0dXJlIG1ham9yIHJlbGVhc2UuIERpZCB5b3UgbWVhbiB0byByZW5kZXIgPENvbnRleHQuQ29uc3VtZXI+IGluc3RlYWQ/Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmVhY3RDb250ZXh0ID0gcmVhY3RDb250ZXh0Ll9jb250ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBfbmV4dFByb3BzID0gbmV4dENoaWxkLnByb3BzO1xuICAgICAgICAgICAgICB2YXIgdGhyZWFkSUQgPSB0aGlzLnRocmVhZElEO1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNvbnRleHRCb3VuZHMocmVhY3RDb250ZXh0LCB0aHJlYWRJRCk7XG4gICAgICAgICAgICAgIHZhciBuZXh0VmFsdWUgPSByZWFjdENvbnRleHRbdGhyZWFkSURdO1xuXG4gICAgICAgICAgICAgIHZhciBfbmV4dENoaWxkcmVuOCA9IHRvQXJyYXkoX25leHRQcm9wcy5jaGlsZHJlbihuZXh0VmFsdWUpKTtcblxuICAgICAgICAgICAgICB2YXIgX2ZyYW1lOCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBuZXh0Q2hpbGQsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW44LFxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBmb290ZXI6ICcnXG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9mcmFtZTguZGVidWdFbGVtZW50U3RhY2sgPSBbXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChfZnJhbWU4KTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZS1uby1mYWxsdGhyb3VnaFxuXG4gICAgICAgICAgY2FzZSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFOlxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCJSZWFjdERPTVNlcnZlciBkb2VzIG5vdCB5ZXQgc3VwcG9ydCB0aGUgZnVuZGFtZW50YWwgQVBJLlwiICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lLW5vLWZhbGx0aHJvdWdoXG5cbiAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIF9lbGVtZW50MiA9IG5leHRDaGlsZDtcbiAgICAgICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSBuZXh0Q2hpbGQudHlwZTsgLy8gQXR0ZW1wdCB0byBpbml0aWFsaXplIGxhenkgY29tcG9uZW50IHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGVcbiAgICAgICAgICAgICAgLy8gc3VzcGVuc2Ugc2VydmVyLXNpZGUgcmVuZGVyZXIgaXMgZW5hYmxlZCBzbyBzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICAgIC8vIHJlc29sdmVkIGNvbnN0cnVjdG9ycyBhcmUgc3VwcG9ydGVkLlxuXG4gICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW5pdChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgdmFyIF9uZXh0Q2hpbGRyZW4xMCA9IFtSZWFjdC5jcmVhdGVFbGVtZW50KHJlc3VsdCwgX2Fzc2lnbih7XG4gICAgICAgICAgICAgICAgcmVmOiBfZWxlbWVudDIucmVmXG4gICAgICAgICAgICAgIH0sIF9lbGVtZW50Mi5wcm9wcykpXTtcbiAgICAgICAgICAgICAgdmFyIF9mcmFtZTEwID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZG9tTmFtZXNwYWNlOiBwYXJlbnROYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IF9uZXh0Q2hpbGRyZW4xMCxcbiAgICAgICAgICAgICAgICBjaGlsZEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZm9vdGVyOiAnJ1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfZnJhbWUxMC5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKF9mcmFtZTEwKTtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIHtcbiAgICAgICAgdmFyIG93bmVyID0gbmV4dEVsZW1lbnQuX293bmVyO1xuXG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoZWxlbWVudFR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIFwiICsgJ25hbWVkIGltcG9ydHMuJztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvd25lck5hbWUgPSBvd25lciA/IGdldENvbXBvbmVudE5hbWUob3duZXIpIDogbnVsbDtcblxuICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHRocm93IEVycm9yKCBcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogXCIgKyAoZWxlbWVudFR5cGUgPT0gbnVsbCA/IGVsZW1lbnRUeXBlIDogdHlwZW9mIGVsZW1lbnRUeXBlKSArIFwiLlwiICsgaW5mbyApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5yZW5kZXJET00gPSBmdW5jdGlvbiByZW5kZXJET00oZWxlbWVudCwgY29udGV4dCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gICAgdmFyIHRhZyA9IGVsZW1lbnQudHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBuYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2U7XG5cbiAgICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBOYW1lc3BhY2VzLmh0bWwpIHtcbiAgICAgIG5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChuYW1lc3BhY2UgPT09IE5hbWVzcGFjZXMuaHRtbCkge1xuICAgICAgICAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAgIC8vIGFsbG93IDxTVkc+IG9yIDxtQVRIPi5cbiAgICAgICAgaWYgKHRhZyAhPT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgZXJyb3IoJzwlcyAvPiBpcyB1c2luZyBpbmNvcnJlY3QgY2FzaW5nLiAnICsgJ1VzZSBQYXNjYWxDYXNlIGZvciBSZWFjdCBjb21wb25lbnRzLCAnICsgJ29yIGxvd2VyY2FzZSBmb3IgSFRNTCBlbGVtZW50cy4nLCBlbGVtZW50LnR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVEYW5nZXJvdXNUYWcodGFnKTtcbiAgICB2YXIgcHJvcHMgPSBlbGVtZW50LnByb3BzO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2lucHV0Jykge1xuICAgICAge1xuICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdpbnB1dCcsIHByb3BzKTtcblxuICAgICAgICBpZiAocHJvcHMuY2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5EZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgICAgIGVycm9yKCclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCBjaGVja2VkIGFuZCBkZWZhdWx0Q2hlY2tlZCBwcm9wcy4gJyArICdJbnB1dCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgY2hlY2tlZCBwcm9wLCBvciB0aGUgZGVmYXVsdENoZWNrZWQgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgICAgIGRpZFdhcm5EZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRJbnB1dFZhbHVlKSB7XG4gICAgICAgICAgZXJyb3IoJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnLCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcblxuICAgICAgICAgIGRpZFdhcm5EZWZhdWx0SW5wdXRWYWx1ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcHJvcHMgPSBfYXNzaWduKHtcbiAgICAgICAgdHlwZTogdW5kZWZpbmVkXG4gICAgICB9LCBwcm9wcywge1xuICAgICAgICBkZWZhdWx0Q2hlY2tlZDogdW5kZWZpbmVkLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsdWU6IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgICAgY2hlY2tlZDogcHJvcHMuY2hlY2tlZCAhPSBudWxsID8gcHJvcHMuY2hlY2tlZCA6IHByb3BzLmRlZmF1bHRDaGVja2VkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3RleHRhcmVhJykge1xuICAgICAge1xuICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCd0ZXh0YXJlYScsIHByb3BzKTtcblxuICAgICAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlKSB7XG4gICAgICAgICAgZXJyb3IoJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL2NvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuXG4gICAgICAgICAgZGlkV2FybkRlZmF1bHRUZXh0YXJlYVZhbHVlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaW5pdGlhbFZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgICAgIGlmIChpbml0aWFsVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlOyAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuXG4gICAgICAgIHZhciB0ZXh0YXJlYUNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgICAgaWYgKHRleHRhcmVhQ2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVycm9yKCdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoIFwiSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLlwiICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGV4dGFyZWFDaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGlmICghKHRleHRhcmVhQ2hpbGRyZW4ubGVuZ3RoIDw9IDEpKSB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvciggXCI8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuXCIgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0ZXh0YXJlYUNoaWxkcmVuID0gdGV4dGFyZWFDaGlsZHJlblswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIHRleHRhcmVhQ2hpbGRyZW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgcHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBjaGlsZHJlbjogJycgKyBpbml0aWFsVmFsdWVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnc2VsZWN0Jykge1xuICAgICAge1xuICAgICAgICBjaGVja0NvbnRyb2xsZWRWYWx1ZVByb3BzKCdzZWxlY3QnLCBwcm9wcyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuXG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcblxuICAgICAgICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4nLCBwcm9wTmFtZSk7XG4gICAgICAgICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgICAgICAgZXJyb3IoJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJywgcHJvcE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuRGVmYXVsdFNlbGVjdFZhbHVlKSB7XG4gICAgICAgICAgZXJyb3IoJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcblxuICAgICAgICAgIGRpZFdhcm5EZWZhdWx0U2VsZWN0VmFsdWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3VycmVudFNlbGVjdFZhbHVlID0gcHJvcHMudmFsdWUgIT0gbnVsbCA/IHByb3BzLnZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgcHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ29wdGlvbicpIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IG51bGw7XG4gICAgICB2YXIgc2VsZWN0VmFsdWUgPSB0aGlzLmN1cnJlbnRTZWxlY3RWYWx1ZTtcbiAgICAgIHZhciBvcHRpb25DaGlsZHJlbiA9IGZsYXR0ZW5PcHRpb25DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgICAgIGlmIChzZWxlY3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAocHJvcHMudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIHZhbHVlID0gcHJvcHMudmFsdWUgKyAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IG9wdGlvbkNoaWxkcmVuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZWxlY3RWYWx1ZSkpIHtcbiAgICAgICAgICAvLyBtdWx0aXBsZVxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2VsZWN0VmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmICgnJyArIHNlbGVjdFZhbHVlW2pdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxlY3RlZCA9ICcnICsgc2VsZWN0VmFsdWUgPT09IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcHMgPSBfYXNzaWduKHtcbiAgICAgICAgICBzZWxlY3RlZDogdW5kZWZpbmVkLFxuICAgICAgICAgIGNoaWxkcmVuOiB1bmRlZmluZWRcbiAgICAgICAgfSwgcHJvcHMsIHtcbiAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICAgICAgY2hpbGRyZW46IG9wdGlvbkNoaWxkcmVuXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzKTtcbiAgICB2YXIgb3V0ID0gY3JlYXRlT3BlblRhZ01hcmt1cChlbGVtZW50LnR5cGUsIHRhZywgcHJvcHMsIG5hbWVzcGFjZSwgdGhpcy5tYWtlU3RhdGljTWFya3VwLCB0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMSk7XG4gICAgdmFyIGZvb3RlciA9ICcnO1xuXG4gICAgaWYgKG9taXR0ZWRDbG9zZVRhZ3MuaGFzT3duUHJvcGVydHkodGFnKSkge1xuICAgICAgb3V0ICs9ICcvPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCArPSAnPic7XG4gICAgICBmb290ZXIgPSAnPC8nICsgZWxlbWVudC50eXBlICsgJz4nO1xuICAgIH1cblxuICAgIHZhciBjaGlsZHJlbjtcbiAgICB2YXIgaW5uZXJNYXJrdXAgPSBnZXROb25DaGlsZHJlbklubmVyTWFya3VwKHByb3BzKTtcblxuICAgIGlmIChpbm5lck1hcmt1cCAhPSBudWxsKSB7XG4gICAgICBjaGlsZHJlbiA9IFtdO1xuXG4gICAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3MuaGFzT3duUHJvcGVydHkodGFnKSAmJiBpbm5lck1hcmt1cC5jaGFyQXQoMCkgPT09ICdcXG4nKSB7XG4gICAgICAgIC8vIHRleHQvaHRtbCBpZ25vcmVzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlc2UgdGFncyBpZiBpdCdzIGEgbmV3bGluZVxuICAgICAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAgICAgLy8gYSBuZXdsaW5lIHNwZWNpZmljYWxseSB0byBnZXQgZWF0ZW4gYnkgdGhlIHBhcnNlci4gKEFsdGVybmF0ZWx5IGZvclxuICAgICAgICAvLyB0ZXh0YXJlYXMsIHJlcGxhY2luZyBcIl5cXG5cIiB3aXRoIFwiXFxyXFxuXCIgZG9lc24ndCBnZXQgZWF0ZW4sIGFuZCB0aGUgZmlyc3RcbiAgICAgICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sLXBvbHlnbG90LyNuZXdsaW5lcy1pbi10ZXh0YXJlYS1hbmQtcHJlPlxuICAgICAgICAvLyBTZWU6IDxodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50LXJlc3RyaWN0aW9ucz5cbiAgICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgICAgIC8vIFNlZTogUGFyc2luZyBvZiBcInRleHRhcmVhXCIgXCJsaXN0aW5nXCIgYW5kIFwicHJlXCIgZWxlbWVudHNcbiAgICAgICAgLy8gIGZyb20gPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHk+XG4gICAgICAgIG91dCArPSAnXFxuJztcbiAgICAgIH1cblxuICAgICAgb3V0ICs9IGlubmVyTWFya3VwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGlsZHJlbiA9IHRvQXJyYXkocHJvcHMuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHZhciBmcmFtZSA9IHtcbiAgICAgIGRvbU5hbWVzcGFjZTogZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCBlbGVtZW50LnR5cGUpLFxuICAgICAgdHlwZTogdGFnLFxuICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgY2hpbGRJbmRleDogMCxcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBmb290ZXI6IGZvb3RlclxuICAgIH07XG5cbiAgICB7XG4gICAgICBmcmFtZS5kZWJ1Z0VsZW1lbnRTdGFjayA9IFtdO1xuICAgIH1cblxuICAgIHRoaXMuc3RhY2sucHVzaChmcmFtZSk7XG4gICAgdGhpcy5wcmV2aW91c1dhc1RleHROb2RlID0gZmFsc2U7XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICByZXR1cm4gUmVhY3RET01TZXJ2ZXJSZW5kZXJlcjtcbn0oKTtcblxuLyoqXG4gKiBSZW5kZXIgYSBSZWFjdEVsZW1lbnQgdG8gaXRzIGluaXRpYWwgSFRNTC4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIG9uIHRoZVxuICogc2VydmVyLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1kb20tc2VydmVyLmh0bWwjcmVuZGVydG9zdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiByZW5kZXJUb1N0cmluZyhlbGVtZW50LCBvcHRpb25zKSB7XG4gIHZhciByZW5kZXJlciA9IG5ldyBSZWFjdERPTVNlcnZlclJlbmRlcmVyKGVsZW1lbnQsIGZhbHNlLCBvcHRpb25zKTtcblxuICB0cnkge1xuICAgIHZhciBtYXJrdXAgPSByZW5kZXJlci5yZWFkKEluZmluaXR5KTtcbiAgICByZXR1cm4gbWFya3VwO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgfVxufVxuLyoqXG4gKiBTaW1pbGFyIHRvIHJlbmRlclRvU3RyaW5nLCBleGNlcHQgdGhpcyBkb2Vzbid0IGNyZWF0ZSBleHRyYSBET00gYXR0cmlidXRlc1xuICogc3VjaCBhcyBkYXRhLXJlYWN0LWlkIHRoYXQgUmVhY3QgdXNlcyBpbnRlcm5hbGx5LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1kb20tc2VydmVyLmh0bWwjcmVuZGVydG9zdGF0aWNtYXJrdXBcbiAqL1xuXG5mdW5jdGlvbiByZW5kZXJUb1N0YXRpY01hcmt1cChlbGVtZW50LCBvcHRpb25zKSB7XG4gIHZhciByZW5kZXJlciA9IG5ldyBSZWFjdERPTVNlcnZlclJlbmRlcmVyKGVsZW1lbnQsIHRydWUsIG9wdGlvbnMpO1xuXG4gIHRyeSB7XG4gICAgdmFyIG1hcmt1cCA9IHJlbmRlcmVyLnJlYWQoSW5maW5pdHkpO1xuICAgIHJldHVybiBtYXJrdXA7XG4gIH0gZmluYWxseSB7XG4gICAgcmVuZGVyZXIuZGVzdHJveSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFkYWJsZSkge1xuICBfaW5oZXJpdHNMb29zZShSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtLCBfUmVhZGFibGUpO1xuXG4gIGZ1bmN0aW9uIFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0oZWxlbWVudCwgbWFrZVN0YXRpY01hcmt1cCwgb3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcblxuICAgIC8vIENhbGxzIHRoZSBzdHJlYW0uUmVhZGFibGUob3B0aW9ucykgY29uc3RydWN0b3IuIENvbnNpZGVyIGV4cG9zaW5nIGJ1aWx0LWluXG4gICAgLy8gZmVhdHVyZXMgbGlrZSBoaWdoV2F0ZXJNYXJrIGluIHRoZSBmdXR1cmUuXG4gICAgX3RoaXMgPSBfUmVhZGFibGUuY2FsbCh0aGlzLCB7fSkgfHwgdGhpcztcbiAgICBfdGhpcy5wYXJ0aWFsUmVuZGVyZXIgPSBuZXcgUmVhY3RET01TZXJ2ZXJSZW5kZXJlcihlbGVtZW50LCBtYWtlU3RhdGljTWFya3VwLCBvcHRpb25zKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9kZXN0cm95ID0gZnVuY3Rpb24gX2Rlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgIHRoaXMucGFydGlhbFJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9O1xuXG4gIF9wcm90by5fcmVhZCA9IGZ1bmN0aW9uIF9yZWFkKHNpemUpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5wdXNoKHRoaXMucGFydGlhbFJlbmRlcmVyLnJlYWQoc2l6ZSkpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5kZXN0cm95KGVycik7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBSZWFjdE1hcmt1cFJlYWRhYmxlU3RyZWFtO1xufShzdHJlYW0uUmVhZGFibGUpO1xuLyoqXG4gKiBSZW5kZXIgYSBSZWFjdEVsZW1lbnQgdG8gaXRzIGluaXRpYWwgSFRNTC4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIG9uIHRoZVxuICogc2VydmVyLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1kb20tc2VydmVyLmh0bWwjcmVuZGVydG9ub2Rlc3RyZWFtXG4gKi9cblxuXG5mdW5jdGlvbiByZW5kZXJUb05vZGVTdHJlYW0oZWxlbWVudCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFJlYWN0TWFya3VwUmVhZGFibGVTdHJlYW0oZWxlbWVudCwgZmFsc2UsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBTaW1pbGFyIHRvIHJlbmRlclRvTm9kZVN0cmVhbSwgZXhjZXB0IHRoaXMgZG9lc24ndCBjcmVhdGUgZXh0cmEgRE9NIGF0dHJpYnV0ZXNcbiAqIHN1Y2ggYXMgZGF0YS1yZWFjdC1pZCB0aGF0IFJlYWN0IHVzZXMgaW50ZXJuYWxseS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtZG9tLXNlcnZlci5odG1sI3JlbmRlcnRvc3RhdGljbm9kZXN0cmVhbVxuICovXG5cbmZ1bmN0aW9uIHJlbmRlclRvU3RhdGljTm9kZVN0cmVhbShlbGVtZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUmVhY3RNYXJrdXBSZWFkYWJsZVN0cmVhbShlbGVtZW50LCB0cnVlLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5yZW5kZXJUb05vZGVTdHJlYW0gPSByZW5kZXJUb05vZGVTdHJlYW07XG5leHBvcnRzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG5leHBvcnRzLnJlbmRlclRvU3RhdGljTm9kZVN0cmVhbSA9IHJlbmRlclRvU3RhdGljTm9kZVN0cmVhbTtcbmV4cG9ydHMucmVuZGVyVG9TdHJpbmcgPSByZW5kZXJUb1N0cmluZztcbmV4cG9ydHMudmVyc2lvbiA9IFJlYWN0VmVyc2lvbjtcbiAgfSkoKTtcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLXNlcnZlci5ub2RlLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS1zZXJ2ZXIubm9kZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwgIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NlcnZlci5ub2RlJyk7XG4iLCAiY29uc3QgZGF0YSA9IHtcblx0XCJib2R5XCI6IFwiPHBhdGggZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBkPVxcXCJNNDAwLjEgMTk0LjhjLTEwLjkgMi44LTE5LjkgNC4zLTI5LjEgNy42Yy03LjMgMS45LTE0LjcgMy45LTIzLjIgNi4xbC0uNi4xYy00LjIgMS4yLTQuNiAxLjMtOC41LTMuMmMtNC43LTUuMy04LjEtOC43LTE0LjYtMTEuOWMtMTkuNy05LjYtMzguNy02LjgtNTYuNCA0LjdjLTIxLjIgMTMuNy0zMi4xIDM0LTMxLjggNTkuMmMuMyAyNSAxNy40IDQ1LjUgNDEuMiA0OC45YzIyIDIuOCAzOS44LTQuNiA1My44LTIwLjVjMi4xLTIuNiA0LTUuMyA2LjEtOC4zYy44LTEgMS41LTIuMSAyLjMtMy4zaC02MC4xYy02LjUgMC04LjEtNC01LjktOS4zYzQtOS43IDExLjUtMjUuOSAxNS45LTM0Yy45LTEuOCAzLjEtNS44IDYuOS01LjhoMTAxLjFjNC41LTEzLjQgMTEuOC0yNi45IDIxLjYtMzkuN2MyMi43LTI5LjkgNDkuMy00NS41IDg3LjItNTJjMzEuOC01LjYgNjEuNy0yLjUgODguOSAxNS45YzI0LjYgMTYuOCAzOS44IDM5LjYgNDMuOSA2OS41YzUuMyA0Mi4xLTYuOSA3Ni4zLTM2LjcgMTA1LjZjLTE5LjcgMjAuOS00NC45IDM0LTczLjkgMzkuOWMtNS42IDEtMTEuMSAxLjUtMTYuNSAyYy0yLjkuMi01LjcuNS04LjUuOGMtMjguMy0uNi01NC4yLTguNy03Ni0yNy40Yy0xNS4zLTEzLjMtMjUuOS0yOS42LTMxLjEtNDguNWMtMy43IDcuMy04IDE0LjQtMTQgMjEuMWMtMjEuNiAyOS42LTUwLjkgNDgtODcuOSA1Mi45Yy0zMC42IDQuMS01OC45LTEuOC04My45LTIwLjVjLTIzLTE3LjUtMzYuMS00MC41LTM5LjUtNjkuMmMtNC4xLTM0IDUuOS02NS40IDI2LjQtOTEuM2MyMi4yLTI5IDUxLjUtNDcuNCA4Ny4zLTUzLjljMjkuMy02LjIgNTcuMy0xLjkgODIuNiAxNS4zYzE2LjUgMTAuOSAyOC4zIDI1LjggMzYuMSA0My45YzEuOSAyLjguNiA0LjQtMy4xIDUuM3ptLTM1MS44IDUuNmMtMS4yNSAwLTEuNTYtLjYtLjk0LTEuNmw2LjU1LTguNGMuNjItLjkgMi4xOC0xLjUgMy40My0xLjVIMTY4LjZjMS4yIDAgMS41LjkuOSAxLjhsLTUuMyA4LjFjLS42IDEtMi4yIDEuOS0zLjEgMS45bC0xMTIuOC0uM3pNMS4yNDYgMjI5LjFjLTEuMjQ2IDAtMS41NTgtLjctLjkzNC0xLjZsNi41NDMtOC40Yy42MjQtLjkgMi4xODItMS42IDMuNDI1LTEuNkgxNTIuNGMxLjIgMCAxLjggMSAxLjUgMS45bC0yLjUgNy41Yy0uMyAxLjItMS41IDEuOS0yLjggMS45bC0xNDcuMzU0LjN6bTc0LjQ3NCAyNi44Yy0uNjIuOS0uMzEgMS44LjkzIDEuOGw2Ny45NS4zYy45IDAgMi4yLS45IDIuMi0yLjFsLjYtNy41YzAtMS4zLS42LTIuMi0xLjktMi4ySDgzLjJjLTEuMjUgMC0yLjQ5LjktMy4xMiAxLjlsLTQuMzYgNy44em01MDEuNDgtMThjLS4yLTIuNi0uMy00LjgtLjctN2MtNS42LTMwLjgtMzQtNDguMy02My42LTQxLjRjLTI5IDYuNS00Ny43IDI0LjktNTQuNSA1NC4yYy01LjYgMjQuMyA2LjIgNDguOSAyOC42IDU4LjljMTcuMiA3LjUgMzQuMyA2LjYgNTAuOC0xLjljMjQuNi0xMy42IDM4LTMyLjcgMzkuNi01OS41Yy0uMS0xLjItLjEtMi4zLS4yLTMuM3pcXFwiLz5cIixcblx0XCJ3aWR0aFwiOiA2NDAsXG5cdFwiaGVpZ2h0XCI6IDUxMlxufTtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBkYXRhO1xuIiwgImNvbnN0IGRhdGEgPSB7XG5cdFwiYm9keVwiOiBcIjxwYXRoIGZpbGw9XFxcIiMzMjZERTZcXFwiIGQ9XFxcIk04Mi4wODUgMjQ0LjkzNGMtNS45NDYgMC0xMS41NjEtMi42NDItMTUuMzYtNy40MzJMOC45MiAxNjUuNjU3Yy0zLjc5OS00Ljc5LTUuMjg1LTEwLjktMy43OTktMTYuODQ3bDIwLjY0NS04OS42ODJjMS4zMjEtNS45NDYgNS4yODUtMTAuNzM2IDEwLjczNi0xMy4zNzhsODMuNTcxLTM5Ljk3YzIuNjQzLTEuMzIgNS42MTYtMS45ODEgOC41ODktMS45ODFjMi45NzMgMCA1Ljk0NS42NiA4LjU4OCAxLjk4Mmw4My41NzIgMzkuODA0YzUuNDUgMi42NDIgOS40MTQgNy40MzIgMTAuNzM1IDEzLjM3OGwyMC42NDUgODkuNjgyYzEuMzIyIDUuOTQ2IDAgMTIuMDU3LTMuNzk4IDE2Ljg0N2wtNTcuODA3IDcxLjg0NWMtMy43OTkgNC42MjQtOS40MTQgNy40MzItMTUuMzYgNy40MzJsLTkzLjE1LjE2NVpcXFwiLz48cGF0aCBmaWxsPVxcXCIjRkZGXFxcIiBkPVxcXCJNMTI4LjQ5NSA3LjkyOGMyLjMxMyAwIDQuNjI1LjQ5NSA2Ljc3MiAxLjQ4Nmw4My41NzIgMzkuODA0YzQuMjk0IDIuMTQ3IDcuNTk3IDYuMTExIDguNTg4IDEwLjczNmwyMC42NDUgODkuNjgyYzEuMTU2IDQuNzkgMCA5Ljc0NS0zLjEzOCAxMy41NDNsLTU3LjgwNiA3MS44NDZjLTIuOTczIDMuNzk4LTcuNTk4IDUuOTQ1LTEyLjM4NyA1Ljk0NUg4Mi4wODVjLTQuNzkgMC05LjQxNC0yLjE0Ny0xMi4zODctNS45NDVsLTU3LjgwNi03MS44NDZjLTIuOTczLTMuNzk4LTQuMTMtOC43NTMtMy4xMzgtMTMuNTQzbDIwLjY0NS04OS42ODJjMS4xNTYtNC43OSA0LjI5NC04Ljc1NCA4LjU4OC0xMC43MzZMMTIxLjU2IDkuMjVjMi4xNDctLjgyNiA0LjYyNC0xLjMyMSA2LjkzNi0xLjMyMVptMC03Ljc2M2MtMy40NjggMC02LjkzNi44MjYtMTAuMjQgMi4zMTJsLTgzLjU3MSAzOS45N2MtNi42MDcgMy4xMzgtMTEuMjMxIDguOTE4LTEyLjg4MyAxNi4wMkwxLjE1NiAxNDguMTVjLTEuNjUxIDcuMTAyIDAgMTQuMzY5IDQuNjI1IDIwLjE1bDU3LjgwNiA3MS44NDVjNC40NiA1LjYxNSAxMS4yMzEgOC43NTMgMTguMzMzIDguNzUzaDkyLjY1NWM3LjEwMiAwIDEzLjg3NC0zLjEzOCAxOC4zMzMtOC43NTNsNTcuODA3LTcxLjg0NmM0LjYyNC01LjYxNSA2LjI3Ni0xMy4wNDcgNC42MjQtMjAuMTVsLTIwLjY0NS04OS42ODJjLTEuNjUxLTcuMTAyLTYuMjc2LTEyLjg4Mi0xMi44ODItMTYuMDJMMTM4LjU3IDIuNDc2QzEzNS40MzIuOTkxIDEzMS45NjQuMTY1IDEyOC40OTUuMTY1WlxcXCIvPjxwYXRoIGZpbGw9XFxcIiNGRkZcXFwiIGQ9XFxcIk0yMTIuMjMyIDE0Mi41MzRjLS4xNjUgMC0uMTY1IDAgMCAwaC0uMTY1Yy0uMTY1IDAtLjMzIDAtLjMzLS4xNjVjLS4zMyAwLS42Ni0uMTY1LS45OTEtLjE2NWMtMS4xNTYtLjE2NS0yLjE0Ny0uMzMtMy4xMzgtLjMzYy0uNDk2IDAtLjk5MSAwLTEuNjUyLS4xNjZoLS4xNjVjLTMuNDY4LS4zMy02LjI3Ni0uNjYtOC45MTktMS40ODZjLTEuMTU2LS40OTYtMS40ODYtMS4xNTYtMS44MTctMS44MTdjMC0uMTY1LS4xNjUtLjE2NS0uMTY1LS4zM2wtMi4xNDctLjY2YTY1LjMzIDY1LjMzIDAgMCAwLTEuMTU2LTIzLjI4OWE2OC4wNTQgNjguMDU0IDAgMCAwLTkuMjQ5LTIxLjYzNmwxLjY1Mi0xLjQ4NnYtLjMzYzAtLjgyNi4xNjUtMS42NTIuODI1LTIuNDc4YzEuOTgyLTEuODE3IDQuNDYtMy4zMDMgNy40MzMtNS4xMmMuNDk1LS4zMy45OS0uNDk1IDEuNDg2LS44MjZjLjk5MS0uNDk1IDEuODE3LS45OSAyLjgwOC0xLjY1MWMuMTY1LS4xNjUuNDk1LS4zMy44MjYtLjY2Yy4xNjUtLjE2Ni4zMy0uMTY2LjMzLS4zMzFjMi4zMTItMS45ODIgMi44MDgtNS4yODUgMS4xNTYtNy40MzNjLS44MjYtMS4xNTYtMi4zMTItMS44MTYtMy43OTktMS44MTZjLTEuMzIgMC0yLjQ3Ny40OTUtMy42MzMgMS4zMjFsLS4zMy4zM2MtLjMzLjE2NS0uNDk2LjQ5Ni0uODI2LjY2MWMtLjgyNi44MjYtMS40ODcgMS40ODYtMi4xNDcgMi4zMTJjLS4zMy4zMy0uNjYuODI2LTEuMTU2IDEuMTU2Yy0yLjMxMyAyLjQ3OC00LjQ2IDQuNDYtNi42MDcgNS45NDZjLS40OTUuMzMtLjk5LjQ5Ni0xLjQ4Ni40OTZjLS4zMyAwLS42NjEgMC0uOTkxLS4xNjZoLS4zM2wtMS45ODMgMS4zMjJjLTIuMTQ3LTIuMzEyLTQuNDU5LTQuMjk0LTYuNzcxLTYuMjc2YTY1Ljk1OCA2NS45NTggMCAwIDAtMzQuNTE5LTEzLjcwOWwtLjE2NS0yLjE0N2wtLjMzLS4zM2MtLjQ5Ni0uNDk2LTEuMTU2LS45OTEtMS4zMjItMi4xNDdjLS4xNjUtMi42NDMuMTY2LTUuNjE2LjQ5Ni04LjkxOXYtLjE2NWMwLS40OTYuMTY1LTEuMTU2LjMzLTEuNjUyYy4xNjUtLjk5LjMzLTEuOTgyLjQ5Ni0zLjEzOHYtMS40ODZjMC0yLjk3My0yLjMxMy01LjQ1LTUuMTItNS40NWMtMS4zMjIgMC0yLjY0My42Ni0zLjYzNCAxLjY1MWMtLjk5Ljk5MS0xLjQ4NiAyLjMxMi0xLjQ4NiAzLjc5OXYxLjMyMWMwIDEuMTU2LjE2NSAyLjE0Ny40OTUgMy4xMzhjLjE2NS40OTYuMTY1Ljk5MS4zMyAxLjY1MnYuMTY1Yy4zMyAzLjMwMy44MjYgNi4yNzYuNDk2IDguOTE5Yy0uMTY1IDEuMTU2LS44MjYgMS42NTEtMS4zMjEgMi4xNDdsLS4zMy4zM2wtLjE2NiAyLjE0N2MtMi45NzMuMzMtNS45NDYuNjYtOC45MTkgMS4zMjFjLTEyLjcxNyAyLjgwOC0yMy45NDggOS4yNS0zMi43MDEgMTguNDk4bC0xLjY1Mi0xLjE1NmgtLjMzYy0uMzMgMC0uNjYxLjE2NS0uOTkxLjE2NWMtLjQ5NiAwLS45OTEtLjE2NS0xLjQ4Ny0uNDk1Yy0yLjE0Ny0xLjQ4Ni00LjI5NC0zLjYzNC02LjYwNi02LjExMWMtLjMzLS4zMy0uNjYtLjgyNi0xLjE1Ni0xLjE1NmMtLjY2MS0uODI2LTEuMzIyLTEuNDg3LTIuMTQ4LTIuMzEyYy0uMTY1LS4xNjYtLjQ5NS0uMzMtLjgyNS0uNjYxYy0uMTY1LS4xNjUtLjMzLS4xNjUtLjMzLS4zM2E1Ljc3MiA1Ljc3MiAwIDAgMC0zLjYzNC0xLjMyMmMtMS40ODcgMC0yLjk3My42NjEtMy43OTkgMS44MTdjLTEuNjUyIDIuMTQ3LTEuMTU2IDUuNDUgMS4xNTYgNy40MzJjLjE2NSAwIC4xNjUuMTY2LjMzLjE2NmMuMzMuMTY1LjQ5Ni40OTUuODI2LjY2Yy45OTEuNjYgMS44MTcgMS4xNTYgMi44MDggMS42NTJjLjQ5Ni4xNjUuOTkxLjQ5NSAxLjQ4Ny44MjZjMi45NzIgMS44MTYgNS40NSAzLjMwMyA3LjQzMiA1LjEyYy44MjYuODI1LjgyNiAxLjY1MS44MjYgMi40Nzd2LjMzbDEuNjUxIDEuNDg3Yy0uMzMuNDk1LS42Ni44MjYtLjgyNiAxLjMyMWMtOC4yNTggMTMuMDQ4LTExLjM5NiAyOC40MDgtOS4yNDkgNDMuNjAzbC0yLjE0Ny42NmMwIC4xNjYtLjE2NS4xNjYtLjE2NS4zM2MtLjMzLjY2MS0uODI2IDEuMzIyLTEuODE3IDEuODE3Yy0yLjQ3Ny44MjYtNS40NSAxLjE1Ny04LjkxOCAxLjQ4N2gtLjE2NmMtLjQ5NSAwLTEuMTU2IDAtMS42NTEuMTY1Yy0uOTkxIDAtMS45ODIuMTY1LTMuMTM4LjMzYy0uMzMgMC0uNjYuMTY2LS45OTEuMTY2Yy0uMTY1IDAtLjMzIDAtLjQ5Ni4xNjVjLTIuOTczLjY2LTQuNzkgMy40NjgtNC4yOTQgNi4xMWMuNDk2IDIuMzEzIDIuNjQzIDMuOCA1LjI4NSAzLjhjLjQ5NiAwIC44MjYgMCAxLjMyMi0uMTY2Yy4xNjUgMCAuMzMgMCAuMzMtLjE2NWMuMzMgMCAuNjYtLjE2NS45OS0uMTY1YzEuMTU3LS4zMyAxLjk4My0uNjYgMi45NzQtMS4xNTZjLjQ5NS0uMTY1Ljk5LS40OTYgMS40ODYtLjY2aC4xNjVjMy4xMzgtMS4xNTcgNS45NDYtMi4xNDggOC41ODktMi40NzhoLjMzYy45OTEgMCAxLjY1Mi40OTUgMi4xNDcuODI2Yy4xNjUgMCAuMTY1LjE2NS4zMy4xNjVsMi4zMTMtLjMzYzMuOTY0IDEyLjIyMSAxMS41NjEgMjMuMTIyIDIxLjYzNiAzMS4wNWMyLjMxMiAxLjgxNiA0LjYyNCAzLjMwMyA3LjEwMiA0Ljc5bC0uOTkxIDIuMTQ2YzAgLjE2Ni4xNjUuMTY2LjE2NS4zM2MuMzMuNjYxLjY2IDEuNDg3LjMzIDIuNjQzYy0uOTkgMi40NzgtMi40NzcgNC45NTUtNC4yOTQgNy43NjN2LjE2NWMtLjMzLjQ5Ni0uNjYuODI2LS45OSAxLjMyMWMtLjY2MS44MjYtMS4xNTcgMS42NTItMS44MTggMi42NDNjLS4xNjUuMTY1LS4zMy40OTUtLjQ5NS44MjZjMCAuMTY1LS4xNjUuMzMtLjE2NS4zM2MtMS4zMjEgMi44MDgtLjMzIDUuOTQ2IDIuMTQ3IDcuMTAyYy42Ni4zMyAxLjMyMS40OTYgMS45ODIuNDk2YzEuOTgyIDAgMy45NjQtMS4zMjIgNC45NTUtMy4xMzljMC0uMTY1LjE2NS0uMzMuMTY1LS4zM2MuMTY1LS4zMy4zMy0uNjYuNDk1LS44MjZjLjQ5Ni0xLjE1Ni42NjEtMS45ODIuOTkxLTIuOTczbC40OTYtMS40ODZjMS4xNTYtMy4zMDMgMS45ODItNS45NDYgMy40NjgtOC4yNThjLjY2LS45OTEgMS40ODctMS4xNTYgMi4xNDctMS40ODdjLjE2NSAwIC4xNjUgMCAuMzMtLjE2NWwxLjE1Ny0yLjE0N2M3LjI2NyAyLjgwOCAxNS4xOTUgNC4yOTQgMjMuMTIyIDQuMjk0YzQuNzkgMCA5Ljc0NS0uNDk1IDE0LjM3LTEuNjUxYTczLjQwMiA3My40MDIgMCAwIDAgOC41ODgtMi40NzhsLjk5IDEuODE3Yy4xNjYgMCAuMTY2IDAgLjMzMS4xNjVjLjgyNi4xNjUgMS40ODYuNDk2IDIuMTQ3IDEuNDg3YzEuMzIxIDIuMzEyIDIuMzEyIDUuMTIgMy40NjggOC4yNTh2LjE2NWwuNDk2IDEuNDg2Yy4zMy45OTEuNDk1IDEuOTgyLjk5IDIuOTczYy4xNjYuMzMuMzMxLjQ5Ni40OTYuODI2YzAgLjE2NS4xNjYuMzMuMTY2LjMzYy45OSAxLjk4MiAyLjk3MiAzLjEzOSA0Ljk1NCAzLjEzOWMuNjYxIDAgMS4zMjItLjE2NiAxLjk4Mi0uNDk2YzEuMTU2LS42NiAyLjE0Ny0xLjY1MiAyLjQ3OC0yLjk3M2MuMzMtMS4zMjEuMzMtMi44MDgtLjMzLTQuMTI5YzAtLjE2NS0uMTY2LS4xNjUtLjE2Ni0uMzNjLS4xNjUtLjMzLS4zMy0uNjYtLjQ5NS0uODI2Yy0uNDk2LS45OTEtMS4xNTYtMS44MTctMS44MTctMi42NDNjLS4zMy0uNDk1LS42Ni0uODI1LS45OS0xLjMydi0uMTY2Yy0xLjgxOC0yLjgwOC0zLjQ3LTUuMjg1LTQuMjk1LTcuNzYzYy0uMzMtMS4xNTYgMC0xLjgxNi4xNjUtMi42NDJjMC0uMTY1LjE2NS0uMTY1LjE2NS0uMzNsLS44MjYtMS45ODJjOC43NTQtNS4xMiAxNi4xODYtMTIuMzg4IDIxLjgwMi0yMS4zMDZjMi45NzMtNC42MjUgNS4yODUtOS43NDUgNi45MzYtMTQuODY1bDEuOTgyLjMzYy4xNjYgMCAuMTY2LS4xNjUuMzMtLjE2NWMuNjYxLS4zMyAxLjE1Ny0uODI1IDIuMTQ4LS44MjVoLjMzYzIuNjQzLjMzIDUuNDUgMS4zMiA4LjU4OSAyLjQ3N2guMTY1Yy40OTUuMTY1Ljk5LjQ5NSAxLjQ4Ni42NmMuOTkxLjQ5NiAxLjgxNy44MjYgMi45NzMgMS4xNTdjLjMzIDAgLjY2LjE2NS45OTEuMTY1Yy4xNjUgMCAuMzMgMCAuNDk1LjE2NWMuNDk2LjE2NS44MjYuMTY1IDEuMzIyLjE2NWMyLjQ3NyAwIDQuNjI0LTEuNjUxIDUuMjg1LTMuNzk4YzAtMS45ODItMS44MTctNC42MjUtNC43OS01LjQ1Wm0tNzYuNDctOC4wOTNsLTcuMjY3IDMuNDY5bC03LjI2Ny0zLjQ2OWwtMS44MTYtNy43NjJsNC45NTQtNi4yNzZoOC4wOTNsNC45NTUgNi4yNzZsLTEuNjUxIDcuNzYyWm00My4xMDgtMTcuMTc2YTUyLjA3OCA1Mi4wNzggMCAwIDEgMS4xNTYgMTYuNjhsLTI1LjI3LTcuMjY2Yy0yLjMxMi0uNjYtMy42MzMtMi45NzMtMy4xMzgtNS4yODVjLjE2NS0uNjYxLjQ5Ni0xLjMyMi45OTEtMS44MTdsMTkuOTg1LTE4LjAwM2MyLjgwNyA0LjYyNSA0Ljk1NCA5LjkxIDYuMjc2IDE1LjY5Wm0tMTQuMjA0LTI1LjZsLTIxLjYzNiAxNS4zNmMtMS44MTcgMS4xNTYtNC4yOTUuODI1LTUuNzgxLS45OTFjLS40OTUtLjQ5Ni0uNjYtMS4xNTctLjgyNi0xLjgxN2wtMS40ODYtMjYuOTIyYTUwLjEzIDUwLjEzIDAgMCAxIDI5LjcyOSAxNC4zN1pNMTE2Ljc2OSA3OC4xMmMxLjgxNy0uMzMgMy40NjgtLjY2IDUuMjg1LS45OWwtMS40ODYgMjYuNDI1Yy0uMTY1IDIuMzEyLTEuOTgyIDQuMjk0LTQuNDYgNC4yOTRjLS42NiAwLTEuNDg2LS4xNjUtMS45ODItLjQ5NUw5Mi4xNiA5MS42NjVjNi43NzItNi43NzIgMTUuMTk1LTExLjM5NyAyNC42MDktMTMuNTQ0Wm0tMzIuNTM3IDIzLjQ1M2wxOS42NTQgMTcuNTA3YzEuODE3IDEuNDg3IDEuOTgyIDQuMjk0LjQ5NiA2LjExMWMtLjQ5Ni42Ni0xLjE1NiAxLjE1Ni0xLjk4MiAxLjMyMmwtMjUuNiA3LjQzMmMtLjk5MS0xMS4yMzEgMS40ODYtMjIuNjI3IDcuNDMyLTMyLjM3MlptLTQuNDYgNDQuNzU5bDI2LjI2Mi00LjQ2YzIuMTQ3LS4xNjUgNC4xMjkgMS4zMjIgNC42MjQgMy40NjljLjE2NS45OS4xNjUgMS44MTctLjE2NSAyLjY0M2wtMTAuMDc1IDI0LjI3OGMtOS4yNDktNS45NDYtMTYuNjgxLTE1LjAzLTIwLjY0NS0yNS45M1ptNjAuMjg1IDMyLjg2N2MtMy43OTkuODI2LTcuNTk4IDEuMzIxLTExLjU2MiAxLjMyMWMtNS43OCAwLTExLjM5Ni0uOTktMTYuNjgtMi42NDJsMTMuMDQ3LTIzLjYxOGMxLjMyMS0xLjQ4NyAzLjQ2OC0yLjE0NyA1LjI4NS0xLjE1NmE3LjA0IDcuMDQgMCAwIDEgMS45ODIgMS44MTZsMTIuNzE3IDIyLjk1OGMtMS40ODYuNDk1LTMuMTM4LjgyNi00Ljc5IDEuMzIxWm0zMi4yMDYtMjIuOTU3Yy00LjEyOSA2LjYwNi05LjU4IDExLjg5MS0xNS44NTUgMTYuMDJsLTEwLjQwNS0yNC45NGMtLjQ5Ni0xLjk4MS4zMy00LjEyOCAyLjMxMi01LjEyYy42Ni0uMzMgMS40ODYtLjQ5NSAyLjMxMi0uNDk1bDI2LjQyNiA0LjQ2Yy0uOTkxIDMuNjMzLTIuNjQzIDYuOTM3LTQuNzkgMTAuMDc1WlxcXCIvPlwiLFxuXHRcIndpZHRoXCI6IDI1Nixcblx0XCJoZWlnaHRcIjogMjQ5XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRhdGE7XG4iLCAiY29uc3QgZGF0YSA9IHtcblx0XCJib2R5XCI6IFwiPGRlZnM+PGxpbmVhckdyYWRpZW50IGlkPVxcXCJzdmdJRGFcXFwiIHgxPVxcXCIxMi45NTklXFxcIiB4Mj1cXFwiNzkuNjM5JVxcXCIgeTE9XFxcIjEyLjAzOSVcXFwiIHkyPVxcXCI3OC4yMDElXFxcIj48c3RvcCBvZmZzZXQ9XFxcIjAlXFxcIiBzdG9wLWNvbG9yPVxcXCIjMzg3RUI4XFxcIi8+PHN0b3Agb2Zmc2V0PVxcXCIxMDAlXFxcIiBzdG9wLWNvbG9yPVxcXCIjMzY2OTk0XFxcIi8+PC9saW5lYXJHcmFkaWVudD48bGluZWFyR3JhZGllbnQgaWQ9XFxcInN2Z0lEYlxcXCIgeDE9XFxcIjE5LjEyOCVcXFwiIHgyPVxcXCI5MC43NDIlXFxcIiB5MT1cXFwiMjAuNTc5JVxcXCIgeTI9XFxcIjg4LjQyOSVcXFwiPjxzdG9wIG9mZnNldD1cXFwiMCVcXFwiIHN0b3AtY29sb3I9XFxcIiNGRkUwNTJcXFwiLz48c3RvcCBvZmZzZXQ9XFxcIjEwMCVcXFwiIHN0b3AtY29sb3I9XFxcIiNGRkMzMzFcXFwiLz48L2xpbmVhckdyYWRpZW50PjwvZGVmcz48cGF0aCBmaWxsPVxcXCJ1cmwoI3N2Z0lEYSlcXFwiIGQ9XFxcIk0xMjYuOTE2LjA3MmMtNjQuODMyIDAtNjAuNzg0IDI4LjExNS02MC43ODQgMjguMTE1bC4wNzIgMjkuMTI4aDYxLjg2OHY4Ljc0NUg0MS42MzFTLjE0NSA2MS4zNTUuMTQ1IDEyNi43N2MwIDY1LjQxNyAzNi4yMSA2My4wOTcgMzYuMjEgNjMuMDk3aDIxLjYxdi0zMC4zNTZzLTEuMTY1LTM2LjIxIDM1LjYzMi0zNi4yMWg2MS4zNjJzMzQuNDc1LjU1NyAzNC40NzUtMzMuMzE5VjMzLjk3UzE5NC42Ny4wNzIgMTI2LjkxNi4wNzJaTTkyLjgwMiAxOS42NmExMS4xMiAxMS4xMiAwIDAgMSAxMS4xMyAxMS4xM2ExMS4xMiAxMS4xMiAwIDAgMS0xMS4xMyAxMS4xM2ExMS4xMiAxMS4xMiAwIDAgMS0xMS4xMy0xMS4xM2ExMS4xMiAxMS4xMiAwIDAgMSAxMS4xMy0xMS4xM1pcXFwiLz48cGF0aCBmaWxsPVxcXCJ1cmwoI3N2Z0lEYilcXFwiIGQ9XFxcIk0xMjguNzU3IDI1NC4xMjZjNjQuODMyIDAgNjAuNzg0LTI4LjExNSA2MC43ODQtMjguMTE1bC0uMDcyLTI5LjEyN0gxMjcuNnYtOC43NDVoODYuNDQxczQxLjQ4NiA0LjcwNSA0MS40ODYtNjAuNzEyYzAtNjUuNDE2LTM2LjIxLTYzLjA5Ni0zNi4yMS02My4wOTZoLTIxLjYxdjMwLjM1NXMxLjE2NSAzNi4yMS0zNS42MzIgMzYuMjFoLTYxLjM2MnMtMzQuNDc1LS41NTctMzQuNDc1IDMzLjMydjU2LjAxM3MtNS4yMzUgMzMuODk3IDYyLjUxOCAzMy44OTdabTM0LjExNC0xOS41ODZhMTEuMTIgMTEuMTIgMCAwIDEtMTEuMTMtMTEuMTNhMTEuMTIgMTEuMTIgMCAwIDEgMTEuMTMtMTEuMTMxYTExLjEyIDExLjEyIDAgMCAxIDExLjEzIDExLjEzYTExLjEyIDExLjEyIDAgMCAxLTExLjEzIDExLjEzWlxcXCIvPlwiLFxuXHRcIndpZHRoXCI6IDI1Nixcblx0XCJoZWlnaHRcIjogMjU1XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRhdGE7XG4iLCAiLyohXG4gIENvcHlyaWdodCAoYykgMjAxOCBKZWQgV2F0c29uLlxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UgKE1JVCksIHNlZVxuICBodHRwOi8vamVkd2F0c29uLmdpdGh1Yi5pby9jbGFzc25hbWVzXG4qL1xuLyogZ2xvYmFsIGRlZmluZSAqL1xuXG4oZnVuY3Rpb24gKCkge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGlmIChhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKGFyZy50b1N0cmluZyA9PT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBhcmcpIHtcblx0XHRcdFx0XHRcdGlmIChoYXNPd24uY2FsbChhcmcsIGtleSkgJiYgYXJnW2tleV0pIHtcblx0XHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH1cblxuXHRpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0XHRjbGFzc05hbWVzLmRlZmF1bHQgPSBjbGFzc05hbWVzO1xuXHRcdG1vZHVsZS5leHBvcnRzID0gY2xhc3NOYW1lcztcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09PSAnb2JqZWN0JyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gcmVnaXN0ZXIgYXMgJ2NsYXNzbmFtZXMnLCBjb25zaXN0ZW50IHdpdGggbnBtIHBhY2thZ2UgbmFtZVxuXHRcdGRlZmluZSgnY2xhc3NuYW1lcycsIFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gY2xhc3NOYW1lcztcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHR3aW5kb3cuY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXM7XG5cdH1cbn0oKSk7XG4iLCAiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gMHhlYWNhO1xuZXhwb3J0cy5GcmFnbWVudCA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSAweGVhZDk7XG52YXIgUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUgPSAweGVhZGE7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IDB4ZWFkNTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gMHhlYWQ3O1xudmFyIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gMHhlYWUwO1xudmFyIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gMHhlYWUxO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gMHhlYWUyO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IDB4ZWFlMztcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgUkVBQ1RfRUxFTUVOVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX1BPUlRBTF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5wb3J0YWwnKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHN5bWJvbEZvcigncmVhY3QuZnJhZ21lbnQnKTtcbiAgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbiAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvZmlsZXInKTtcbiAgUkVBQ1RfUFJPVklERVJfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucHJvdmlkZXInKTtcbiAgUkVBQ1RfQ09OVEVYVF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5jb250ZXh0Jyk7XG4gIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG4gIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG4gIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xuICBSRUFDVF9NRU1PX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm1lbW8nKTtcbiAgUkVBQ1RfTEFaWV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sYXp5Jyk7XG4gIFJFQUNUX0JMT0NLX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmJsb2NrJyk7XG4gIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zZXJ2ZXIuYmxvY2snKTtcbiAgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZnVuZGFtZW50YWwnKTtcbiAgUkVBQ1RfU0NPUEVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2NvcGUnKTtcbiAgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9wYXF1ZS5pZCcpO1xuICBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZGVidWdfdHJhY2VfbW9kZScpO1xuICBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG4gIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGVnYWN5X2hpZGRlbicpO1xufVxuXG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuXG4gICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfVxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiAnJyArIGl0ZW07XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyBGaWx0ZXIgY2VydGFpbiBET00gYXR0cmlidXRlcyAoZS5nLiBzcmMsIGhyZWYpIGlmIHRoZWlyIHZhbHVlcyBhcmUgZW1wdHkgc3RyaW5ncy5cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gZXhwb3J0cy5GcmFnbWVudCB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUgfHwgdHlwZVswXSA9PT0gUkVBQ1RfU0VSVkVSX0JMT0NLX1RZUEUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgZXhwb3J0cy5GcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZSh0eXBlLl9yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gUmV0dXJuIHRoZSBsaW5lIHdlIGZvdW5kLlxuXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgJiYgYyA+PSAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICByZWVudHJ5ID0gZmFsc2U7XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLCBzb3VyY2UsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgICBjYXNlIFJFQUNUX0JMT0NLX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuc3RhdGVOb2RlICE9PSBzZWxmKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3Rqcy9yZmNzL3B1bGwvMTA3XG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICovXG5cbmZ1bmN0aW9uIGpzeERFVih0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFR5cGVzO1xuXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCAvLyBOb3RlOiBNZW1vIG9ubHkgY2hlY2tzIG91dGVyIHByb3BzIGhlcmUuXG4gICAgLy8gSW5uZXIgcHJvcHMgYXJlIGNoZWNrZWQgaW4gdGhlIHJlY29uY2lsZXIuXG4gICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvcFR5cGVzKSB7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGluc2lkZSB0byBhdm9pZCB0cmlnZ2VyaW5nIGxhenkgaW5pdGlhbGl6ZXJzOlxuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG4vLyBldmVuIHdpdGggdGhlIHByb2QgdHJhbnNmb3JtLiBUaGlzIG1lYW5zIHRoYXQganN4REVWIGlzIHB1cmVseVxuLy8gb3B0LWluIGJlaGF2aW9yIGZvciBiZXR0ZXIgbWVzc2FnZXMgYnV0IHRoYXQgd2Ugd29uJ3Qgc3RvcFxuLy8gZ2l2aW5nIHlvdSB3YXJuaW5ncyBpZiB5b3UgdXNlIHByb2R1Y3Rpb24gYXBpcy5cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25TdGF0aWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGZhbHNlKTtcbiAgfVxufVxuXG52YXIganN4ID0gIGpzeFdpdGhWYWxpZGF0aW9uRHluYW1pYyA7IC8vIHdlIG1heSB3YW50IHRvIHNwZWNpYWwgY2FzZSBqc3hzIGludGVybmFsbHkgdG8gdGFrZSBhZHZhbnRhZ2Ugb2Ygc3RhdGljIGNoaWxkcmVuLlxuLy8gZm9yIG5vdyB3ZSBjYW4gc2hpcCBpZGVudGljYWwgcHJvZCBmdW5jdGlvbnNcblxudmFyIGpzeHMgPSAganN4V2l0aFZhbGlkYXRpb25TdGF0aWMgO1xuXG5leHBvcnRzLmpzeCA9IGpzeDtcbmV4cG9ydHMuanN4cyA9IGpzeHM7XG4gIH0pKCk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCAiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xMy4xXG4gKiByZWFjdC1pcy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIGhhc1N5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKSA6IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKSA6IDB4ZWFkMjtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKSA6IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0JykgOiAweGVhY2U7IC8vIFRPRE86IFdlIGRvbid0IHVzZSBBc3luY01vZGUgb3IgQ29uY3VycmVudE1vZGUgYW55bW9yZS4gVGhleSB3ZXJlIHRlbXBvcmFyeVxuLy8gKHVuc3RhYmxlKSBBUElzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuIENhbiB3ZSByZW1vdmUgdGhlIHN5bWJvbHM/XG5cbnZhciBSRUFDVF9BU1lOQ19NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5hc3luY19tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5jb25jdXJyZW50X21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKSA6IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKSA6IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0JykgOiAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubWVtbycpIDogMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKSA6IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYmxvY2snKSA6IDB4ZWFkOTtcbnZhciBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZnVuZGFtZW50YWwnKSA6IDB4ZWFkNTtcbnZhciBSRUFDVF9SRVNQT05ERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnJlc3BvbmRlcicpIDogMHhlYWQ2O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zY29wZScpIDogMHhlYWQ3O1xuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IC8vIE5vdGU6IGl0cyB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyBpZiBpdCdzIGEgcG9seWZpbGwuXG4gIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9SRVNQT05ERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9TQ09QRV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0JMT0NLX1RZUEUpO1xufVxuXG5mdW5jdGlvbiB0eXBlT2Yob2JqZWN0KSB7XG4gIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBvYmplY3QuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKCQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgdmFyIHR5cGUgPSBvYmplY3QudHlwZTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0FTWU5DX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHZhciAkJHR5cGVvZlR5cGUgPSB0eXBlICYmIHR5cGUuJCR0eXBlb2Y7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoJCR0eXBlb2ZUeXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZlR5cGU7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICByZXR1cm4gJCR0eXBlb2Y7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn0gLy8gQXN5bmNNb2RlIGlzIGRlcHJlY2F0ZWQgYWxvbmcgd2l0aCBpc0FzeW5jTW9kZVxuXG52YXIgQXN5bmNNb2RlID0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xudmFyIENvbmN1cnJlbnRNb2RlID0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG52YXIgQ29udGV4dENvbnN1bWVyID0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xudmFyIENvbnRleHRQcm92aWRlciA9IFJFQUNUX1BST1ZJREVSX1RZUEU7XG52YXIgRWxlbWVudCA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcbnZhciBGb3J3YXJkUmVmID0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbnZhciBGcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG52YXIgTGF6eSA9IFJFQUNUX0xBWllfVFlQRTtcbnZhciBNZW1vID0gUkVBQ1RfTUVNT19UWVBFO1xudmFyIFBvcnRhbCA9IFJFQUNUX1BPUlRBTF9UWVBFO1xudmFyIFByb2ZpbGVyID0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbnZhciBTdHJpY3RNb2RlID0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbnZhciBTdXNwZW5zZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG52YXIgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSBmYWxzZTsgLy8gQXN5bmNNb2RlIHNob3VsZCBiZSBkZXByZWNhdGVkXG5cbmZ1bmN0aW9uIGlzQXN5bmNNb2RlKG9iamVjdCkge1xuICB7XG4gICAgaWYgKCFoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSkge1xuICAgICAgaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUgPSB0cnVlOyAvLyBVc2luZyBjb25zb2xlWyd3YXJuJ10gdG8gZXZhZGUgQmFiZWwgYW5kIEVTTGludFxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJ1RoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgJyArICdhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE3Ky4gVXBkYXRlIHlvdXIgY29kZSB0byB1c2UgJyArICdSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBpbnN0ZWFkLiBJdCBoYXMgdGhlIGV4YWN0IHNhbWUgQVBJLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkgfHwgdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05URVhUX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9WSURFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNGb3J3YXJkUmVmKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZyYWdtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0xhenkob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTEFaWV9UWVBFO1xufVxuZnVuY3Rpb24gaXNNZW1vKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX01FTU9fVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUG9ydGFsKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BPUlRBTF9UWVBFO1xufVxuZnVuY3Rpb24gaXNQcm9maWxlcihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdHJpY3RNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N1c3BlbnNlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG59XG5cbmV4cG9ydHMuQXN5bmNNb2RlID0gQXN5bmNNb2RlO1xuZXhwb3J0cy5Db25jdXJyZW50TW9kZSA9IENvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLkNvbnRleHRQcm92aWRlciA9IENvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuRWxlbWVudCA9IEVsZW1lbnQ7XG5leHBvcnRzLkZvcndhcmRSZWYgPSBGb3J3YXJkUmVmO1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5MYXp5ID0gTGF6eTtcbmV4cG9ydHMuTWVtbyA9IE1lbW87XG5leHBvcnRzLlBvcnRhbCA9IFBvcnRhbDtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IFN0cmljdE1vZGU7XG5leHBvcnRzLlN1c3BlbnNlID0gU3VzcGVuc2U7XG5leHBvcnRzLmlzQXN5bmNNb2RlID0gaXNBc3luY01vZGU7XG5leHBvcnRzLmlzQ29uY3VycmVudE1vZGUgPSBpc0NvbmN1cnJlbnRNb2RlO1xuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGlzQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGlzQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGlzRm9yd2FyZFJlZjtcbmV4cG9ydHMuaXNGcmFnbWVudCA9IGlzRnJhZ21lbnQ7XG5leHBvcnRzLmlzTGF6eSA9IGlzTGF6eTtcbmV4cG9ydHMuaXNNZW1vID0gaXNNZW1vO1xuZXhwb3J0cy5pc1BvcnRhbCA9IGlzUG9ydGFsO1xuZXhwb3J0cy5pc1Byb2ZpbGVyID0gaXNQcm9maWxlcjtcbmV4cG9ydHMuaXNTdHJpY3RNb2RlID0gaXNTdHJpY3RNb2RlO1xuZXhwb3J0cy5pc1N1c3BlbnNlID0gaXNTdXNwZW5zZTtcbmV4cG9ydHMuaXNWYWxpZEVsZW1lbnRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlO1xuZXhwb3J0cy50eXBlT2YgPSB0eXBlT2Y7XG4gIH0pKCk7XG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iLCAiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iLCAibW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG4iLCAiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIHZhciBoYXMgPSByZXF1aXJlKCcuL2xpYi9oYXMnKTtcblxuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkgeyAvKiovIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoXG4gICAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAgICAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgK1xuICAgICAgICAgICAgICAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAnICtcbiAgICAgICAgICAgIGxvY2F0aW9uICsgJyBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJyArIHR5cGVvZiBlcnJvciArICcuICcgK1xuICAgICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArXG4gICAgICAgICAgICAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAnRmFpbGVkICcgKyBsb2NhdGlvbiArICcgdHlwZTogJyArIGVycm9yLm1lc3NhZ2UgKyAoc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlc2V0cyB3YXJuaW5nIGNhY2hlIHdoZW4gdGVzdGluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5jaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG4iLCAiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBiaWdpbnQ6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdiaWdpbnQnKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhOiB7fTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSxcbiAgICAgICAgICB7ZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGV9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIGV4cGVjdGVkVHlwZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIHZhciBjaGVja2VyUmVzdWx0ID0gY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0LmRhdGEgJiYgaGFzKGNoZWNrZXJSZXN1bHQuZGF0YSwgJ2V4cGVjdGVkVHlwZScpKSB7XG4gICAgICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGNoZWNrZXJSZXN1bHQuZGF0YS5leHBlY3RlZFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgPSAoZXhwZWN0ZWRUeXBlcy5sZW5ndGggPiAwKSA/ICcsIGV4cGVjdGVkIG9uZSBvZiB0eXBlIFsnICsgZXhwZWN0ZWRUeXBlcy5qb2luKCcsICcpICsgJ10nOiAnJztcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AnICsgZXhwZWN0ZWRUeXBlc01lc3NhZ2UgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHByb3BGdWxsTmFtZSArICcuJyArIGtleSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZSArICdgLidcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb20gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoaGFzKHNoYXBlVHlwZXMsIGtleSkgJiYgdHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIGZhbHN5IHZhbHVlIGNhbid0IGJlIGEgU3ltYm9sXG4gICAgaWYgKCFwcm9wVmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZSA9IGNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuIiwgIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxudmFyIF9jbGFzc25hbWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xhc3NuYW1lc1wiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IFZlcnRpY2FsVGltZWxpbmUgPSAoe1xuICBhbmltYXRlLFxuICBjbGFzc05hbWUsXG4gIGxheW91dCxcbiAgbGluZUNvbG9yLFxuICBjaGlsZHJlblxufSkgPT4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tbGluZS1jb2xvcicsIGxpbmVDb2xvcik7XG4gIH1cblxuICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzLmRlZmF1bHQpKGNsYXNzTmFtZSwgJ3ZlcnRpY2FsLXRpbWVsaW5lJywge1xuICAgICAgJ3ZlcnRpY2FsLXRpbWVsaW5lLS1hbmltYXRlJzogYW5pbWF0ZSxcbiAgICAgICd2ZXJ0aWNhbC10aW1lbGluZS0tdHdvLWNvbHVtbnMnOiBsYXlvdXQgPT09ICcyLWNvbHVtbnMnLFxuICAgICAgJ3ZlcnRpY2FsLXRpbWVsaW5lLS1vbmUtY29sdW1uLWxlZnQnOiBsYXlvdXQgPT09ICcxLWNvbHVtbicgfHwgbGF5b3V0ID09PSAnMS1jb2x1bW4tbGVmdCcsXG4gICAgICAndmVydGljYWwtdGltZWxpbmUtLW9uZS1jb2x1bW4tcmlnaHQnOiBsYXlvdXQgPT09ICcxLWNvbHVtbi1yaWdodCdcbiAgICB9KVxuICB9LCBjaGlsZHJlbik7XG59O1xuXG5WZXJ0aWNhbFRpbWVsaW5lLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMuZGVmYXVsdC5hcnJheU9mKF9wcm9wVHlwZXMuZGVmYXVsdC5ub2RlKSwgX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGVdKS5pc1JlcXVpcmVkLFxuICBjbGFzc05hbWU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIGFuaW1hdGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5ib29sLFxuICBsYXlvdXQ6IF9wcm9wVHlwZXMuZGVmYXVsdC5vbmVPZihbJzEtY29sdW1uLWxlZnQnLCAnMS1jb2x1bW4nLCAnMi1jb2x1bW5zJywgJzEtY29sdW1uLXJpZ2h0J10pLFxuICBsaW5lQ29sb3I6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmdcbn07XG5WZXJ0aWNhbFRpbWVsaW5lLmRlZmF1bHRQcm9wcyA9IHtcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgY2xhc3NOYW1lOiAnJyxcbiAgbGF5b3V0OiAnMi1jb2x1bW5zJyxcbiAgbGluZUNvbG9yOiAnI0ZGRidcbn07XG52YXIgX2RlZmF1bHQgPSBWZXJ0aWNhbFRpbWVsaW5lO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwgImltcG9ydCB7IE9ic2VydmVySW5zdGFuY2VDYWxsYmFjayB9IGZyb20gJy4vaW5kZXgnO1xuXG5jb25zdCBvYnNlcnZlck1hcCA9IG5ldyBNYXA8XG4gIHN0cmluZyxcbiAge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgb2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyO1xuICAgIGVsZW1lbnRzOiBNYXA8RWxlbWVudCwgQXJyYXk8T2JzZXJ2ZXJJbnN0YW5jZUNhbGxiYWNrPj47XG4gIH1cbj4oKTtcblxuY29uc3QgUm9vdElkczogV2Vha01hcDxFbGVtZW50IHwgRG9jdW1lbnQsIHN0cmluZz4gPSBuZXcgV2Vha01hcCgpO1xubGV0IHJvb3RJZCA9IDA7XG5cbmxldCB1bnN1cHBvcnRlZFZhbHVlOiBib29sZWFuIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4vKipcbiAqIFdoYXQgc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlmIHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlciBpcyB1bnN1cHBvcnRlZD9cbiAqIElkZWFsbHkgdGhlIHBvbHlmaWxsIGhhcyBiZWVuIGxvYWRlZCwgeW91IGNhbiBoYXZlIHRoZSBmb2xsb3dpbmcgaGFwcGVuOlxuICogLSBgdW5kZWZpbmVkYDogVGhyb3cgYW4gZXJyb3JcbiAqIC0gYHRydWVgIG9yIGBmYWxzZWA6IFNldCB0aGUgYGluVmlld2AgdmFsdWUgdG8gdGhpcyByZWdhcmRsZXNzIG9mIGludGVyc2VjdGlvbiBzdGF0ZVxuICogKiovXG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdEZhbGxiYWNrSW5WaWV3KGluVmlldzogYm9vbGVhbiB8IHVuZGVmaW5lZCkge1xuICB1bnN1cHBvcnRlZFZhbHVlID0gaW5WaWV3O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciB0aGUgcm9vdCBlbGVtZW50XG4gKiBAcGFyYW0gcm9vdFxuICovXG5mdW5jdGlvbiBnZXRSb290SWQocm9vdDogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0Wydyb290J10pIHtcbiAgaWYgKCFyb290KSByZXR1cm4gJzAnO1xuICBpZiAoUm9vdElkcy5oYXMocm9vdCkpIHJldHVybiBSb290SWRzLmdldChyb290KTtcbiAgcm9vdElkICs9IDE7XG4gIFJvb3RJZHMuc2V0KHJvb3QsIHJvb3RJZC50b1N0cmluZygpKTtcbiAgcmV0dXJuIFJvb3RJZHMuZ2V0KHJvb3QpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIG9wdGlvbnMgdG8gYSBzdHJpbmcgSWQsIGJhc2VkIG9uIHRoZSB2YWx1ZXMuXG4gKiBFbnN1cmVzIHdlIGNhbiByZXVzZSB0aGUgc2FtZSBvYnNlcnZlciB3aGVuIG9ic2VydmluZyBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uc1RvSWQob3B0aW9uczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgIC5zb3J0KClcbiAgICAuZmlsdGVyKChrZXkpID0+IG9wdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkKVxuICAgIC5tYXAoKGtleSkgPT4ge1xuICAgICAgcmV0dXJuIGAke2tleX1fJHtcbiAgICAgICAga2V5ID09PSAncm9vdCcgPyBnZXRSb290SWQob3B0aW9ucy5yb290KSA6IG9wdGlvbnNba2V5XVxuICAgICAgfWA7XG4gICAgfSlcbiAgICAudG9TdHJpbmcoKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9uczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0KSB7XG4gIC8vIENyZWF0ZSBhIHVuaXF1ZSBJRCBmb3IgdGhpcyBvYnNlcnZlciBpbnN0YW5jZSwgYmFzZWQgb24gdGhlIHJvb3QsIHJvb3QgbWFyZ2luIGFuZCB0aHJlc2hvbGQuXG4gIGxldCBpZCA9IG9wdGlvbnNUb0lkKG9wdGlvbnMpO1xuICBsZXQgaW5zdGFuY2UgPSBvYnNlcnZlck1hcC5nZXQoaWQpO1xuXG4gIGlmICghaW5zdGFuY2UpIHtcbiAgICAvLyBDcmVhdGUgYSBtYXAgb2YgZWxlbWVudHMgdGhpcyBvYnNlcnZlciBpcyBnb2luZyB0byBvYnNlcnZlLiBFYWNoIGVsZW1lbnQgaGFzIGEgbGlzdCBvZiBjYWxsYmFja3MgdGhhdCBzaG91bGQgYmUgdHJpZ2dlcmVkLCBvbmNlIGl0IGNvbWVzIGludG8gdmlldy5cbiAgICBjb25zdCBlbGVtZW50cyA9IG5ldyBNYXA8RWxlbWVudCwgQXJyYXk8T2JzZXJ2ZXJJbnN0YW5jZUNhbGxiYWNrPj4oKTtcbiAgICBsZXQgdGhyZXNob2xkczogbnVtYmVyW10gfCByZWFkb25seSBudW1iZXJbXTtcblxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgIC8vIFdoaWxlIGl0IHdvdWxkIGJlIG5pY2UgaWYgeW91IGNvdWxkIGp1c3QgbG9vayBhdCBpc0ludGVyc2VjdGluZyB0byBkZXRlcm1pbmUgaWYgdGhlIGNvbXBvbmVudCBpcyBpbnNpZGUgdGhlIHZpZXdwb3J0LCBicm93c2VycyBjYW4ndCBhZ3JlZSBvbiBob3cgdG8gdXNlIGl0LlxuICAgICAgICAvLyAtRmlyZWZveCBpZ25vcmVzIGB0aHJlc2hvbGRgIHdoZW4gY29uc2lkZXJpbmcgYGlzSW50ZXJzZWN0aW5nYCwgc28gaXQgd2lsbCBuZXZlciBiZSBmYWxzZSBhZ2FpbiBpZiBgdGhyZXNob2xkYCBpcyA+IDBcbiAgICAgICAgY29uc3QgaW5WaWV3ID1cbiAgICAgICAgICBlbnRyeS5pc0ludGVyc2VjdGluZyAmJlxuICAgICAgICAgIHRocmVzaG9sZHMuc29tZSgodGhyZXNob2xkKSA9PiBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+PSB0aHJlc2hvbGQpO1xuXG4gICAgICAgIC8vIEB0cy1pZ25vcmUgc3VwcG9ydCBJbnRlcnNlY3Rpb25PYnNlcnZlciB2MlxuICAgICAgICBpZiAob3B0aW9ucy50cmFja1Zpc2liaWxpdHkgJiYgdHlwZW9mIGVudHJ5LmlzVmlzaWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBUaGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgSW50ZXJzZWN0aW9uIE9ic2VydmVyIHYyLCBmYWxsaW5nIGJhY2sgdG8gdjEgYmVoYXZpb3IuXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGVudHJ5LmlzVmlzaWJsZSA9IGluVmlldztcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpPy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKGluVmlldywgZW50cnkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gRW5zdXJlIHdlIGhhdmUgYSB2YWxpZCB0aHJlc2hvbGRzIGFycmF5LiBJZiBub3QsIHVzZSB0aGUgdGhyZXNob2xkIGZyb20gdGhlIG9wdGlvbnNcbiAgICB0aHJlc2hvbGRzID1cbiAgICAgIG9ic2VydmVyLnRocmVzaG9sZHMgfHxcbiAgICAgIChBcnJheS5pc0FycmF5KG9wdGlvbnMudGhyZXNob2xkKVxuICAgICAgICA/IG9wdGlvbnMudGhyZXNob2xkXG4gICAgICAgIDogW29wdGlvbnMudGhyZXNob2xkIHx8IDBdKTtcblxuICAgIGluc3RhbmNlID0ge1xuICAgICAgaWQsXG4gICAgICBvYnNlcnZlcixcbiAgICAgIGVsZW1lbnRzLFxuICAgIH07XG5cbiAgICBvYnNlcnZlck1hcC5zZXQoaWQsIGluc3RhbmNlKTtcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gZWxlbWVudCAtIERPTSBFbGVtZW50IHRvIG9ic2VydmVcbiAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHRyaWdnZXIgd2hlbiBpbnRlcnNlY3Rpb24gc3RhdHVzIGNoYW5nZXNcbiAqIEBwYXJhbSBvcHRpb25zIC0gSW50ZXJzZWN0aW9uIE9ic2VydmVyIG9wdGlvbnNcbiAqIEBwYXJhbSBmYWxsYmFja0luVmlldyAtIEZhbGxiYWNrIGluVmlldyB2YWx1ZS5cbiAqIEByZXR1cm4gRnVuY3Rpb24gLSBDbGVhbnVwIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIHRyaWdnZXJlZCB0byB1bnJlZ2lzdGVyIHRoZSBvYnNlcnZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZShcbiAgZWxlbWVudDogRWxlbWVudCxcbiAgY2FsbGJhY2s6IE9ic2VydmVySW5zdGFuY2VDYWxsYmFjayxcbiAgb3B0aW9uczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0ID0ge30sXG4gIGZhbGxiYWNrSW5WaWV3ID0gdW5zdXBwb3J0ZWRWYWx1ZSxcbikge1xuICBpZiAoXG4gICAgdHlwZW9mIHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBmYWxsYmFja0luVmlldyAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIGNvbnN0IGJvdW5kcyA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY2FsbGJhY2soZmFsbGJhY2tJblZpZXcsIHtcbiAgICAgIGlzSW50ZXJzZWN0aW5nOiBmYWxsYmFja0luVmlldyxcbiAgICAgIHRhcmdldDogZWxlbWVudCxcbiAgICAgIGludGVyc2VjdGlvblJhdGlvOlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy50aHJlc2hvbGQgPT09ICdudW1iZXInID8gb3B0aW9ucy50aHJlc2hvbGQgOiAwLFxuICAgICAgdGltZTogMCxcbiAgICAgIGJvdW5kaW5nQ2xpZW50UmVjdDogYm91bmRzLFxuICAgICAgaW50ZXJzZWN0aW9uUmVjdDogYm91bmRzLFxuICAgICAgcm9vdEJvdW5kczogYm91bmRzLFxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGNsZWFudXBcbiAgICB9O1xuICB9XG4gIC8vIEFuIG9ic2VydmVyIHdpdGggdGhlIHNhbWUgb3B0aW9ucyBjYW4gYmUgcmV1c2VkLCBzbyBsZXRzIHVzZSB0aGlzIGZhY3RcbiAgY29uc3QgeyBpZCwgb2JzZXJ2ZXIsIGVsZW1lbnRzIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKTtcblxuICAvLyBSZWdpc3RlciB0aGUgY2FsbGJhY2sgbGlzdGVuZXIgZm9yIHRoaXMgZWxlbWVudFxuICBsZXQgY2FsbGJhY2tzID0gZWxlbWVudHMuZ2V0KGVsZW1lbnQpIHx8IFtdO1xuICBpZiAoIWVsZW1lbnRzLmhhcyhlbGVtZW50KSkge1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFja3MpO1xuICB9XG5cbiAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpO1xuXG4gIHJldHVybiBmdW5jdGlvbiB1bm9ic2VydmUoKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIHRoZSBjYWxsYmFjayBsaXN0XG4gICAgY2FsbGJhY2tzLnNwbGljZShjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuXG4gICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIG1vcmUgY2FsbGJhY2sgZXhpc3RzIGZvciBlbGVtZW50LCBzbyBkZXN0cm95IGl0XG4gICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgIC8vIE5vIG1vcmUgZWxlbWVudHMgYXJlIGJlaW5nIG9ic2VydmVyIGJ5IHRoaXMgaW5zdGFuY2UsIHNvIGRlc3Ryb3kgaXRcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIG9ic2VydmVyTWFwLmRlbGV0ZShpZCk7XG4gICAgfVxuICB9O1xufVxuIiwgImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEludGVyc2VjdGlvbk9ic2VydmVyUHJvcHMsIFBsYWluQ2hpbGRyZW5Qcm9wcyB9IGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgb2JzZXJ2ZSB9IGZyb20gJy4vb2JzZXJ2ZSc7XG5cbnR5cGUgU3RhdGUgPSB7XG4gIGluVmlldzogYm9vbGVhbjtcbiAgZW50cnk/OiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5O1xufTtcblxuZnVuY3Rpb24gaXNQbGFpbkNoaWxkcmVuKFxuICBwcm9wczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJQcm9wcyB8IFBsYWluQ2hpbGRyZW5Qcm9wcyxcbik6IHByb3BzIGlzIFBsYWluQ2hpbGRyZW5Qcm9wcyB7XG4gIHJldHVybiB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gIT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICMjIFJlbmRlciBwcm9wc1xuXG4gVG8gdXNlIHRoZSBgPEluVmlldz5gIGNvbXBvbmVudCwgeW91IHBhc3MgaXQgYSBmdW5jdGlvbi4gSXQgd2lsbCBiZSBjYWxsZWRcbiB3aGVuZXZlciB0aGUgc3RhdGUgY2hhbmdlcywgd2l0aCB0aGUgbmV3IHZhbHVlIG9mIGBpblZpZXdgLiBJbiBhZGRpdGlvbiB0byB0aGVcbiBgaW5WaWV3YCBwcm9wLCBjaGlsZHJlbiBhbHNvIHJlY2VpdmUgYSBgcmVmYCB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlXG4gY29udGFpbmluZyBET00gZWxlbWVudC4gVGhpcyBpcyB0aGUgZWxlbWVudCB0aGF0IHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlciB3aWxsXG4gbW9uaXRvci5cblxuIElmIHlvdSBuZWVkIGl0LCB5b3UgY2FuIGFsc28gYWNjZXNzIHRoZVxuIFtgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KVxuIG9uIGBlbnRyeWAsIGdpdmluZyB5b3UgYWNjZXNzIHRvIGFsbCB0aGUgZGV0YWlscyBhYm91dCB0aGUgY3VycmVudCBpbnRlcnNlY3Rpb25cbiBzdGF0ZS5cblxuIGBgYGpzeFxuIGltcG9ydCB7IEluVmlldyB9IGZyb20gJ3JlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlcic7XG5cbiBjb25zdCBDb21wb25lbnQgPSAoKSA9PiAoXG4gPEluVmlldz5cbiB7KHsgaW5WaWV3LCByZWYsIGVudHJ5IH0pID0+IChcbiAgICAgIDxkaXYgcmVmPXtyZWZ9PlxuICAgICAgICA8aDI+e2BIZWFkZXIgaW5zaWRlIHZpZXdwb3J0ICR7aW5WaWV3fS5gfTwvaDI+XG4gICAgICA8L2Rpdj5cbiAgICApfVxuIDwvSW5WaWV3PlxuICk7XG5cbiBleHBvcnQgZGVmYXVsdCBDb21wb25lbnQ7XG4gYGBgXG5cbiAjIyBQbGFpbiBjaGlsZHJlblxuXG4gWW91IGNhbiBwYXNzIGFueSBlbGVtZW50IHRvIHRoZSBgPEluVmlldyAvPmAsIGFuZCBpdCB3aWxsIGhhbmRsZSBjcmVhdGluZyB0aGVcbiB3cmFwcGluZyBET00gZWxlbWVudC4gQWRkIGEgaGFuZGxlciB0byB0aGUgYG9uQ2hhbmdlYCBtZXRob2QsIGFuZCBjb250cm9sIHRoZVxuIHN0YXRlIGluIHlvdXIgb3duIGNvbXBvbmVudC4gQW55IGV4dHJhIHByb3BzIHlvdSBhZGQgdG8gYDxJblZpZXc+YCB3aWxsIGJlXG4gcGFzc2VkIHRvIHRoZSBIVE1MIGVsZW1lbnQsIGFsbG93aW5nIHlvdSBzZXQgdGhlIGBjbGFzc05hbWVgLCBgc3R5bGVgLCBldGMuXG5cbiBgYGBqc3hcbiBpbXBvcnQgeyBJblZpZXcgfSBmcm9tICdyZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXInO1xuXG4gY29uc3QgQ29tcG9uZW50ID0gKCkgPT4gKFxuIDxJblZpZXcgYXM9XCJkaXZcIiBvbkNoYW5nZT17KGluVmlldywgZW50cnkpID0+IGNvbnNvbGUubG9nKCdJbnZpZXc6JywgaW5WaWV3KX0+XG4gPGgyPlBsYWluIGNoaWxkcmVuIGFyZSBhbHdheXMgcmVuZGVyZWQuIFVzZSBvbkNoYW5nZSB0byBtb25pdG9yIHN0YXRlLjwvaDI+XG4gPC9JblZpZXc+XG4gKTtcblxuIGV4cG9ydCBkZWZhdWx0IENvbXBvbmVudDtcbiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEluVmlldyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxcbiAgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJQcm9wcyB8IFBsYWluQ2hpbGRyZW5Qcm9wcyxcbiAgU3RhdGVcbj4ge1xuICBzdGF0aWMgZGlzcGxheU5hbWUgPSAnSW5WaWV3JztcbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICB0aHJlc2hvbGQ6IDAsXG4gICAgdHJpZ2dlck9uY2U6IGZhbHNlLFxuICAgIGluaXRpYWxJblZpZXc6IGZhbHNlLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBJbnRlcnNlY3Rpb25PYnNlcnZlclByb3BzIHwgUGxhaW5DaGlsZHJlblByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpblZpZXc6ICEhcHJvcHMuaW5pdGlhbEluVmlldyxcbiAgICAgIGVudHJ5OiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IEludGVyc2VjdGlvbk9ic2VydmVyUHJvcHMpIHtcbiAgICAvLyBJZiBhIEludGVyc2VjdGlvbk9ic2VydmVyIG9wdGlvbiBjaGFuZ2VkLCByZWluaXQgdGhlIG9ic2VydmVyXG4gICAgaWYgKFxuICAgICAgcHJldlByb3BzLnJvb3RNYXJnaW4gIT09IHRoaXMucHJvcHMucm9vdE1hcmdpbiB8fFxuICAgICAgcHJldlByb3BzLnJvb3QgIT09IHRoaXMucHJvcHMucm9vdCB8fFxuICAgICAgcHJldlByb3BzLnRocmVzaG9sZCAhPT0gdGhpcy5wcm9wcy50aHJlc2hvbGQgfHxcbiAgICAgIHByZXZQcm9wcy5za2lwICE9PSB0aGlzLnByb3BzLnNraXAgfHxcbiAgICAgIHByZXZQcm9wcy50cmFja1Zpc2liaWxpdHkgIT09IHRoaXMucHJvcHMudHJhY2tWaXNpYmlsaXR5IHx8XG4gICAgICBwcmV2UHJvcHMuZGVsYXkgIT09IHRoaXMucHJvcHMuZGVsYXlcbiAgICApIHtcbiAgICAgIHRoaXMudW5vYnNlcnZlKCk7XG4gICAgICB0aGlzLm9ic2VydmVOb2RlKCk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy51bm9ic2VydmUoKTtcbiAgICB0aGlzLm5vZGUgPSBudWxsO1xuICB9XG5cbiAgbm9kZTogRWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBfdW5vYnNlcnZlQ2I6ICgoKSA9PiB2b2lkKSB8IG51bGwgPSBudWxsO1xuXG4gIG9ic2VydmVOb2RlKCkge1xuICAgIGlmICghdGhpcy5ub2RlIHx8IHRoaXMucHJvcHMuc2tpcCkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIHJvb3QsXG4gICAgICByb290TWFyZ2luLFxuICAgICAgdHJhY2tWaXNpYmlsaXR5LFxuICAgICAgZGVsYXksXG4gICAgICBmYWxsYmFja0luVmlldyxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIHRoaXMuX3Vub2JzZXJ2ZUNiID0gb2JzZXJ2ZShcbiAgICAgIHRoaXMubm9kZSxcbiAgICAgIHRoaXMuaGFuZGxlQ2hhbmdlLFxuICAgICAge1xuICAgICAgICB0aHJlc2hvbGQsXG4gICAgICAgIHJvb3QsXG4gICAgICAgIHJvb3RNYXJnaW4sXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdHJhY2tWaXNpYmlsaXR5LFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRlbGF5LFxuICAgICAgfSxcbiAgICAgIGZhbGxiYWNrSW5WaWV3LFxuICAgICk7XG4gIH1cblxuICB1bm9ic2VydmUoKSB7XG4gICAgaWYgKHRoaXMuX3Vub2JzZXJ2ZUNiKSB7XG4gICAgICB0aGlzLl91bm9ic2VydmVDYigpO1xuICAgICAgdGhpcy5fdW5vYnNlcnZlQ2IgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZU5vZGUgPSAobm9kZT86IEVsZW1lbnQgfCBudWxsKSA9PiB7XG4gICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgLy8gQ2xlYXIgdGhlIG9sZCBvYnNlcnZlciwgYmVmb3JlIHdlIHN0YXJ0IG9ic2VydmluZyBhIG5ldyBlbGVtZW50XG4gICAgICB0aGlzLnVub2JzZXJ2ZSgpO1xuXG4gICAgICBpZiAoIW5vZGUgJiYgIXRoaXMucHJvcHMudHJpZ2dlck9uY2UgJiYgIXRoaXMucHJvcHMuc2tpcCkge1xuICAgICAgICAvLyBSZXNldCB0aGUgc3RhdGUgaWYgd2UgZ2V0IGEgbmV3IG5vZGUsIGFuZCB3ZSBhcmVuJ3QgaWdub3JpbmcgdXBkYXRlc1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgaW5WaWV3OiAhIXRoaXMucHJvcHMuaW5pdGlhbEluVmlldywgZW50cnk6IHVuZGVmaW5lZCB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLm5vZGUgPSBub2RlID8gbm9kZSA6IG51bGw7XG4gICAgdGhpcy5vYnNlcnZlTm9kZSgpO1xuICB9O1xuXG4gIGhhbmRsZUNoYW5nZSA9IChpblZpZXc6IGJvb2xlYW4sIGVudHJ5OiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KSA9PiB7XG4gICAgaWYgKGluVmlldyAmJiB0aGlzLnByb3BzLnRyaWdnZXJPbmNlKSB7XG4gICAgICAvLyBJZiBgdHJpZ2dlck9uY2VgIGlzIHRydWUsIHdlIHNob3VsZCBzdG9wIG9ic2VydmluZyB0aGUgZWxlbWVudC5cbiAgICAgIHRoaXMudW5vYnNlcnZlKCk7XG4gICAgfVxuICAgIGlmICghaXNQbGFpbkNoaWxkcmVuKHRoaXMucHJvcHMpKSB7XG4gICAgICAvLyBTdG9yZSB0aGUgY3VycmVudCBTdGF0ZSwgc28gd2UgY2FuIHBhc3MgaXQgdG8gdGhlIGNoaWxkcmVuIGluIHRoZSBuZXh0IHJlbmRlciB1cGRhdGVcbiAgICAgIC8vIFRoZXJlJ3Mgbm8gcmVhc29uIHRvIHVwZGF0ZSB0aGUgc3RhdGUgZm9yIHBsYWluIGNoaWxkcmVuLCBzaW5jZSBpdCdzIG5vdCB1c2VkIGluIHRoZSByZW5kZXJpbmcuXG4gICAgICB0aGlzLnNldFN0YXRlKHsgaW5WaWV3LCBlbnRyeSB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIGlzIGFjdGl2ZWx5IGxpc3RlbmluZyBmb3Igb25DaGFuZ2UsIGFsd2F5cyB0cmlnZ2VyIGl0XG4gICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKGluVmlldywgZW50cnkpO1xuICAgIH1cbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgaWYgKCFpc1BsYWluQ2hpbGRyZW4odGhpcy5wcm9wcykpIHtcbiAgICAgIGNvbnN0IHsgaW5WaWV3LCBlbnRyeSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuKHsgaW5WaWV3LCBlbnRyeSwgcmVmOiB0aGlzLmhhbmRsZU5vZGUgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgY2hpbGRyZW4sXG4gICAgICBhcyxcbiAgICAgIHRhZyxcbiAgICAgIHRyaWdnZXJPbmNlLFxuICAgICAgdGhyZXNob2xkLFxuICAgICAgcm9vdCxcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICBvbkNoYW5nZSxcbiAgICAgIHNraXAsXG4gICAgICB0cmFja1Zpc2liaWxpdHksXG4gICAgICBkZWxheSxcbiAgICAgIGluaXRpYWxJblZpZXcsXG4gICAgICBmYWxsYmFja0luVmlldyxcbiAgICAgIC4uLnByb3BzXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIGFzIHx8IHRhZyB8fCAnZGl2JyxcbiAgICAgIHsgcmVmOiB0aGlzLmhhbmRsZU5vZGUsIC4uLnByb3BzIH0sXG4gICAgICBjaGlsZHJlbixcbiAgICApO1xuICB9XG59XG4iLCAiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgSW5WaWV3SG9va1Jlc3BvbnNlLCBJbnRlcnNlY3Rpb25PcHRpb25zIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBvYnNlcnZlIH0gZnJvbSAnLi9vYnNlcnZlJztcblxudHlwZSBTdGF0ZSA9IHtcbiAgaW5WaWV3OiBib29sZWFuO1xuICBlbnRyeT86IEludGVyc2VjdGlvbk9ic2VydmVyRW50cnk7XG59O1xuXG4vKipcbiAqIFJlYWN0IEhvb2tzIG1ha2UgaXQgZWFzeSB0byBtb25pdG9yIHRoZSBgaW5WaWV3YCBzdGF0ZSBvZiB5b3VyIGNvbXBvbmVudHMuIENhbGxcbiAqIHRoZSBgdXNlSW5WaWV3YCBob29rIHdpdGggdGhlIChvcHRpb25hbCkgW29wdGlvbnNdKCNvcHRpb25zKSB5b3UgbmVlZC4gSXQgd2lsbFxuICogcmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgYSBgcmVmYCwgdGhlIGBpblZpZXdgIHN0YXR1cyBhbmQgdGhlIGN1cnJlbnRcbiAqIFtgZW50cnlgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSkuXG4gKiBBc3NpZ24gdGhlIGByZWZgIHRvIHRoZSBET00gZWxlbWVudCB5b3Ugd2FudCB0byBtb25pdG9yLCBhbmQgdGhlIGhvb2sgd2lsbFxuICogcmVwb3J0IHRoZSBzdGF0dXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbiAqIGltcG9ydCB7IHVzZUluVmlldyB9IGZyb20gJ3JlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlcic7XG4gKlxuICogY29uc3QgQ29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCB7IHJlZiwgaW5WaWV3LCBlbnRyeSB9ID0gdXNlSW5WaWV3KHtcbiAqICAgICAgIHRocmVzaG9sZDogMCxcbiAqICAgfSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxkaXYgcmVmPXtyZWZ9PlxuICogICAgICAgPGgyPntgSGVhZGVyIGluc2lkZSB2aWV3cG9ydCAke2luVmlld30uYH08L2gyPlxuICogICAgIDwvZGl2PlxuICogICApO1xuICogfTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5WaWV3KHtcbiAgdGhyZXNob2xkLFxuICBkZWxheSxcbiAgdHJhY2tWaXNpYmlsaXR5LFxuICByb290TWFyZ2luLFxuICByb290LFxuICB0cmlnZ2VyT25jZSxcbiAgc2tpcCxcbiAgaW5pdGlhbEluVmlldyxcbiAgZmFsbGJhY2tJblZpZXcsXG59OiBJbnRlcnNlY3Rpb25PcHRpb25zID0ge30pOiBJblZpZXdIb29rUmVzcG9uc2Uge1xuICBjb25zdCB1bm9ic2VydmUgPSBSZWFjdC51c2VSZWY8RnVuY3Rpb24+KCk7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGU8U3RhdGU+KHtcbiAgICBpblZpZXc6ICEhaW5pdGlhbEluVmlldyxcbiAgfSk7XG4gIGNvbnN0IHNldFJlZiA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIChub2RlKSA9PiB7XG4gICAgICBpZiAodW5vYnNlcnZlLmN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1bm9ic2VydmUuY3VycmVudCgpO1xuICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCBjcmVhdGluZyB0aGUgb2JzZXJ2ZXJcbiAgICAgIGlmIChza2lwKSByZXR1cm47XG5cbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIHVub2JzZXJ2ZS5jdXJyZW50ID0gb2JzZXJ2ZShcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIChpblZpZXcsIGVudHJ5KSA9PiB7XG4gICAgICAgICAgICBzZXRTdGF0ZSh7IGluVmlldywgZW50cnkgfSk7XG5cbiAgICAgICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZyAmJiB0cmlnZ2VyT25jZSAmJiB1bm9ic2VydmUuY3VycmVudCkge1xuICAgICAgICAgICAgICAvLyBJZiBpdCBzaG91bGQgb25seSB0cmlnZ2VyIG9uY2UsIHVub2JzZXJ2ZSB0aGUgZWxlbWVudCBhZnRlciBpdCdzIGluVmlld1xuICAgICAgICAgICAgICB1bm9ic2VydmUuY3VycmVudCgpO1xuICAgICAgICAgICAgICB1bm9ic2VydmUuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHJvb3QsXG4gICAgICAgICAgICByb290TWFyZ2luLFxuICAgICAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdHJhY2tWaXNpYmlsaXR5LFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmYWxsYmFja0luVmlldyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFdlIGJyZWFrIHRoZSBydWxlIGhlcmUsIGJlY2F1c2Ugd2UgYXJlbid0IGluY2x1ZGluZyB0aGUgYWN0dWFsIGB0aHJlc2hvbGRgIHZhcmlhYmxlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtcbiAgICAgIC8vIElmIHRoZSB0aHJlc2hvbGQgaXMgYW4gYXJyYXksIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcgc28gaXQgd29uJ3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgIEFycmF5LmlzQXJyYXkodGhyZXNob2xkKSA/IHRocmVzaG9sZC50b1N0cmluZygpIDogdGhyZXNob2xkLFxuICAgICAgcm9vdCxcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0cmlnZ2VyT25jZSxcbiAgICAgIHNraXAsXG4gICAgICB0cmFja1Zpc2liaWxpdHksXG4gICAgICBmYWxsYmFja0luVmlldyxcbiAgICAgIGRlbGF5LFxuICAgIF0sXG4gICk7XG5cbiAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lICovXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF1bm9ic2VydmUuY3VycmVudCAmJiBzdGF0ZS5lbnRyeSAmJiAhdHJpZ2dlck9uY2UgJiYgIXNraXApIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSByZWYsIHRoZW4gcmVzZXQgdGhlIHN0YXRlICh1bmxlc3MgdGhlIGhvb2sgaXMgc2V0IHRvIG9ubHkgYHRyaWdnZXJPbmNlYCBvciBgc2tpcGApXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgd2UgY29ycmVjdGx5IHJlZmxlY3QgdGhlIGN1cnJlbnQgc3RhdGUgLSBJZiB5b3UgYXJlbid0IG9ic2VydmluZyBhbnl0aGluZywgdGhlbiBub3RoaW5nIGlzIGluVmlld1xuICAgICAgc2V0U3RhdGUoe1xuICAgICAgICBpblZpZXc6ICEhaW5pdGlhbEluVmlldyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgY29uc3QgcmVzdWx0ID0gW3NldFJlZiwgc3RhdGUuaW5WaWV3LCBzdGF0ZS5lbnRyeV0gYXMgSW5WaWV3SG9va1Jlc3BvbnNlO1xuXG4gIC8vIFN1cHBvcnQgb2JqZWN0IGRlc3RydWN0dXJpbmcsIGJ5IGFkZGluZyB0aGUgc3BlY2lmaWMgdmFsdWVzLlxuICByZXN1bHQucmVmID0gcmVzdWx0WzBdO1xuICByZXN1bHQuaW5WaWV3ID0gcmVzdWx0WzFdO1xuICByZXN1bHQuZW50cnkgPSByZXN1bHRbMl07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsICJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWFjdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcInJlYWN0XCIpKTtcblxudmFyIF9wcm9wVHlwZXMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcblxudmFyIF9jbGFzc25hbWVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiY2xhc3NuYW1lc1wiKSk7XG5cbnZhciBfcmVhY3RJbnRlcnNlY3Rpb25PYnNlcnZlciA9IHJlcXVpcmUoXCJyZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXJcIik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmNvbnN0IFZlcnRpY2FsVGltZWxpbmVFbGVtZW50ID0gKHtcbiAgY2hpbGRyZW4sXG4gIGNsYXNzTmFtZSxcbiAgY29udGVudEFycm93U3R5bGUsXG4gIGNvbnRlbnRTdHlsZSxcbiAgZGF0ZSxcbiAgZGF0ZUNsYXNzTmFtZSxcbiAgaWNvbixcbiAgaWNvbkNsYXNzTmFtZSxcbiAgaWNvbk9uQ2xpY2ssXG4gIG9uVGltZWxpbmVFbGVtZW50Q2xpY2ssXG4gIGljb25TdHlsZSxcbiAgaWQsXG4gIHBvc2l0aW9uLFxuICBzdHlsZSxcbiAgdGV4dENsYXNzTmFtZSxcbiAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXJQcm9wcyxcbiAgdmlzaWJsZVxufSkgPT4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIuSW5WaWV3LCBpbnRlcnNlY3Rpb25PYnNlcnZlclByb3BzLCAoe1xuICBpblZpZXcsXG4gIHJlZlxufSkgPT4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICByZWY6IHJlZixcbiAgaWQ6IGlkLFxuICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lcy5kZWZhdWx0KShjbGFzc05hbWUsICd2ZXJ0aWNhbC10aW1lbGluZS1lbGVtZW50Jywge1xuICAgICd2ZXJ0aWNhbC10aW1lbGluZS1lbGVtZW50LS1sZWZ0JzogcG9zaXRpb24gPT09ICdsZWZ0JyxcbiAgICAndmVydGljYWwtdGltZWxpbmUtZWxlbWVudC0tcmlnaHQnOiBwb3NpdGlvbiA9PT0gJ3JpZ2h0JyxcbiAgICAndmVydGljYWwtdGltZWxpbmUtZWxlbWVudC0tbm8tY2hpbGRyZW4nOiBjaGlsZHJlbiA9PT0gJydcbiAgfSksXG4gIHN0eWxlOiBzdHlsZVxufSwgLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX3JlYWN0LmRlZmF1bHQuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUganN4LWExMXkvbm8tc3RhdGljLWVsZW1lbnQtaW50ZXJhY3Rpb25zXG4gIHN0eWxlOiBpY29uU3R5bGUsXG4gIG9uQ2xpY2s6IGljb25PbkNsaWNrLFxuICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lcy5kZWZhdWx0KShpY29uQ2xhc3NOYW1lLCAndmVydGljYWwtdGltZWxpbmUtZWxlbWVudC1pY29uJywge1xuICAgICdib3VuY2UtaW4nOiBpblZpZXcgfHwgdmlzaWJsZSxcbiAgICAnaXMtaGlkZGVuJzogIShpblZpZXcgfHwgdmlzaWJsZSlcbiAgfSlcbn0sIGljb24pLCAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gIHN0eWxlOiBjb250ZW50U3R5bGUsXG4gIG9uQ2xpY2s6IG9uVGltZWxpbmVFbGVtZW50Q2xpY2ssXG4gIGNsYXNzTmFtZTogKDAsIF9jbGFzc25hbWVzLmRlZmF1bHQpKHRleHRDbGFzc05hbWUsICd2ZXJ0aWNhbC10aW1lbGluZS1lbGVtZW50LWNvbnRlbnQnLCB7XG4gICAgJ2JvdW5jZS1pbic6IGluVmlldyB8fCB2aXNpYmxlLFxuICAgICdpcy1oaWRkZW4nOiAhKGluVmlldyB8fCB2aXNpYmxlKVxuICB9KVxufSwgLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICBzdHlsZTogY29udGVudEFycm93U3R5bGUsXG4gIGNsYXNzTmFtZTogXCJ2ZXJ0aWNhbC10aW1lbGluZS1lbGVtZW50LWNvbnRlbnQtYXJyb3dcIlxufSksIGNoaWxkcmVuLCAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcInNwYW5cIiwge1xuICBjbGFzc05hbWU6ICgwLCBfY2xhc3NuYW1lcy5kZWZhdWx0KShkYXRlQ2xhc3NOYW1lLCAndmVydGljYWwtdGltZWxpbmUtZWxlbWVudC1kYXRlJylcbn0sIGRhdGUpKSkpKTtcblxuVmVydGljYWxUaW1lbGluZUVsZW1lbnQucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogX3Byb3BUeXBlcy5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlcy5kZWZhdWx0LmFycmF5T2YoX3Byb3BUeXBlcy5kZWZhdWx0Lm5vZGUpLCBfcHJvcFR5cGVzLmRlZmF1bHQubm9kZV0pLFxuICBjbGFzc05hbWU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIGNvbnRlbnRBcnJvd1N0eWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe30pLFxuICBjb250ZW50U3R5bGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5zaGFwZSh7fSksXG4gIGRhdGU6IF9wcm9wVHlwZXMuZGVmYXVsdC5ub2RlLFxuICBkYXRlQ2xhc3NOYW1lOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICBpY29uOiBfcHJvcFR5cGVzLmRlZmF1bHQuZWxlbWVudCxcbiAgaWNvbkNsYXNzTmFtZTogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgaWNvblN0eWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe30pLFxuICBpY29uT25DbGljazogX3Byb3BUeXBlcy5kZWZhdWx0LmZ1bmMsXG4gIG9uVGltZWxpbmVFbGVtZW50Q2xpY2s6IF9wcm9wVHlwZXMuZGVmYXVsdC5mdW5jLFxuICBpZDogX3Byb3BUeXBlcy5kZWZhdWx0LnN0cmluZyxcbiAgcG9zaXRpb246IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gIHN0eWxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuc2hhcGUoe30pLFxuICB0ZXh0Q2xhc3NOYW1lOiBfcHJvcFR5cGVzLmRlZmF1bHQuc3RyaW5nLFxuICB2aXNpYmxlOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbCxcbiAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXJQcm9wczogX3Byb3BUeXBlcy5kZWZhdWx0LnNoYXBlKHtcbiAgICByb290OiBfcHJvcFR5cGVzLmRlZmF1bHQub2JqZWN0LFxuICAgIHJvb3RNYXJnaW46IF9wcm9wVHlwZXMuZGVmYXVsdC5zdHJpbmcsXG4gICAgdGhyZXNob2xkOiBfcHJvcFR5cGVzLmRlZmF1bHQubnVtYmVyLFxuICAgIHRyaWdnZXJPbmNlOiBfcHJvcFR5cGVzLmRlZmF1bHQuYm9vbFxuICB9KVxufTtcblZlcnRpY2FsVGltZWxpbmVFbGVtZW50LmRlZmF1bHRQcm9wcyA9IHtcbiAgY2hpbGRyZW46ICcnLFxuICBjbGFzc05hbWU6ICcnLFxuICBjb250ZW50QXJyb3dTdHlsZTogbnVsbCxcbiAgY29udGVudFN0eWxlOiBudWxsLFxuICBpY29uOiBudWxsLFxuICBpY29uQ2xhc3NOYW1lOiAnJyxcbiAgaWNvbk9uQ2xpY2s6IG51bGwsXG4gIG9uVGltZWxpbmVFbGVtZW50Q2xpY2s6IG51bGwsXG4gIGljb25TdHlsZTogbnVsbCxcbiAgaWQ6ICcnLFxuICBzdHlsZTogbnVsbCxcbiAgZGF0ZTogJycsXG4gIGRhdGVDbGFzc05hbWU6ICcnLFxuICBwb3NpdGlvbjogJycsXG4gIHRleHRDbGFzc05hbWU6ICcnLFxuICB2aXNpYmxlOiBmYWxzZSxcbiAgaW50ZXJzZWN0aW9uT2JzZXJ2ZXJQcm9wczoge1xuICAgIHJvb3RNYXJnaW46ICcwcHggMHB4IC00MHB4IDBweCcsXG4gICAgdHJpZ2dlck9uY2U6IHRydWVcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IFZlcnRpY2FsVGltZWxpbmVFbGVtZW50O1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwgIlwidXNlIHN0cmljdFwiO1xuXG4vLyB0aGlzIHNob3VsZCBiZSB0aGUgZW50cnkgcG9pbnQgdG8geW91ciBsaWJyYXJ5XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVmVydGljYWxUaW1lbGluZTogcmVxdWlyZSgnLi9WZXJ0aWNhbFRpbWVsaW5lJykuZGVmYXVsdCxcbiAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnbG9iYWwtcmVxdWlyZVxuICBWZXJ0aWNhbFRpbWVsaW5lRWxlbWVudDogcmVxdWlyZSgnLi9WZXJ0aWNhbFRpbWVsaW5lRWxlbWVudCcpLmRlZmF1bHQgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnbG9iYWwtcmVxdWlyZVxuXG59OyIsICJpbXBvcnQgeyBjcmVhdGVQYWdlc0Z1bmN0aW9uSGFuZGxlciB9IGZyb20gXCJAcmVtaXgtcnVuL2Nsb3VkZmxhcmUtcGFnZXNcIjtcbmltcG9ydCAqIGFzIGJ1aWxkIGZyb20gXCJAcmVtaXgtcnVuL2Rldi9zZXJ2ZXItYnVpbGRcIjtcblxuY29uc3QgaGFuZGxlUmVxdWVzdCA9IGNyZWF0ZVBhZ2VzRnVuY3Rpb25IYW5kbGVyKHtcbiAgYnVpbGQsXG4gIG1vZGU6IHByb2Nlc3MuZW52Lk5PREVfRU5WLFxuICBnZXRMb2FkQ29udGV4dDogKGNvbnRleHQpID0+IGNvbnRleHQuZW52LFxufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBvblJlcXVlc3QoY29udGV4dCkge1xuICByZXR1cm4gaGFuZGxlUmVxdWVzdChjb250ZXh0KTtcbn1cbiIsICIvKipcbiAqIEByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyB2MS4yLjNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgaW5zdGFsbEdsb2JhbHMgfSBmcm9tICcuL2dsb2JhbHMuanMnO1xuZXhwb3J0IHsgY3JlYXRlQ2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2UgfSBmcm9tICcuL3Nlc3Npb25zL2Nsb3VkZmxhcmVLVlNlc3Npb25TdG9yYWdlLmpzJztcbmV4cG9ydCB7IGNyZWF0ZVBhZ2VzRnVuY3Rpb25IYW5kbGVyLCBjcmVhdGVSZXF1ZXN0SGFuZGxlciB9IGZyb20gJy4vd29ya2VyLmpzJztcblxuaW5zdGFsbEdsb2JhbHMoKTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyB2MS4yLjNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgc2lnbiwgdW5zaWduIH0gZnJvbSAnLi9jb29raWVTaWduaW5nLmpzJztcblxuZnVuY3Rpb24gaW5zdGFsbEdsb2JhbHMoKSB7XG4gIHNlbGYuc2lnbiA9IHNpZ247XG4gIHNlbGYudW5zaWduID0gdW5zaWduO1xufVxuXG5leHBvcnQgeyBpbnN0YWxsR2xvYmFscyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjIuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5jb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG5hc3luYyBmdW5jdGlvbiBzaWduKHZhbHVlLCBzZWNyZXQpIHtcbiAgbGV0IGtleSA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIGVuY29kZXIuZW5jb2RlKHNlY3JldCksIHtcbiAgICBuYW1lOiBcIkhNQUNcIixcbiAgICBoYXNoOiBcIlNIQS0yNTZcIlxuICB9LCBmYWxzZSwgW1wic2lnblwiXSk7XG4gIGxldCBkYXRhID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICBsZXQgc2lnbmF0dXJlID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5zaWduKFwiSE1BQ1wiLCBrZXksIGRhdGEpO1xuICBsZXQgaGFzaCA9IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShzaWduYXR1cmUpKSkucmVwbGFjZSgvPSskLywgXCJcIik7XG4gIHJldHVybiB2YWx1ZSArIFwiLlwiICsgaGFzaDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHVuc2lnbihjb29raWUsIHNlY3JldCkge1xuICBsZXQga2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgZW5jb2Rlci5lbmNvZGUoc2VjcmV0KSwge1xuICAgIG5hbWU6IFwiSE1BQ1wiLFxuICAgIGhhc2g6IFwiU0hBLTI1NlwiXG4gIH0sIGZhbHNlLCBbXCJ2ZXJpZnlcIl0pO1xuICBsZXQgdmFsdWUgPSBjb29raWUuc2xpY2UoMCwgY29va2llLmxhc3RJbmRleE9mKFwiLlwiKSk7XG4gIGxldCBoYXNoID0gY29va2llLnNsaWNlKGNvb2tpZS5sYXN0SW5kZXhPZihcIi5cIikgKyAxKTtcbiAgbGV0IGRhdGEgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gIGxldCBzaWduYXR1cmUgPSBieXRlU3RyaW5nVG9VaW50OEFycmF5KGF0b2IoaGFzaCkpO1xuICBsZXQgdmFsaWQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLnZlcmlmeShcIkhNQUNcIiwga2V5LCBzaWduYXR1cmUsIGRhdGEpO1xuICByZXR1cm4gdmFsaWQgPyB2YWx1ZSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBieXRlU3RyaW5nVG9VaW50OEFycmF5KGJ5dGVTdHJpbmcpIHtcbiAgbGV0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZVN0cmluZy5sZW5ndGgpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgeyBzaWduLCB1bnNpZ24gfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyB2MS4yLjNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgY3JlYXRlU2Vzc2lvblN0b3JhZ2UgfSBmcm9tICdAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgU2Vzc2lvblN0b3JhZ2UgdGhhdCBzdG9yZXMgc2Vzc2lvbiBkYXRhIGluIHRoZSBDbG91bGRmbGFyZSBLViBTdG9yZS5cbiAqXG4gKiBUaGUgYWR2YW50YWdlIG9mIHVzaW5nIHRoaXMgaW5zdGVhZCBvZiBjb29raWUgc2Vzc2lvbiBzdG9yYWdlIGlzIHRoYXRcbiAqIEtWIFN0b3JlIG1heSBjb250YWluIG11Y2ggbW9yZSBkYXRhIHRoYW4gY29va2llcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNjcmVhdGVjbG91ZGZsYXJla3ZzZXNzaW9uc3RvcmFnZS1jbG91ZGZsYXJlLXdvcmtlcnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2Uoe1xuICBjb29raWUsXG4gIGt2XG59KSB7XG4gIHJldHVybiBjcmVhdGVTZXNzaW9uU3RvcmFnZSh7XG4gICAgY29va2llLFxuXG4gICAgYXN5bmMgY3JlYXRlRGF0YShkYXRhLCBleHBpcmVzKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBsZXQgcmFuZG9tQnl0ZXMgPSBuZXcgVWludDhBcnJheSg4KTtcbiAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyYW5kb21CeXRlcyk7IC8vIFRoaXMgc3RvcmFnZSBtYW5hZ2VzIGFuIGlkIHNwYWNlIG9mIDJeNjQgaWRzLCB3aGljaCBpcyBmYXIgZ3JlYXRlclxuICAgICAgICAvLyB0aGFuIHRoZSBtYXhpbXVtIG51bWJlciBvZiBmaWxlcyBhbGxvd2VkIG9uIGFuIE5URlMgb3IgZXh0NCB2b2x1bWVcbiAgICAgICAgLy8gKDJeMzIpLiBIb3dldmVyLCB0aGUgbGFyZ2VyIGlkIHNwYWNlIHNob3VsZCBoZWxwIHRvIGF2b2lkIGNvbGxpc2lvbnNcbiAgICAgICAgLy8gd2l0aCBleGlzdGluZyBpZHMgd2hlbiBjcmVhdGluZyBuZXcgc2Vzc2lvbnMsIHdoaWNoIHNwZWVkcyB0aGluZ3MgdXAuXG5cbiAgICAgICAgbGV0IGlkID0gWy4uLnJhbmRvbUJ5dGVzXS5tYXAoeCA9PiB4LnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpLmpvaW4oXCJcIik7XG5cbiAgICAgICAgaWYgKGF3YWl0IGt2LmdldChpZCwgXCJqc29uXCIpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBhd2FpdCBrdi5wdXQoaWQsIEpTT04uc3RyaW5naWZ5KGRhdGEpLCB7XG4gICAgICAgICAgZXhwaXJhdGlvbjogZXhwaXJlcyA/IE1hdGgucm91bmQoZXhwaXJlcy5nZXRUaW1lKCkgLyAxMDAwKSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyByZWFkRGF0YShpZCkge1xuICAgICAgbGV0IHNlc3Npb24gPSBhd2FpdCBrdi5nZXQoaWQpO1xuXG4gICAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHNlc3Npb24pO1xuICAgIH0sXG5cbiAgICBhc3luYyB1cGRhdGVEYXRhKGlkLCBkYXRhLCBleHBpcmVzKSB7XG4gICAgICBhd2FpdCBrdi5wdXQoaWQsIEpTT04uc3RyaW5naWZ5KGRhdGEpLCB7XG4gICAgICAgIGV4cGlyYXRpb246IGV4cGlyZXMgPyBNYXRoLnJvdW5kKGV4cGlyZXMuZ2V0VGltZSgpIC8gMTAwMCkgOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhc3luYyBkZWxldGVEYXRhKGlkKSB7XG4gICAgICBhd2FpdCBrdi5kZWxldGUoaWQpO1xuICAgIH1cblxuICB9KTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ2xvdWRmbGFyZUtWU2Vzc2lvblN0b3JhZ2UgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4zXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmV4cG9ydCB7IGNyZWF0ZUNvb2tpZSwgaXNDb29raWUgfSBmcm9tICcuL2Nvb2tpZXMuanMnO1xuZXhwb3J0IHsganNvbiwgcmVkaXJlY3QgfSBmcm9tICcuL3Jlc3BvbnNlcy5qcyc7XG5leHBvcnQgeyBjcmVhdGVSZXF1ZXN0SGFuZGxlciB9IGZyb20gJy4vc2VydmVyLmpzJztcbmV4cG9ydCB7IGNyZWF0ZVNlc3Npb24sIGNyZWF0ZVNlc3Npb25TdG9yYWdlLCBpc1Nlc3Npb24gfSBmcm9tICcuL3Nlc3Npb25zLmpzJztcbmV4cG9ydCB7IGNyZWF0ZUNvb2tpZVNlc3Npb25TdG9yYWdlIH0gZnJvbSAnLi9zZXNzaW9ucy9jb29raWVTdG9yYWdlLmpzJztcbmV4cG9ydCB7IGNyZWF0ZU1lbW9yeVNlc3Npb25TdG9yYWdlIH0gZnJvbSAnLi9zZXNzaW9ucy9tZW1vcnlTdG9yYWdlLmpzJztcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4zXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qKlxuICogVGhpcyBpcyBhIHNob3J0Y3V0IGZvciBjcmVhdGluZyBgYXBwbGljYXRpb24vanNvbmAgcmVzcG9uc2VzLiBDb252ZXJ0cyBgZGF0YWBcbiAqIHRvIEpTT04gYW5kIHNldHMgdGhlIGBDb250ZW50LVR5cGVgIGhlYWRlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNqc29uXG4gKi9cbmZ1bmN0aW9uIGpzb24oZGF0YSwgaW5pdCA9IHt9KSB7XG4gIGxldCByZXNwb25zZUluaXQgPSBpbml0O1xuXG4gIGlmICh0eXBlb2YgaW5pdCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJlc3BvbnNlSW5pdCA9IHtcbiAgICAgIHN0YXR1czogaW5pdFxuICAgIH07XG4gIH1cblxuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcblxuICBpZiAoIWhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpKSB7XG4gICAgaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uOyBjaGFyc2V0PXV0Zi04XCIpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShkYXRhKSwgeyAuLi5yZXNwb25zZUluaXQsXG4gICAgaGVhZGVyc1xuICB9KTtcbn1cbi8qKlxuICogQSByZWRpcmVjdCByZXNwb25zZS4gU2V0cyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRoZSBgTG9jYXRpb25gIGhlYWRlci5cbiAqIERlZmF1bHRzIHRvIFwiMzAyIEZvdW5kXCIuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjcmVkaXJlY3RcbiAqL1xuXG5mdW5jdGlvbiByZWRpcmVjdCh1cmwsIGluaXQgPSAzMDIpIHtcbiAgbGV0IHJlc3BvbnNlSW5pdCA9IGluaXQ7XG5cbiAgaWYgKHR5cGVvZiByZXNwb25zZUluaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXNwb25zZUluaXQgPSB7XG4gICAgICBzdGF0dXM6IHJlc3BvbnNlSW5pdFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdC5zdGF0dXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXNwb25zZUluaXQuc3RhdHVzID0gMzAyO1xuICB9XG5cbiAgbGV0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhyZXNwb25zZUluaXQuaGVhZGVycyk7XG4gIGhlYWRlcnMuc2V0KFwiTG9jYXRpb25cIiwgdXJsKTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7IC4uLnJlc3BvbnNlSW5pdCxcbiAgICBoZWFkZXJzXG4gIH0pO1xufVxuZnVuY3Rpb24gaXNSZXNwb25zZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUuc3RhdHVzID09PSBcIm51bWJlclwiICYmIHR5cGVvZiB2YWx1ZS5zdGF0dXNUZXh0ID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2YWx1ZS5oZWFkZXJzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS5ib2R5ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuY29uc3QgcmVkaXJlY3RTdGF0dXNDb2RlcyA9IG5ldyBTZXQoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSk7XG5mdW5jdGlvbiBpc1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlZGlyZWN0U3RhdHVzQ29kZXMuaGFzKHJlc3BvbnNlLnN0YXR1cyk7XG59XG5mdW5jdGlvbiBpc0NhdGNoUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1DYXRjaFwiKSAhPSBudWxsO1xufVxuXG5leHBvcnQgeyBpc0NhdGNoUmVzcG9uc2UsIGlzUmVkaXJlY3RSZXNwb25zZSwgaXNSZXNwb25zZSwganNvbiwgcmVkaXJlY3QgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4zXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IGNhbGxSb3V0ZUFjdGlvbiwgY2FsbFJvdXRlTG9hZGVyLCBleHRyYWN0RGF0YSB9IGZyb20gJy4vZGF0YS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVFbnRyeVJvdXRlTW9kdWxlcywgY3JlYXRlRW50cnlNYXRjaGVzIH0gZnJvbSAnLi9lbnRyeS5qcyc7XG5pbXBvcnQgeyBzZXJpYWxpemVFcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmltcG9ydCB7IGdldERvY3VtZW50SGVhZGVycyB9IGZyb20gJy4vaGVhZGVycy5qcyc7XG5pbXBvcnQgeyBtYXRjaFNlcnZlclJvdXRlcyB9IGZyb20gJy4vcm91dGVNYXRjaGluZy5qcyc7XG5pbXBvcnQgeyBpc1NlcnZlck1vZGUsIFNlcnZlck1vZGUgfSBmcm9tICcuL21vZGUuanMnO1xuaW1wb3J0IHsgY3JlYXRlUm91dGVzIH0gZnJvbSAnLi9yb3V0ZXMuanMnO1xuaW1wb3J0IHsgaXNSZWRpcmVjdFJlc3BvbnNlLCBpc0NhdGNoUmVzcG9uc2UsIGpzb24gfSBmcm9tICcuL3Jlc3BvbnNlcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTZXJ2ZXJIYW5kb2ZmU3RyaW5nIH0gZnJvbSAnLi9zZXJ2ZXJIYW5kb2ZmLmpzJztcblxuLyoqXG4gKiBUaGUgbWFpbiByZXF1ZXN0IGhhbmRsZXIgZm9yIGEgUmVtaXggc2VydmVyLiBUaGlzIGhhbmRsZXIgcnVucyBpbiB0aGUgY29udGV4dFxuICogb2YgYSBjbG91ZCBwcm92aWRlcidzIHNlcnZlciAoZS5nLiBFeHByZXNzIG9uIEZpcmViYXNlKSBvciBsb2NhbGx5IHZpYSB0aGVpclxuICogZGV2IHRvb2xzLlxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgc2VydmVzIEhUVFAgcmVxdWVzdHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3RIYW5kbGVyKGJ1aWxkLCBwbGF0Zm9ybSwgbW9kZSkge1xuICBsZXQgcm91dGVzID0gY3JlYXRlUm91dGVzKGJ1aWxkLnJvdXRlcyk7XG4gIGxldCBzZXJ2ZXJNb2RlID0gaXNTZXJ2ZXJNb2RlKG1vZGUpID8gbW9kZSA6IFNlcnZlck1vZGUuUHJvZHVjdGlvbjtcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIHJlcXVlc3RIYW5kbGVyKHJlcXVlc3QsIGxvYWRDb250ZXh0KSB7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hTZXJ2ZXJSb3V0ZXMocm91dGVzLCB1cmwucGF0aG5hbWUpO1xuICAgIGxldCByZXF1ZXN0VHlwZSA9IGdldFJlcXVlc3RUeXBlKHVybCwgbWF0Y2hlcyk7XG4gICAgbGV0IHJlc3BvbnNlO1xuXG4gICAgc3dpdGNoIChyZXF1ZXN0VHlwZSkge1xuICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVEYXRhUmVxdWVzdCh7XG4gICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgICBtYXRjaGVzOiBtYXRjaGVzLFxuICAgICAgICAgIGhhbmRsZURhdGFSZXF1ZXN0OiBidWlsZC5lbnRyeS5tb2R1bGUuaGFuZGxlRGF0YVJlcXVlc3QsXG4gICAgICAgICAgc2VydmVyTW9kZVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJkb2N1bWVudFwiOlxuICAgICAgICByZXNwb25zZSA9IGF3YWl0IHJlbmRlckRvY3VtZW50UmVxdWVzdCh7XG4gICAgICAgICAgYnVpbGQsXG4gICAgICAgICAgbG9hZENvbnRleHQsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIHJvdXRlcyxcbiAgICAgICAgICBzZXJ2ZXJNb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcInJlc291cmNlXCI6XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlUmVzb3VyY2VSZXF1ZXN0KHtcbiAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgICAgICAgc2VydmVyTW9kZVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiaGVhZFwiKSB7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlRGF0YVJlcXVlc3Qoe1xuICBoYW5kbGVEYXRhUmVxdWVzdCxcbiAgbG9hZENvbnRleHQsXG4gIG1hdGNoZXMsXG4gIHJlcXVlc3QsXG4gIHNlcnZlck1vZGVcbn0pIHtcbiAgaWYgKCFpc1ZhbGlkUmVxdWVzdE1ldGhvZChyZXF1ZXN0KSkge1xuICAgIHJldHVybiBlcnJvckJvdW5kYXJ5RXJyb3IobmV3IEVycm9yKGBJbnZhbGlkIHJlcXVlc3QgbWV0aG9kIFwiJHtyZXF1ZXN0Lm1ldGhvZH1cImApLCA0MDUpO1xuICB9XG5cbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIHJldHVybiBlcnJvckJvdW5kYXJ5RXJyb3IobmV3IEVycm9yKGBObyByb3V0ZSBtYXRjaGVzIFVSTCBcIiR7dXJsLnBhdGhuYW1lfVwiYCksIDQwNCk7XG4gIH1cblxuICBsZXQgcmVzcG9uc2U7XG4gIGxldCBtYXRjaDtcblxuICB0cnkge1xuICAgIGlmIChpc0FjdGlvblJlcXVlc3QocmVxdWVzdCkpIHtcbiAgICAgIG1hdGNoID0gZ2V0QWN0aW9uUmVxdWVzdE1hdGNoKHVybCwgbWF0Y2hlcyk7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGNhbGxSb3V0ZUFjdGlvbih7XG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCByb3V0ZUlkID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJfZGF0YVwiKTtcblxuICAgICAgaWYgKCFyb3V0ZUlkKSB7XG4gICAgICAgIHJldHVybiBlcnJvckJvdW5kYXJ5RXJyb3IobmV3IEVycm9yKGBNaXNzaW5nIHJvdXRlIGlkIGluID9fZGF0YWApLCA0MDMpO1xuICAgICAgfVxuXG4gICAgICBsZXQgdGVtcE1hdGNoID0gbWF0Y2hlcy5maW5kKG1hdGNoID0+IG1hdGNoLnJvdXRlLmlkID09PSByb3V0ZUlkKTtcblxuICAgICAgaWYgKCF0ZW1wTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihuZXcgRXJyb3IoYFJvdXRlIFwiJHtyb3V0ZUlkfVwiIGRvZXMgbm90IG1hdGNoIFVSTCBcIiR7dXJsLnBhdGhuYW1lfVwiYCksIDQwMyk7XG4gICAgICB9XG5cbiAgICAgIG1hdGNoID0gdGVtcE1hdGNoO1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBjYWxsUm91dGVMb2FkZXIoe1xuICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHJlcXVlc3RcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAvLyBXZSBkb24ndCBoYXZlIGFueSB3YXkgdG8gcHJldmVudCBhIGZldGNoIHJlcXVlc3QgZnJvbSBmb2xsb3dpbmdcbiAgICAgIC8vIHJlZGlyZWN0cy4gU28gd2UgdXNlIHRoZSBgWC1SZW1peC1SZWRpcmVjdGAgaGVhZGVyIHRvIGluZGljYXRlIHRoZVxuICAgICAgLy8gbmV4dCBVUkwsIGFuZCB0aGVuIFwiZm9sbG93XCIgdGhlIHJlZGlyZWN0IG1hbnVhbGx5IG9uIHRoZSBjbGllbnQuXG4gICAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlLmhlYWRlcnMpO1xuICAgICAgaGVhZGVycy5zZXQoXCJYLVJlbWl4LVJlZGlyZWN0XCIsIGhlYWRlcnMuZ2V0KFwiTG9jYXRpb25cIikpO1xuICAgICAgaGVhZGVycy5kZWxldGUoXCJMb2NhdGlvblwiKTtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZURhdGFSZXF1ZXN0KSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZURhdGFSZXF1ZXN0KHJlc3BvbnNlLmNsb25lKCksIHtcbiAgICAgICAgY29udGV4dDogbG9hZENvbnRleHQsXG4gICAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LmNsb25lKClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoc2VydmVyTW9kZSAhPT0gU2VydmVyTW9kZS5UZXN0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyTW9kZSA9PT0gU2VydmVyTW9kZS5EZXZlbG9wbWVudCkge1xuICAgICAgcmV0dXJuIGVycm9yQm91bmRhcnlFcnJvcihlcnJvciwgNTAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXJyb3JCb3VuZGFyeUVycm9yKG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgU2VydmVyIEVycm9yXCIpLCA1MDApO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlckRvY3VtZW50UmVxdWVzdCh7XG4gIGJ1aWxkLFxuICBsb2FkQ29udGV4dCxcbiAgbWF0Y2hlcyxcbiAgcmVxdWVzdCxcbiAgcm91dGVzLFxuICBzZXJ2ZXJNb2RlXG59KSB7XG4gIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgbGV0IGFwcFN0YXRlID0ge1xuICAgIHRyYWNrQm91bmRhcmllczogdHJ1ZSxcbiAgICB0cmFja0NhdGNoQm91bmRhcmllczogdHJ1ZSxcbiAgICBjYXRjaEJvdW5kYXJ5Um91dGVJZDogbnVsbCxcbiAgICByZW5kZXJCb3VuZGFyeVJvdXRlSWQ6IG51bGwsXG4gICAgbG9hZGVyQm91bmRhcnlSb3V0ZUlkOiBudWxsLFxuICAgIGVycm9yOiB1bmRlZmluZWQsXG4gICAgY2F0Y2g6IHVuZGVmaW5lZFxuICB9O1xuXG4gIGlmICghaXNWYWxpZFJlcXVlc3RNZXRob2QocmVxdWVzdCkpIHtcbiAgICBtYXRjaGVzID0gbnVsbDtcbiAgICBhcHBTdGF0ZS50cmFja0NhdGNoQm91bmRhcmllcyA9IGZhbHNlO1xuICAgIGFwcFN0YXRlLmNhdGNoID0ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIHN0YXR1czogNDA1LFxuICAgICAgc3RhdHVzVGV4dDogXCJNZXRob2QgTm90IEFsbG93ZWRcIlxuICAgIH07XG4gIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICBhcHBTdGF0ZS50cmFja0NhdGNoQm91bmRhcmllcyA9IGZhbHNlO1xuICAgIGFwcFN0YXRlLmNhdGNoID0ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIHN0YXR1czogNDA0LFxuICAgICAgc3RhdHVzVGV4dDogXCJOb3QgRm91bmRcIlxuICAgIH07XG4gIH1cblxuICBsZXQgYWN0aW9uU3RhdHVzO1xuICBsZXQgYWN0aW9uRGF0YTtcbiAgbGV0IGFjdGlvbk1hdGNoO1xuICBsZXQgYWN0aW9uUmVzcG9uc2U7XG5cbiAgaWYgKG1hdGNoZXMgJiYgaXNBY3Rpb25SZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgYWN0aW9uTWF0Y2ggPSBnZXRBY3Rpb25SZXF1ZXN0TWF0Y2godXJsLCBtYXRjaGVzKTtcblxuICAgIHRyeSB7XG4gICAgICBhY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxSb3V0ZUFjdGlvbih7XG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICBtYXRjaDogYWN0aW9uTWF0Y2gsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKGFjdGlvblJlc3BvbnNlKSkge1xuICAgICAgICByZXR1cm4gYWN0aW9uUmVzcG9uc2U7XG4gICAgICB9XG5cbiAgICAgIGFjdGlvblN0YXR1cyA9IHtcbiAgICAgICAgc3RhdHVzOiBhY3Rpb25SZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IGFjdGlvblJlc3BvbnNlLnN0YXR1c1RleHRcbiAgICAgIH07XG5cbiAgICAgIGlmIChpc0NhdGNoUmVzcG9uc2UoYWN0aW9uUmVzcG9uc2UpKSB7XG4gICAgICAgIGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID0gZ2V0RGVlcGVzdFJvdXRlSWRXaXRoQm91bmRhcnkobWF0Y2hlcywgXCJDYXRjaEJvdW5kYXJ5XCIpO1xuICAgICAgICBhcHBTdGF0ZS50cmFja0NhdGNoQm91bmRhcmllcyA9IGZhbHNlO1xuICAgICAgICBhcHBTdGF0ZS5jYXRjaCA9IHsgLi4uYWN0aW9uU3RhdHVzLFxuICAgICAgICAgIGRhdGE6IGF3YWl0IGV4dHJhY3REYXRhKGFjdGlvblJlc3BvbnNlKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9uRGF0YSA9IHtcbiAgICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiBhd2FpdCBleHRyYWN0RGF0YShhY3Rpb25SZXNwb25zZSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgYXBwU3RhdGUubG9hZGVyQm91bmRhcnlSb3V0ZUlkID0gZ2V0RGVlcGVzdFJvdXRlSWRXaXRoQm91bmRhcnkobWF0Y2hlcywgXCJFcnJvckJvdW5kYXJ5XCIpO1xuICAgICAgYXBwU3RhdGUudHJhY2tCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgICBhcHBTdGF0ZS5lcnJvciA9IGF3YWl0IHNlcmlhbGl6ZUVycm9yKGVycm9yKTtcblxuICAgICAgaWYgKHNlcnZlck1vZGUgIT09IFNlcnZlck1vZGUuVGVzdCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBUaGVyZSB3YXMgYW4gZXJyb3IgcnVubmluZyB0aGUgYWN0aW9uIGZvciByb3V0ZSAke2FjdGlvbk1hdGNoLnJvdXRlLmlkfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCByb3V0ZU1vZHVsZXMgPSBjcmVhdGVFbnRyeVJvdXRlTW9kdWxlcyhidWlsZC5yb3V0ZXMpO1xuICBsZXQgbWF0Y2hlc1RvTG9hZCA9IG1hdGNoZXMgfHwgW107XG5cbiAgaWYgKGFwcFN0YXRlLmNhdGNoKSB7XG4gICAgbWF0Y2hlc1RvTG9hZCA9IGdldE1hdGNoZXNVcFRvRGVlcGVzdEJvdW5kYXJ5KCAvLyBnZXQgcmlkIG9mIHRoZSBhY3Rpb24sIHdlIGRvbid0IHdhbnQgdG8gY2FsbCBpdCdzIGxvYWRlciBlaXRoZXJcbiAgICAvLyBiZWNhdXNlIHdlJ2xsIGJlIHJlbmRlcmluZyB0aGUgY2F0Y2ggYm91bmRhcnksIGlmIHlvdSBjYW4gZ2V0IGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBsb2FkZXIgZGF0YSBpbiB0aGUgY2F0Y2ggYm91bmRhcnkgdGhlbiBob3cgdGhlIGhlY2sgaXMgaXRcbiAgICAvLyBzdXBwb3NlZCB0byBkZWFsIHdpdGggdGhyb3duIHJlc3BvbnNlcz9cbiAgICBtYXRjaGVzVG9Mb2FkLnNsaWNlKDAsIC0xKSwgXCJDYXRjaEJvdW5kYXJ5XCIpO1xuICB9IGVsc2UgaWYgKGFwcFN0YXRlLmVycm9yKSB7XG4gICAgbWF0Y2hlc1RvTG9hZCA9IGdldE1hdGNoZXNVcFRvRGVlcGVzdEJvdW5kYXJ5KCAvLyBnZXQgcmlkIG9mIHRoZSBhY3Rpb24sIHdlIGRvbid0IHdhbnQgdG8gY2FsbCBpdCdzIGxvYWRlciBlaXRoZXJcbiAgICAvLyBiZWNhdXNlIHdlJ2xsIGJlIHJlbmRlcmluZyB0aGUgZXJyb3IgYm91bmRhcnksIGlmIHlvdSBjYW4gZ2V0IGFjY2Vzc1xuICAgIC8vIHRvIHRoZSBsb2FkZXIgZGF0YSBpbiB0aGUgZXJyb3IgYm91bmRhcnkgdGhlbiBob3cgdGhlIGhlY2sgaXMgaXRcbiAgICAvLyBzdXBwb3NlZCB0byBkZWFsIHdpdGggZXJyb3JzIGluIHRoZSBsb2FkZXIsIHRvbz9cbiAgICBtYXRjaGVzVG9Mb2FkLnNsaWNlKDAsIC0xKSwgXCJFcnJvckJvdW5kYXJ5XCIpO1xuICB9XG5cbiAgbGV0IHJvdXRlTG9hZGVyUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChtYXRjaGVzVG9Mb2FkLm1hcChtYXRjaCA9PiBtYXRjaC5yb3V0ZS5tb2R1bGUubG9hZGVyID8gY2FsbFJvdXRlTG9hZGVyKHtcbiAgICBsb2FkQ29udGV4dCxcbiAgICBtYXRjaCxcbiAgICByZXF1ZXN0XG4gIH0pIDogUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCkpKTsgLy8gU3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBhY3Rpb24uIFdlIHdpbGwgdXNlIHRoaXMgdG8gZGV0ZXJtaW5lIGxhdGVyXG4gIC8vIHdoYXQgY2F0Y2ggb3IgZXJyb3IgYm91bmRhcnkgc2hvdWxkIGJlIHJlbmRlcmVkIHVuZGVyIGNhc2VzIHdoZXJlXG4gIC8vIGFjdGlvbnMgZG9uJ3QgdGhyb3cgYnV0IGxvYWRlcnMgZG8sIGFjdGlvbnMgdGhyb3cgYW5kIHBhcmVudCBsb2FkZXJzXG4gIC8vIGFsc28gdGhyb3csIGV0Yy5cblxuICBsZXQgYWN0aW9uQ2F0Y2ggPSBhcHBTdGF0ZS5jYXRjaDtcbiAgbGV0IGFjdGlvbkVycm9yID0gYXBwU3RhdGUuZXJyb3I7XG4gIGxldCBhY3Rpb25DYXRjaEJvdW5kYXJ5Um91dGVJZCA9IGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkO1xuICBsZXQgYWN0aW9uTG9hZGVyQm91bmRhcnlSb3V0ZUlkID0gYXBwU3RhdGUubG9hZGVyQm91bmRhcnlSb3V0ZUlkOyAvLyBSZXNldCB0aGUgYXBwIGVycm9yIGFuZCBjYXRjaCBzdGF0ZSB0byBwcm9wb2dhdGUgdGhlIGxvYWRlciBzdGF0ZXNcbiAgLy8gZnJvbSB0aGUgcmVzdWx0cyBpbnRvIHRoZSBhcHAgc3RhdGUuXG5cbiAgYXBwU3RhdGUuY2F0Y2ggPSB1bmRlZmluZWQ7XG4gIGFwcFN0YXRlLmVycm9yID0gdW5kZWZpbmVkO1xuICBsZXQgcm91dGVMb2FkZXJSZXNwb25zZXMgPSB7fTtcbiAgbGV0IGxvYWRlclN0YXR1c0NvZGVzID0gW107XG4gIGxldCByb3V0ZURhdGEgPSB7fTtcblxuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbWF0Y2hlc1RvTG9hZC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzVG9Mb2FkW2luZGV4XTtcbiAgICBsZXQgcmVzdWx0ID0gcm91dGVMb2FkZXJSZXN1bHRzW2luZGV4XTtcbiAgICBsZXQgZXJyb3IgPSByZXN1bHQuc3RhdHVzID09PSBcInJlamVjdGVkXCIgPyByZXN1bHQucmVhc29uIDogdW5kZWZpbmVkO1xuICAgIGxldCByZXNwb25zZSA9IHJlc3VsdC5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIgPyByZXN1bHQudmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGlzUmVkaXJlY3QgPSByZXNwb25zZSA/IGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkgOiBmYWxzZTtcbiAgICBsZXQgaXNDYXRjaCA9IHJlc3BvbnNlID8gaXNDYXRjaFJlc3BvbnNlKHJlc3BvbnNlKSA6IGZhbHNlOyAvLyBJZiBhIHBhcmVudCBsb2FkZXIgaGFzIGFscmVhZHkgY2F1Z2h0IG9yIGVycm9yJ2QsIGJhaWwgYmVjYXVzZVxuICAgIC8vIHdlIGRvbid0IG5lZWQgYW55IG1vcmUgY2hpbGQgZGF0YS5cblxuICAgIGlmIChhcHBTdGF0ZS5jYXRjaCB8fCBhcHBTdGF0ZS5lcnJvcikge1xuICAgICAgYnJlYWs7XG4gICAgfSAvLyBJZiB0aGVyZSBpcyBhIHJlc3BvbnNlIGFuZCBpdCdzIGEgcmVkaXJlY3QsIGRvIGl0IHVubGVzcyB0aGVyZVxuICAgIC8vIGlzIGFuIGFjdGlvbiBlcnJvciBvciBjYXRjaCBzdGF0ZSwgdGhvc2UgYWN0aW9uIGJvdW5kYXJ5IHN0YXRlc1xuICAgIC8vIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzYXRlcywgdGhpcyBtZWFucyBpZiBhIGxvYWRlciByZWRpcmVjdHNcbiAgICAvLyBhZnRlciBhbiBhY3Rpb24gY2F0Y2hlcyBvciBlcnJvcnMgd2Ugd29uJ3QgZm9sbG93IGl0LCBhbmQgaW5zdGVhZFxuICAgIC8vIHJlbmRlciB0aGUgYm91bmRhcnkgY2F1c2VkIGJ5IHRoZSBhY3Rpb24uXG5cblxuICAgIGlmICghYWN0aW9uQ2F0Y2ggJiYgIWFjdGlvbkVycm9yICYmIHJlc3BvbnNlICYmIGlzUmVkaXJlY3QpIHtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9IC8vIFRyYWNrIHRoZSBib3VuZGFyeSBJRCdzIGZvciB0aGUgbG9hZGVyc1xuXG5cbiAgICBpZiAobWF0Y2gucm91dGUubW9kdWxlLkNhdGNoQm91bmRhcnkpIHtcbiAgICAgIGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoLnJvdXRlLm1vZHVsZS5FcnJvckJvdW5kYXJ5KSB7XG4gICAgICBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICB9XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGxvYWRlclN0YXR1c0NvZGVzLnB1c2goNTAwKTtcbiAgICAgIGFwcFN0YXRlLnRyYWNrQm91bmRhcmllcyA9IGZhbHNlO1xuICAgICAgYXBwU3RhdGUuZXJyb3IgPSBhd2FpdCBzZXJpYWxpemVFcnJvcihlcnJvcik7XG5cbiAgICAgIGlmIChzZXJ2ZXJNb2RlICE9PSBTZXJ2ZXJNb2RlLlRlc3QpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgVGhlcmUgd2FzIGFuIGVycm9yIHJ1bm5pbmcgdGhlIGRhdGEgbG9hZGVyIGZvciByb3V0ZSAke21hdGNoLnJvdXRlLmlkfWApO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlKSB7XG4gICAgICByb3V0ZUxvYWRlclJlc3BvbnNlc1ttYXRjaC5yb3V0ZS5pZF0gPSByZXNwb25zZTtcbiAgICAgIGxvYWRlclN0YXR1c0NvZGVzLnB1c2gocmVzcG9uc2Uuc3RhdHVzKTtcblxuICAgICAgaWYgKGlzQ2F0Y2gpIHtcbiAgICAgICAgLy8gSWYgaXQncyBhIGNhdGNoIHJlc3BvbnNlLCBzdG9yZSBpdCBpbiBhcHAgc3RhdGUsIGFuZCBiYWlsXG4gICAgICAgIGFwcFN0YXRlLnRyYWNrQ2F0Y2hCb3VuZGFyaWVzID0gZmFsc2U7XG4gICAgICAgIGFwcFN0YXRlLmNhdGNoID0ge1xuICAgICAgICAgIGRhdGE6IGF3YWl0IGV4dHJhY3REYXRhKHJlc3BvbnNlKSxcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRXh0cmFjdCBhbmQgc3RvcmUgdGhlIGxvYWRlciBkYXRhXG4gICAgICAgIHJvdXRlRGF0YVttYXRjaC5yb3V0ZS5pZF0gPSBhd2FpdCBleHRyYWN0RGF0YShyZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIElmIHRoZXJlIHdhcyBub3QgYSBsb2FkZXIgY2F0Y2ggb3IgZXJyb3Igc3RhdGUgdHJpZ2dlcmVkIHJlc2V0IHRoZVxuICAvLyBib3VuZGFyaWVzIGFzIHRoZXkgYXJlIHByb2JhYmx5IGRlZXBlciBpbiB0aGUgdHJlZSBpZiB0aGUgYWN0aW9uXG4gIC8vIGluaXRpYWxseSB0cmlnZ2VyZWQgYSBib3VuZGFyeSBhcyB0aGF0IG1hdGNoIHdvdWxkIG5vdCBleGlzdCBpbiB0aGVcbiAgLy8gbWF0Y2hlcyB0byBsb2FkLlxuXG5cbiAgaWYgKCFhcHBTdGF0ZS5jYXRjaCkge1xuICAgIGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID0gYWN0aW9uQ2F0Y2hCb3VuZGFyeVJvdXRlSWQ7XG4gIH1cblxuICBpZiAoIWFwcFN0YXRlLmVycm9yKSB7XG4gICAgYXBwU3RhdGUubG9hZGVyQm91bmRhcnlSb3V0ZUlkID0gYWN0aW9uTG9hZGVyQm91bmRhcnlSb3V0ZUlkO1xuICB9IC8vIElmIHRoZXJlIHdhcyBhbiBhY3Rpb24gZXJyb3Igb3IgY2F0Y2gsIHdlIHdpbGwgcmVzZXQgdGhlIHN0YXRlIHRvIHRoZVxuICAvLyBpbml0aWFsIHZhbHVlcywgb3RoZXJ3aXNlIHdlIHdpbGwgdXNlIHdoYXRldmVyIGNhbWUgb3V0IG9mIHRoZSBsb2FkZXJzLlxuXG5cbiAgYXBwU3RhdGUuY2F0Y2ggPSBhY3Rpb25DYXRjaCB8fCBhcHBTdGF0ZS5jYXRjaDtcbiAgYXBwU3RhdGUuZXJyb3IgPSBhY3Rpb25FcnJvciB8fCBhcHBTdGF0ZS5lcnJvcjtcbiAgbGV0IHJlbmRlcmFibGVNYXRjaGVzID0gZ2V0UmVuZGVyYWJsZU1hdGNoZXMobWF0Y2hlcywgYXBwU3RhdGUpO1xuXG4gIGlmICghcmVuZGVyYWJsZU1hdGNoZXMpIHtcbiAgICByZW5kZXJhYmxlTWF0Y2hlcyA9IFtdO1xuICAgIGxldCByb290ID0gcm91dGVzWzBdO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwgJiYgcm9vdCAhPT0gdm9pZCAwICYmIHJvb3QubW9kdWxlLkNhdGNoQm91bmRhcnkpIHtcbiAgICAgIGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID0gXCJyb290XCI7XG4gICAgICByZW5kZXJhYmxlTWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICAgIHJvdXRlOiByb3V0ZXNbMF1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBIYW5kbGUgcmVzcG9uc2VzIHdpdGggYSBub24tMjAwIHN0YXR1cyBjb2RlLiBUaGUgZmlyc3QgbG9hZGVyIHdpdGggYVxuICAvLyBub24tMjAwIHN0YXR1cyBjb2RlIGRldGVybWluZXMgdGhlIHN0YXR1cyBjb2RlIGZvciB0aGUgd2hvbGUgcmVzcG9uc2UuXG5cblxuICBsZXQgbm90T2tSZXNwb25zZSA9IGFjdGlvblN0YXR1cyAmJiBhY3Rpb25TdGF0dXMuc3RhdHVzICE9PSAyMDAgPyBhY3Rpb25TdGF0dXMuc3RhdHVzIDogbG9hZGVyU3RhdHVzQ29kZXMuZmluZChzdGF0dXMgPT4gc3RhdHVzICE9PSAyMDApO1xuICBsZXQgcmVzcG9uc2VTdGF0dXNDb2RlID0gYXBwU3RhdGUuZXJyb3IgPyA1MDAgOiB0eXBlb2Ygbm90T2tSZXNwb25zZSA9PT0gXCJudW1iZXJcIiA/IG5vdE9rUmVzcG9uc2UgOiBhcHBTdGF0ZS5jYXRjaCA/IGFwcFN0YXRlLmNhdGNoLnN0YXR1cyA6IDIwMDtcbiAgbGV0IHJlc3BvbnNlSGVhZGVycyA9IGdldERvY3VtZW50SGVhZGVycyhidWlsZCwgcmVuZGVyYWJsZU1hdGNoZXMsIHJvdXRlTG9hZGVyUmVzcG9uc2VzLCBhY3Rpb25SZXNwb25zZSk7XG4gIGxldCBlbnRyeU1hdGNoZXMgPSBjcmVhdGVFbnRyeU1hdGNoZXMocmVuZGVyYWJsZU1hdGNoZXMsIGJ1aWxkLmFzc2V0cy5yb3V0ZXMpO1xuICBsZXQgc2VydmVySGFuZG9mZiA9IHtcbiAgICBhY3Rpb25EYXRhLFxuICAgIGFwcFN0YXRlOiBhcHBTdGF0ZSxcbiAgICBtYXRjaGVzOiBlbnRyeU1hdGNoZXMsXG4gICAgcm91dGVEYXRhXG4gIH07XG4gIGxldCBlbnRyeUNvbnRleHQgPSB7IC4uLnNlcnZlckhhbmRvZmYsXG4gICAgbWFuaWZlc3Q6IGJ1aWxkLmFzc2V0cyxcbiAgICByb3V0ZU1vZHVsZXMsXG4gICAgc2VydmVySGFuZG9mZlN0cmluZzogY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyhzZXJ2ZXJIYW5kb2ZmKVxuICB9O1xuICBsZXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0ID0gYnVpbGQuZW50cnkubW9kdWxlLmRlZmF1bHQ7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0KHJlcXVlc3QuY2xvbmUoKSwgcmVzcG9uc2VTdGF0dXNDb2RlLCByZXNwb25zZUhlYWRlcnMsIGVudHJ5Q29udGV4dCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVzcG9uc2VTdGF0dXNDb2RlID0gNTAwOyAvLyBHbyBhZ2FpbiwgdGhpcyB0aW1lIHdpdGggdGhlIGNvbXBvbmVudERpZENhdGNoIGVtdWxhdGlvbi4gQXMgaXQgcmVuZGVyZWRcbiAgICAvLyBsYXN0IHRpbWUgd2UgbXV0YXRlZCBgY29tcG9uZW50RGlkQ2F0Y2gucm91dGVJZGAgZm9yIHRoZSBsYXN0IHJlbmRlcmVkXG4gICAgLy8gcm91dGUsIG5vdyB3ZSBrbm93IHdoZXJlIHRvIHJlbmRlciB0aGUgZXJyb3IgYm91bmRhcnkgKGZlZWxzIGEgbGl0dGxlXG4gICAgLy8gaGFja3kgYnV0IHRoYXQncyBob3cgaG9va3Mgd29yaykuIFRoaXMgdGVsbHMgdGhlIGVtdWxhdG9yIHRvIHN0b3BcbiAgICAvLyB0cmFja2luZyB0aGUgYHJvdXRlSWRgIGFzIHdlIHJlbmRlciBiZWNhdXNlIHdlIGFscmVhZHkgaGF2ZSBhbiBlcnJvciB0b1xuICAgIC8vIHJlbmRlci5cblxuICAgIGFwcFN0YXRlLnRyYWNrQm91bmRhcmllcyA9IGZhbHNlO1xuICAgIGFwcFN0YXRlLmVycm9yID0gYXdhaXQgc2VyaWFsaXplRXJyb3IoZXJyb3IpO1xuICAgIGVudHJ5Q29udGV4dC5zZXJ2ZXJIYW5kb2ZmU3RyaW5nID0gY3JlYXRlU2VydmVySGFuZG9mZlN0cmluZyhzZXJ2ZXJIYW5kb2ZmKTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgaGFuZGxlRG9jdW1lbnRSZXF1ZXN0KHJlcXVlc3QuY2xvbmUoKSwgcmVzcG9uc2VTdGF0dXNDb2RlLCByZXNwb25zZUhlYWRlcnMsIGVudHJ5Q29udGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChzZXJ2ZXJNb2RlICE9PSBTZXJ2ZXJNb2RlLlRlc3QpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIGxldCBtZXNzYWdlID0gXCJVbmV4cGVjdGVkIFNlcnZlciBFcnJvclwiO1xuXG4gICAgICBpZiAoc2VydmVyTW9kZSA9PT0gU2VydmVyTW9kZS5EZXZlbG9wbWVudCkge1xuICAgICAgICBtZXNzYWdlICs9IGBcXG5cXG4ke1N0cmluZyhlcnJvcil9YDtcbiAgICAgIH0gLy8gR29vZCBncmllZiBmb2xrcywgZ2V0IHlvdXIgYWN0IHRvZ2V0aGVyIFx1RDgzRFx1REUwMiFcblxuXG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG1lc3NhZ2UsIHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW5cIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmVzb3VyY2VSZXF1ZXN0KHtcbiAgbG9hZENvbnRleHQsXG4gIG1hdGNoZXMsXG4gIHJlcXVlc3QsXG4gIHNlcnZlck1vZGVcbn0pIHtcbiAgbGV0IG1hdGNoID0gbWF0Y2hlcy5zbGljZSgtMSlbMF07XG5cbiAgdHJ5IHtcbiAgICBpZiAoaXNBY3Rpb25SZXF1ZXN0KHJlcXVlc3QpKSB7XG4gICAgICByZXR1cm4gYXdhaXQgY2FsbFJvdXRlQWN0aW9uKHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGxvYWRDb250ZXh0LFxuICAgICAgICByZXF1ZXN0XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF3YWl0IGNhbGxSb3V0ZUxvYWRlcih7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBsb2FkQ29udGV4dCxcbiAgICAgICAgcmVxdWVzdFxuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChzZXJ2ZXJNb2RlICE9PSBTZXJ2ZXJNb2RlLlRlc3QpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIGxldCBtZXNzYWdlID0gXCJVbmV4cGVjdGVkIFNlcnZlciBFcnJvclwiO1xuXG4gICAgaWYgKHNlcnZlck1vZGUgPT09IFNlcnZlck1vZGUuRGV2ZWxvcG1lbnQpIHtcbiAgICAgIG1lc3NhZ2UgKz0gYFxcblxcbiR7U3RyaW5nKGVycm9yKX1gO1xuICAgIH0gLy8gR29vZCBncmllZiBmb2xrcywgZ2V0IHlvdXIgYWN0IHRvZ2V0aGVyIFx1RDgzRFx1REUwMiFcblxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShtZXNzYWdlLCB7XG4gICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXF1ZXN0VHlwZSh1cmwsIG1hdGNoZXMpIHtcbiAgaWYgKHVybC5zZWFyY2hQYXJhbXMuaGFzKFwiX2RhdGFcIikpIHtcbiAgICByZXR1cm4gXCJkYXRhXCI7XG4gIH1cblxuICBpZiAoIW1hdGNoZXMpIHtcbiAgICByZXR1cm4gXCJkb2N1bWVudFwiO1xuICB9XG5cbiAgbGV0IG1hdGNoID0gbWF0Y2hlcy5zbGljZSgtMSlbMF07XG5cbiAgaWYgKCFtYXRjaC5yb3V0ZS5tb2R1bGUuZGVmYXVsdCkge1xuICAgIHJldHVybiBcInJlc291cmNlXCI7XG4gIH1cblxuICByZXR1cm4gXCJkb2N1bWVudFwiO1xufVxuXG5mdW5jdGlvbiBpc0FjdGlvblJlcXVlc3QocmVxdWVzdCkge1xuICBsZXQgbWV0aG9kID0gcmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG1ldGhvZCA9PT0gXCJwb3N0XCIgfHwgbWV0aG9kID09PSBcInB1dFwiIHx8IG1ldGhvZCA9PT0gXCJwYXRjaFwiIHx8IG1ldGhvZCA9PT0gXCJkZWxldGVcIjtcbn1cblxuZnVuY3Rpb24gaXNIZWFkUmVxdWVzdChyZXF1ZXN0KSB7XG4gIHJldHVybiByZXF1ZXN0Lm1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImhlYWRcIjtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFJlcXVlc3RNZXRob2QocmVxdWVzdCkge1xuICByZXR1cm4gcmVxdWVzdC5tZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gXCJnZXRcIiB8fCBpc0hlYWRSZXF1ZXN0KHJlcXVlc3QpIHx8IGlzQWN0aW9uUmVxdWVzdChyZXF1ZXN0KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZXJyb3JCb3VuZGFyeUVycm9yKGVycm9yLCBzdGF0dXMpIHtcbiAgcmV0dXJuIGpzb24oYXdhaXQgc2VyaWFsaXplRXJyb3IoZXJyb3IpLCB7XG4gICAgc3RhdHVzLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiWC1SZW1peC1FcnJvclwiOiBcInllc1wiXG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNJbmRleFJlcXVlc3RVcmwodXJsKSB7XG4gIGxldCBpbmRleFJlcXVlc3QgPSBmYWxzZTtcblxuICBmb3IgKGxldCBwYXJhbSBvZiB1cmwuc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpKSB7XG4gICAgaWYgKCFwYXJhbSkge1xuICAgICAgaW5kZXhSZXF1ZXN0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXhSZXF1ZXN0O1xufVxuXG5mdW5jdGlvbiBnZXRBY3Rpb25SZXF1ZXN0TWF0Y2godXJsLCBtYXRjaGVzKSB7XG4gIGxldCBtYXRjaCA9IG1hdGNoZXMuc2xpY2UoLTEpWzBdO1xuXG4gIGlmICghaXNJbmRleFJlcXVlc3RVcmwodXJsKSAmJiBtYXRjaC5yb3V0ZS5pZC5lbmRzV2l0aChcIi9pbmRleFwiKSkge1xuICAgIHJldHVybiBtYXRjaGVzLnNsaWNlKC0yKVswXTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaDtcbn1cblxuZnVuY3Rpb24gZ2V0RGVlcGVzdFJvdXRlSWRXaXRoQm91bmRhcnkobWF0Y2hlcywga2V5KSB7XG4gIGxldCBtYXRjaGVkID0gZ2V0TWF0Y2hlc1VwVG9EZWVwZXN0Qm91bmRhcnkobWF0Y2hlcywga2V5KS5zbGljZSgtMSlbMF07XG4gIHJldHVybiBtYXRjaGVkID8gbWF0Y2hlZC5yb3V0ZS5pZCA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldE1hdGNoZXNVcFRvRGVlcGVzdEJvdW5kYXJ5KG1hdGNoZXMsIGtleSkge1xuICBsZXQgZGVlcGVzdEJvdW5kYXJ5SW5kZXggPSAtMTtcbiAgbWF0Y2hlcy5mb3JFYWNoKChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBpZiAobWF0Y2gucm91dGUubW9kdWxlW2tleV0pIHtcbiAgICAgIGRlZXBlc3RCb3VuZGFyeUluZGV4ID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBpZiAoZGVlcGVzdEJvdW5kYXJ5SW5kZXggPT09IC0xKSB7XG4gICAgLy8gbm8gcm91dGUgZXJyb3IgYm91bmRhcmllcywgZG9uJ3QgbmVlZCB0byBjYWxsIGFueSBsb2FkZXJzXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXMuc2xpY2UoMCwgZGVlcGVzdEJvdW5kYXJ5SW5kZXggKyAxKTtcbn0gLy8gVGhpcyBwcmV2ZW50cyBgPE91dGxldC8+YCBmcm9tIHJlbmRlcmluZyBhbnl0aGluZyBiZWxvdyB3aGVyZSB0aGUgZXJyb3IgdGhyZXdcbi8vIFRPRE86IG1heWJlIGRvIHRoaXMgaW4gPFJlbWl4RXJyb3JCb3VuZGFyeSArIGNvbnRleHQ+XG5cblxuZnVuY3Rpb24gZ2V0UmVuZGVyYWJsZU1hdGNoZXMobWF0Y2hlcywgYXBwU3RhdGUpIHtcbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gbm8gZXJyb3IsIG5vIHdvcnJpZXNcblxuXG4gIGlmICghYXBwU3RhdGUuY2F0Y2ggJiYgIWFwcFN0YXRlLmVycm9yKSB7XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cblxuICBsZXQgbGFzdFJlbmRlcmFibGVJbmRleCA9IC0xO1xuICBtYXRjaGVzLmZvckVhY2goKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGxldCBpZCA9IG1hdGNoLnJvdXRlLmlkO1xuXG4gICAgaWYgKGFwcFN0YXRlLnJlbmRlckJvdW5kYXJ5Um91dGVJZCA9PT0gaWQgfHwgYXBwU3RhdGUubG9hZGVyQm91bmRhcnlSb3V0ZUlkID09PSBpZCB8fCBhcHBTdGF0ZS5jYXRjaEJvdW5kYXJ5Um91dGVJZCA9PT0gaWQpIHtcbiAgICAgIGxhc3RSZW5kZXJhYmxlSW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gbWF0Y2hlcy5zbGljZSgwLCBsYXN0UmVuZGVyYWJsZUluZGV4ICsgMSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVJlcXVlc3RIYW5kbGVyIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBpc1Jlc3BvbnNlLCBpc1JlZGlyZWN0UmVzcG9uc2UsIGpzb24gfSBmcm9tICcuL3Jlc3BvbnNlcy5qcyc7XG5cbi8qKlxuICogQW4gb2JqZWN0IG9mIGFyYml0cmFyeSBmb3Igcm91dGUgbG9hZGVycyBhbmQgYWN0aW9ucyBwcm92aWRlZCBieSB0aGVcbiAqIHNlcnZlcidzIGBnZXRMb2FkQ29udGV4dCgpYCBmdW5jdGlvbi5cbiAqL1xuXG5hc3luYyBmdW5jdGlvbiBjYWxsUm91dGVBY3Rpb24oe1xuICBsb2FkQ29udGV4dCxcbiAgbWF0Y2gsXG4gIHJlcXVlc3Rcbn0pIHtcbiAgbGV0IGFjdGlvbiA9IG1hdGNoLnJvdXRlLm1vZHVsZS5hY3Rpb247XG5cbiAgaWYgKCFhY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtYWRlIGEgJHtyZXF1ZXN0Lm1ldGhvZH0gcmVxdWVzdCB0byAke3JlcXVlc3QudXJsfSBidXQgZGlkIG5vdCBwcm92aWRlIGAgKyBgYW4gXFxgYWN0aW9uXFxgIGZvciByb3V0ZSBcIiR7bWF0Y2gucm91dGUuaWR9XCIsIHNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIGAgKyBgcmVxdWVzdC5gKTtcbiAgfVxuXG4gIGxldCByZXN1bHQ7XG5cbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBhd2FpdCBhY3Rpb24oe1xuICAgICAgcmVxdWVzdDogc3RyaXBEYXRhUGFyYW0oc3RyaXBJbmRleFBhcmFtKHJlcXVlc3QpKSxcbiAgICAgIGNvbnRleHQ6IGxvYWRDb250ZXh0LFxuICAgICAgcGFyYW1zOiBtYXRjaC5wYXJhbXNcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoIWlzUmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICBpZiAoIWlzUmVkaXJlY3RSZXNwb25zZShlcnJvcikpIHtcbiAgICAgIGVycm9yLmhlYWRlcnMuc2V0KFwiWC1SZW1peC1DYXRjaFwiLCBcInllc1wiKTtcbiAgICB9XG5cbiAgICByZXN1bHQgPSBlcnJvcjtcbiAgfVxuXG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgWW91IGRlZmluZWQgYW4gYWN0aW9uIGZvciByb3V0ZSBcIiR7bWF0Y2gucm91dGUuaWR9XCIgYnV0IGRpZG4ndCByZXR1cm4gYCArIGBhbnl0aGluZyBmcm9tIHlvdXIgXFxgYWN0aW9uXFxgIGZ1bmN0aW9uLiBQbGVhc2UgcmV0dXJuIGEgdmFsdWUgb3IgXFxgbnVsbFxcYC5gKTtcbiAgfVxuXG4gIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQgOiBqc29uKHJlc3VsdCk7XG59XG5hc3luYyBmdW5jdGlvbiBjYWxsUm91dGVMb2FkZXIoe1xuICBsb2FkQ29udGV4dCxcbiAgbWF0Y2gsXG4gIHJlcXVlc3Rcbn0pIHtcbiAgbGV0IGxvYWRlciA9IG1hdGNoLnJvdXRlLm1vZHVsZS5sb2FkZXI7XG5cbiAgaWYgKCFsb2FkZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtYWRlIGEgJHtyZXF1ZXN0Lm1ldGhvZH0gcmVxdWVzdCB0byAke3JlcXVlc3QudXJsfSBidXQgZGlkIG5vdCBwcm92aWRlIGAgKyBgYSBcXGBsb2FkZXJcXGAgZm9yIHJvdXRlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiwgc28gdGhlcmUgaXMgbm8gd2F5IHRvIGhhbmRsZSB0aGUgYCArIGByZXF1ZXN0LmApO1xuICB9XG5cbiAgbGV0IHJlc3VsdDtcblxuICB0cnkge1xuICAgIHJlc3VsdCA9IGF3YWl0IGxvYWRlcih7XG4gICAgICByZXF1ZXN0OiBzdHJpcERhdGFQYXJhbShzdHJpcEluZGV4UGFyYW0ocmVxdWVzdC5jbG9uZSgpKSksXG4gICAgICBjb250ZXh0OiBsb2FkQ29udGV4dCxcbiAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKCFpc1Jlc3BvbnNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKCFpc1JlZGlyZWN0UmVzcG9uc2UoZXJyb3IpKSB7XG4gICAgICBlcnJvci5oZWFkZXJzLnNldChcIlgtUmVtaXgtQ2F0Y2hcIiwgXCJ5ZXNcIik7XG4gICAgfVxuXG4gICAgcmVzdWx0ID0gZXJyb3I7XG4gIH1cblxuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBkZWZpbmVkIGEgbG9hZGVyIGZvciByb3V0ZSBcIiR7bWF0Y2gucm91dGUuaWR9XCIgYnV0IGRpZG4ndCByZXR1cm4gYCArIGBhbnl0aGluZyBmcm9tIHlvdXIgXFxgbG9hZGVyXFxgIGZ1bmN0aW9uLiBQbGVhc2UgcmV0dXJuIGEgdmFsdWUgb3IgXFxgbnVsbFxcYC5gKTtcbiAgfVxuXG4gIHJldHVybiBpc1Jlc3BvbnNlKHJlc3VsdCkgPyByZXN1bHQgOiBqc29uKHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwSW5kZXhQYXJhbShyZXF1ZXN0KSB7XG4gIGxldCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgbGV0IGluZGV4VmFsdWVzID0gdXJsLnNlYXJjaFBhcmFtcy5nZXRBbGwoXCJpbmRleFwiKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJpbmRleFwiKTtcbiAgbGV0IGluZGV4VmFsdWVzVG9LZWVwID0gW107XG5cbiAgZm9yIChsZXQgaW5kZXhWYWx1ZSBvZiBpbmRleFZhbHVlcykge1xuICAgIGlmIChpbmRleFZhbHVlKSB7XG4gICAgICBpbmRleFZhbHVlc1RvS2VlcC5wdXNoKGluZGV4VmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IHRvS2VlcCBvZiBpbmRleFZhbHVlc1RvS2VlcCkge1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgdG9LZWVwKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUmVxdWVzdCh1cmwuaHJlZiwgcmVxdWVzdCk7XG59XG5cbmZ1bmN0aW9uIHN0cmlwRGF0YVBhcmFtKHJlcXVlc3QpIHtcbiAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICB1cmwuc2VhcmNoUGFyYW1zLmRlbGV0ZShcIl9kYXRhXCIpO1xuICByZXR1cm4gbmV3IFJlcXVlc3QodXJsLmhyZWYsIHJlcXVlc3QpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RGF0YShyZXNwb25zZSkge1xuICBsZXQgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcblxuICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9IC8vIFdoYXQgb3RoZXIgZGF0YSB0eXBlcyBkbyB3ZSBuZWVkIHRvIGhhbmRsZSBoZXJlPyBXaGF0IG90aGVyIGtpbmRzIG9mXG4gIC8vIHJlc3BvbnNlcyBhcmUgcGVvcGxlIGdvaW5nIHRvIGJlIHJldHVybmluZyBmcm9tIHRoZWlyIGxvYWRlcnM/XG4gIC8vIC0gYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkID9cbiAgLy8gLSBtdWx0aXBhcnQvZm9ybS1kYXRhID9cbiAgLy8gLSBiaW5hcnkgKGF1ZGlvL3ZpZGVvKSA/XG5cblxuICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xufVxuXG5leHBvcnQgeyBjYWxsUm91dGVBY3Rpb24sIGNhbGxSb3V0ZUxvYWRlciwgZXh0cmFjdERhdGEgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4zXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVudHJ5TWF0Y2hlcyhtYXRjaGVzLCByb3V0ZXMpIHtcbiAgcmV0dXJuIG1hdGNoZXMubWFwKG1hdGNoID0+ICh7XG4gICAgcGFyYW1zOiBtYXRjaC5wYXJhbXMsXG4gICAgcGF0aG5hbWU6IG1hdGNoLnBhdGhuYW1lLFxuICAgIHJvdXRlOiByb3V0ZXNbbWF0Y2gucm91dGUuaWRdXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzKG1hbmlmZXN0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtYW5pZmVzdCkucmVkdWNlKChtZW1vLCByb3V0ZUlkKSA9PiB7XG4gICAgbWVtb1tyb3V0ZUlkXSA9IG1hbmlmZXN0W3JvdXRlSWRdLm1vZHVsZTtcbiAgICByZXR1cm4gbWVtbztcbiAgfSwge30pO1xufVxuXG5leHBvcnQgeyBjcmVhdGVFbnRyeU1hdGNoZXMsIGNyZWF0ZUVudHJ5Um91dGVNb2R1bGVzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vKipcbiAqIFRoaXMgdGhpbmcgcHJvYmFibHkgd2FycmFudHMgc29tZSBleHBsYW5hdGlvbi5cbiAqXG4gKiBUaGUgd2hvbGUgcG9pbnQgaGVyZSBpcyB0byBlbXVsYXRlIGNvbXBvbmVudERpZENhdGNoIGZvciBzZXJ2ZXIgcmVuZGVyaW5nIGFuZFxuICogZGF0YSBsb2FkaW5nLiBJdCBjYW4gZ2V0IHRyaWNreS4gUmVhY3QgY2FuIGRvIHRoaXMgb24gY29tcG9uZW50IGJvdW5kYXJpZXNcbiAqIGJ1dCBkb2Vzbid0IHN1cHBvcnQgaXQgZm9yIHNlcnZlciByZW5kZXJpbmcgb3IgZGF0YSBsb2FkaW5nLiBXZSBrbm93IGVub3VnaFxuICogd2l0aCBuZXN0ZWQgcm91dGVzIHRvIGJlIGFibGUgdG8gZW11bGF0ZSB0aGUgYmVoYXZpb3IgKGJlY2F1c2Ugd2Uga25vdyB0aGVtXG4gKiBzdGF0aWNhbGx5IGJlZm9yZSByZW5kZXJpbmcuKVxuICpcbiAqIEVhY2ggcm91dGUgY2FuIGV4cG9ydCBhbiBgRXJyb3JCb3VuZGFyeWAuXG4gKlxuICogLSBXaGVuIHJlbmRlcmluZyB0aHJvd3MgYW4gZXJyb3IsIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5IHdpbGwgcmVuZGVyXG4gKiAgIChub3JtYWwgcmVhY3QgY29tcG9uZW50RGlkQ2F0Y2gpLiBUaGlzIHdpbGwgYmUgdGhlIHJvdXRlJ3Mgb3duIGJvdW5kYXJ5LCBidXRcbiAqICAgaWYgbm9uZSBpcyBwcm92aWRlZCwgaXQgd2lsbCBidWJibGUgdXAgdG8gdGhlIHBhcmVudHMuXG4gKiAtIFdoZW4gZGF0YSBsb2FkaW5nIHRocm93cyBhbiBlcnJvciwgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgd2lsbCByZW5kZXJcbiAqIC0gV2hlbiBwZXJmb3JtaW5nIGFuIGFjdGlvbiwgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgZm9yIHRoZSBhY3Rpb24nc1xuICogICByb3V0ZSB0cmVlIHdpbGwgcmVuZGVyIChubyByZWRpcmVjdCBoYXBwZW5zKVxuICpcbiAqIER1cmluZyBub3JtYWwgcmVhY3QgcmVuZGVyaW5nLCB3ZSBkbyBub3RoaW5nIHNwZWNpYWwsIGp1c3Qgbm9ybWFsXG4gKiBjb21wb25lbnREaWRDYXRjaC5cbiAqXG4gKiBGb3Igc2VydmVyIHJlbmRlcmluZywgd2UgbXV0YXRlIGByZW5kZXJCb3VuZGFyeVJvdXRlSWRgIHRvIGtub3cgdGhlIGxhc3RcbiAqIGxheW91dCB0aGF0IGhhcyBhbiBlcnJvciBib3VuZGFyeSB0aGF0IHRyaWVkIHRvIHJlbmRlci4gVGhpcyBlbXVsYXRlcyB3aGljaFxuICogbGF5b3V0IHdvdWxkIGNhdGNoIGEgdGhyb3duIGVycm9yLiBJZiB0aGUgcmVuZGVyaW5nIGZhaWxzLCB3ZSBjYXRjaCB0aGUgZXJyb3JcbiAqIG9uIHRoZSBzZXJ2ZXIsIGFuZCBnbyBhZ2FpbiBhIHNlY29uZCB0aW1lIHdpdGggdGhlIGVtdWxhdG9yIGhvbGRpbmcgb24gdG8gdGhlXG4gKiBpbmZvcm1hdGlvbiBpdCBuZWVkcyB0byByZW5kZXIgdGhlIHNhbWUgZXJyb3IgYm91bmRhcnkgYXMgYSBkeW5hbWljYWxseVxuICogdGhyb3duIHJlbmRlciBlcnJvci5cbiAqXG4gKiBXaGVuIGRhdGEgbG9hZGluZywgc2VydmVyIG9yIGNsaWVudCBzaWRlLCB3ZSB1c2UgdGhlIGVtdWxhdG9yIHRvIGxpa2V3aXNlXG4gKiBoYW5nIG9uIHRvIHRoZSBlcnJvciBhbmQgcmUtcmVuZGVyIGF0IHRoZSBhcHByb3ByaWF0ZSBsYXlvdXQgKHdoZXJlIGEgdGhyb3duXG4gKiBlcnJvciB3b3VsZCBoYXZlIGJlZW4gY2F1Z2h0IGJ5IGNEQykuXG4gKlxuICogV2hlbiBhY3Rpb25zIHRocm93LCBpdCBhbGwgd29ya3MgdGhlIHNhbWUuIFRoZXJlJ3MgYW4gZWRnZSBjYXNlIHRvIGJlIGF3YXJlXG4gKiBvZiB0aG91Z2guIEFjdGlvbnMgbm9ybWFsbHkgYXJlIHJlcXVpcmVkIHRvIHJlZGlyZWN0LCBidXQgaW4gdGhlIGNhc2Ugb2ZcbiAqIGVycm9ycywgd2UgcmVuZGVyIHRoZSBhY3Rpb24ncyByb3V0ZSB3aXRoIHRoZSBlbXVsYXRvciBob2xkaW5nIG9uIHRvIHRoZVxuICogZXJyb3IuIElmIGR1cmluZyB0aGlzIHJlbmRlciBhIHBhcmVudCByb3V0ZS9sb2FkZXIgdGhyb3dzIHdlIGlnbm9yZSB0aGF0IG5ld1xuICogZXJyb3IgYW5kIHJlbmRlciB0aGUgYWN0aW9uJ3Mgb3JpZ2luYWwgZXJyb3IgYXMgZGVlcGx5IGFzIHBvc3NpYmxlLiBJbiBvdGhlclxuICogd29yZHMsIHdlIHNpbXBseSBpZ25vcmUgdGhlIG5ldyBlcnJvciBhbmQgdXNlIHRoZSBhY3Rpb24ncyBlcnJvciBpbiBwbGFjZVxuICogYmVjYXVzZSBpdCBjYW1lIGZpcnN0LCBhbmQgdGhhdCBqdXN0IHdvdWxkbid0IGJlIGZhaXIgdG8gbGV0IGVycm9ycyBjdXQgaW5cbiAqIGxpbmUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICBzdGFjazogZXJyb3Iuc3RhY2tcbiAgfTtcbn1cblxuZXhwb3J0IHsgc2VyaWFsaXplRXJyb3IgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4zXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IHNwbGl0Q29va2llc1N0cmluZyB9IGZyb20gJ3NldC1jb29raWUtcGFyc2VyJztcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRIZWFkZXJzKGJ1aWxkLCBtYXRjaGVzLCByb3V0ZUxvYWRlclJlc3BvbnNlcywgYWN0aW9uUmVzcG9uc2UpIHtcbiAgcmV0dXJuIG1hdGNoZXMucmVkdWNlKChwYXJlbnRIZWFkZXJzLCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBsZXQgcm91dGVNb2R1bGUgPSBidWlsZC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdLm1vZHVsZTtcbiAgICBsZXQgcm91dGVMb2FkZXJSZXNwb25zZSA9IHJvdXRlTG9hZGVyUmVzcG9uc2VzW21hdGNoLnJvdXRlLmlkXTtcbiAgICBsZXQgbG9hZGVySGVhZGVycyA9IHJvdXRlTG9hZGVyUmVzcG9uc2UgPyByb3V0ZUxvYWRlclJlc3BvbnNlLmhlYWRlcnMgOiBuZXcgSGVhZGVycygpO1xuICAgIGxldCBhY3Rpb25IZWFkZXJzID0gYWN0aW9uUmVzcG9uc2UgPyBhY3Rpb25SZXNwb25zZS5oZWFkZXJzIDogbmV3IEhlYWRlcnMoKTtcbiAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJvdXRlTW9kdWxlLmhlYWRlcnMgPyB0eXBlb2Ygcm91dGVNb2R1bGUuaGVhZGVycyA9PT0gXCJmdW5jdGlvblwiID8gcm91dGVNb2R1bGUuaGVhZGVycyh7XG4gICAgICBsb2FkZXJIZWFkZXJzLFxuICAgICAgcGFyZW50SGVhZGVycyxcbiAgICAgIGFjdGlvbkhlYWRlcnNcbiAgICB9KSA6IHJvdXRlTW9kdWxlLmhlYWRlcnMgOiB1bmRlZmluZWQpOyAvLyBBdXRvbWF0aWNhbGx5IHByZXNlcnZlIFNldC1Db29raWUgaGVhZGVycyB0aGF0IHdlcmUgc2V0IGVpdGhlciBieSB0aGVcbiAgICAvLyBsb2FkZXIgb3IgYnkgYSBwYXJlbnQgcm91dGUuXG5cbiAgICBwcmVwZW5kQ29va2llcyhhY3Rpb25IZWFkZXJzLCBoZWFkZXJzKTtcbiAgICBwcmVwZW5kQ29va2llcyhsb2FkZXJIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICBwcmVwZW5kQ29va2llcyhwYXJlbnRIZWFkZXJzLCBoZWFkZXJzKTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfSwgbmV3IEhlYWRlcnMoKSk7XG59XG5cbmZ1bmN0aW9uIHByZXBlbmRDb29raWVzKHBhcmVudEhlYWRlcnMsIGNoaWxkSGVhZGVycykge1xuICBsZXQgcGFyZW50U2V0Q29va2llU3RyaW5nID0gcGFyZW50SGVhZGVycy5nZXQoXCJTZXQtQ29va2llXCIpO1xuXG4gIGlmIChwYXJlbnRTZXRDb29raWVTdHJpbmcpIHtcbiAgICBsZXQgY29va2llcyA9IHNwbGl0Q29va2llc1N0cmluZyhwYXJlbnRTZXRDb29raWVTdHJpbmcpO1xuICAgIGNvb2tpZXMuZm9yRWFjaChjb29raWUgPT4ge1xuICAgICAgY2hpbGRIZWFkZXJzLmFwcGVuZChcIlNldC1Db29raWVcIiwgY29va2llKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgeyBnZXREb2N1bWVudEhlYWRlcnMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4zXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCB7IG1hdGNoUm91dGVzIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5cbi8vIFRPRE86IGV4cG9ydC9pbXBvcnQgZnJvbSByZWFjdC1yb3V0ZXItZG9tXG5mdW5jdGlvbiBtYXRjaFNlcnZlclJvdXRlcyhyb3V0ZXMsIHBhdGhuYW1lKSB7XG4gIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzLCBwYXRobmFtZSk7XG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIG51bGw7XG4gIHJldHVybiBtYXRjaGVzLm1hcChtYXRjaCA9PiAoe1xuICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaC5wYXRobmFtZSxcbiAgICByb3V0ZTogbWF0Y2gucm91dGVcbiAgfSkpO1xufVxuXG5leHBvcnQgeyBtYXRjaFNlcnZlclJvdXRlcyB9O1xuIiwgImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcblxuLyoqXHJcbiAqIEFjdGlvbnMgcmVwcmVzZW50IHRoZSB0eXBlIG9mIGNoYW5nZSB0byBhIGxvY2F0aW9uIHZhbHVlLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2FjdGlvblxyXG4gKi9cbnZhciBBY3Rpb247XG5cbihmdW5jdGlvbiAoQWN0aW9uKSB7XG4gIC8qKlxyXG4gICAqIEEgUE9QIGluZGljYXRlcyBhIGNoYW5nZSB0byBhbiBhcmJpdHJhcnkgaW5kZXggaW4gdGhlIGhpc3Rvcnkgc3RhY2ssIHN1Y2hcclxuICAgKiBhcyBhIGJhY2sgb3IgZm9yd2FyZCBuYXZpZ2F0aW9uLiBJdCBkb2VzIG5vdCBkZXNjcmliZSB0aGUgZGlyZWN0aW9uIG9mIHRoZVxyXG4gICAqIG5hdmlnYXRpb24sIG9ubHkgdGhhdCB0aGUgY3VycmVudCBpbmRleCBjaGFuZ2VkLlxyXG4gICAqXHJcbiAgICogTm90ZTogVGhpcyBpcyB0aGUgZGVmYXVsdCBhY3Rpb24gZm9yIG5ld2x5IGNyZWF0ZWQgaGlzdG9yeSBvYmplY3RzLlxyXG4gICAqL1xuICBBY3Rpb25bXCJQb3BcIl0gPSBcIlBPUFwiO1xuICAvKipcclxuICAgKiBBIFBVU0ggaW5kaWNhdGVzIGEgbmV3IGVudHJ5IGJlaW5nIGFkZGVkIHRvIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoIGFzIHdoZW5cclxuICAgKiBhIGxpbmsgaXMgY2xpY2tlZCBhbmQgYSBuZXcgcGFnZSBsb2Fkcy4gV2hlbiB0aGlzIGhhcHBlbnMsIGFsbCBzdWJzZXF1ZW50XHJcbiAgICogZW50cmllcyBpbiB0aGUgc3RhY2sgYXJlIGxvc3QuXHJcbiAgICovXG5cbiAgQWN0aW9uW1wiUHVzaFwiXSA9IFwiUFVTSFwiO1xuICAvKipcclxuICAgKiBBIFJFUExBQ0UgaW5kaWNhdGVzIHRoZSBlbnRyeSBhdCB0aGUgY3VycmVudCBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFja1xyXG4gICAqIGJlaW5nIHJlcGxhY2VkIGJ5IGEgbmV3IG9uZS5cclxuICAgKi9cblxuICBBY3Rpb25bXCJSZXBsYWNlXCJdID0gXCJSRVBMQUNFXCI7XG59KShBY3Rpb24gfHwgKEFjdGlvbiA9IHt9KSk7XG5cbnZhciByZWFkT25seSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqKTtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmo7XG59O1xuXG5mdW5jdGlvbiB3YXJuaW5nKGNvbmQsIG1lc3NhZ2UpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSBjb25zb2xlLndhcm4obWVzc2FnZSk7XG5cbiAgICB0cnkge1xuICAgICAgLy8gV2VsY29tZSB0byBkZWJ1Z2dpbmcgaGlzdG9yeSFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG59XG5cbnZhciBCZWZvcmVVbmxvYWRFdmVudFR5cGUgPSAnYmVmb3JldW5sb2FkJztcbnZhciBIYXNoQ2hhbmdlRXZlbnRUeXBlID0gJ2hhc2hjaGFuZ2UnO1xudmFyIFBvcFN0YXRlRXZlbnRUeXBlID0gJ3BvcHN0YXRlJztcbi8qKlxyXG4gKiBCcm93c2VyIGhpc3Rvcnkgc3RvcmVzIHRoZSBsb2NhdGlvbiBpbiByZWd1bGFyIFVSTHMuIFRoaXMgaXMgdGhlIHN0YW5kYXJkIGZvclxyXG4gKiBtb3N0IHdlYiBhcHBzLCBidXQgaXQgcmVxdWlyZXMgc29tZSBjb25maWd1cmF0aW9uIG9uIHRoZSBzZXJ2ZXIgdG8gZW5zdXJlIHlvdVxyXG4gKiBzZXJ2ZSB0aGUgc2FtZSBhcHAgYXQgbXVsdGlwbGUgVVJMcy5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVicm93c2VyaGlzdG9yeVxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlQnJvd3Nlckhpc3Rvcnkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHdpbmRvdyA9IF9vcHRpb25zLndpbmRvdyxcbiAgICAgIHdpbmRvdyA9IF9vcHRpb25zJHdpbmRvdyA9PT0gdm9pZCAwID8gZG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBfb3B0aW9ucyR3aW5kb3c7XG4gIHZhciBnbG9iYWxIaXN0b3J5ID0gd2luZG93Lmhpc3Rvcnk7XG5cbiAgZnVuY3Rpb24gZ2V0SW5kZXhBbmRMb2NhdGlvbigpIHtcbiAgICB2YXIgX3dpbmRvdyRsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbixcbiAgICAgICAgcGF0aG5hbWUgPSBfd2luZG93JGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICBzZWFyY2ggPSBfd2luZG93JGxvY2F0aW9uLnNlYXJjaCxcbiAgICAgICAgaGFzaCA9IF93aW5kb3ckbG9jYXRpb24uaGFzaDtcbiAgICB2YXIgc3RhdGUgPSBnbG9iYWxIaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgIHJldHVybiBbc3RhdGUuaWR4LCByZWFkT25seSh7XG4gICAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICAgIGhhc2g6IGhhc2gsXG4gICAgICBzdGF0ZTogc3RhdGUudXNyIHx8IG51bGwsXG4gICAgICBrZXk6IHN0YXRlLmtleSB8fCAnZGVmYXVsdCdcbiAgICB9KV07XG4gIH1cblxuICB2YXIgYmxvY2tlZFBvcFR4ID0gbnVsbDtcblxuICBmdW5jdGlvbiBoYW5kbGVQb3AoKSB7XG4gICAgaWYgKGJsb2NrZWRQb3BUeCkge1xuICAgICAgYmxvY2tlcnMuY2FsbChibG9ja2VkUG9wVHgpO1xuICAgICAgYmxvY2tlZFBvcFR4ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUG9wO1xuXG4gICAgICB2YXIgX2dldEluZGV4QW5kTG9jYXRpb24gPSBnZXRJbmRleEFuZExvY2F0aW9uKCksXG4gICAgICAgICAgbmV4dEluZGV4ID0gX2dldEluZGV4QW5kTG9jYXRpb25bMF0sXG4gICAgICAgICAgbmV4dExvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb25bMV07XG5cbiAgICAgIGlmIChibG9ja2Vycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG5leHRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGRlbHRhID0gaW5kZXggLSBuZXh0SW5kZXg7XG5cbiAgICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIC8vIFJldmVydCB0aGUgUE9QXG4gICAgICAgICAgICBibG9ja2VkUG9wVHggPSB7XG4gICAgICAgICAgICAgIGFjdGlvbjogbmV4dEFjdGlvbixcbiAgICAgICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICAgICAgcmV0cnk6IGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgICAgICAgICAgIGdvKGRlbHRhICogLTEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ28oZGVsdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUcnlpbmcgdG8gUE9QIHRvIGEgbG9jYXRpb24gd2l0aCBubyBpbmRleC4gV2UgZGlkIG5vdCBjcmVhdGVcbiAgICAgICAgICAvLyB0aGlzIGxvY2F0aW9uLCBzbyB3ZSBjYW4ndCBlZmZlY3RpdmVseSBibG9jayB0aGUgbmF2aWdhdGlvbi5cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAvLyBUT0RPOiBXcml0ZSB1cCBhIGRvYyB0aGF0IGV4cGxhaW5zIG91ciBibG9ja2luZyBzdHJhdGVneSBpblxuICAgICAgICAgIC8vIGRldGFpbCBhbmQgbGluayB0byBpdCBoZXJlIHNvIHBlb3BsZSBjYW4gdW5kZXJzdGFuZCBiZXR0ZXIgd2hhdFxuICAgICAgICAgIC8vIGlzIGdvaW5nIG9uIGFuZCBob3cgdG8gYXZvaWQgaXQuXG4gICAgICAgICAgXCJZb3UgYXJlIHRyeWluZyB0byBibG9jayBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gdGhhdCB3YXMgbm90IFwiICsgXCJjcmVhdGVkIGJ5IHRoZSBoaXN0b3J5IGxpYnJhcnkuIFRoZSBibG9jayB3aWxsIGZhaWwgc2lsZW50bHkgaW4gXCIgKyBcInByb2R1Y3Rpb24sIGJ1dCBpbiBnZW5lcmFsIHlvdSBzaG91bGQgZG8gYWxsIG5hdmlnYXRpb24gd2l0aCB0aGUgXCIgKyBcImhpc3RvcnkgbGlicmFyeSAoaW5zdGVhZCBvZiB1c2luZyB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgZGlyZWN0bHkpIFwiICsgXCJ0byBhdm9pZCB0aGlzIHNpdHVhdGlvbi5cIikgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7XG4gIHZhciBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuXG4gIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbjIgPSBnZXRJbmRleEFuZExvY2F0aW9uKCksXG4gICAgICBpbmRleCA9IF9nZXRJbmRleEFuZExvY2F0aW9uMlswXSxcbiAgICAgIGxvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb24yWzFdO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBjcmVhdGVFdmVudHMoKTtcbiAgdmFyIGJsb2NrZXJzID0gY3JlYXRlRXZlbnRzKCk7XG5cbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoX2V4dGVuZHMoe30sIGdsb2JhbEhpc3Rvcnkuc3RhdGUsIHtcbiAgICAgIGlkeDogaW5kZXhcbiAgICB9KSwgJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfSAvLyBzdGF0ZSBkZWZhdWx0cyB0byBgbnVsbGAgYmVjYXVzZSBgd2luZG93Lmhpc3Rvcnkuc3RhdGVgIGRvZXNcblxuXG4gIGZ1bmN0aW9uIGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZWFkT25seShfZXh0ZW5kcyh7XG4gICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBoYXNoOiAnJyxcbiAgICAgIHNlYXJjaDogJydcbiAgICB9LCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8gcGFyc2VQYXRoKHRvKSA6IHRvLCB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBrZXk6IGNyZWF0ZUtleSgpXG4gICAgfSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlQW5kVXJsKG5leHRMb2NhdGlvbiwgaW5kZXgpIHtcbiAgICByZXR1cm4gW3tcbiAgICAgIHVzcjogbmV4dExvY2F0aW9uLnN0YXRlLFxuICAgICAga2V5OiBuZXh0TG9jYXRpb24ua2V5LFxuICAgICAgaWR4OiBpbmRleFxuICAgIH0sIGNyZWF0ZUhyZWYobmV4dExvY2F0aW9uKV07XG4gIH1cblxuICBmdW5jdGlvbiBhbGxvd1R4KGFjdGlvbiwgbG9jYXRpb24sIHJldHJ5KSB7XG4gICAgcmV0dXJuICFibG9ja2Vycy5sZW5ndGggfHwgKGJsb2NrZXJzLmNhbGwoe1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICByZXRyeTogcmV0cnlcbiAgICB9KSwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlUeChuZXh0QWN0aW9uKSB7XG4gICAgYWN0aW9uID0gbmV4dEFjdGlvbjtcblxuICAgIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbjMgPSBnZXRJbmRleEFuZExvY2F0aW9uKCk7XG5cbiAgICBpbmRleCA9IF9nZXRJbmRleEFuZExvY2F0aW9uM1swXTtcbiAgICBsb2NhdGlvbiA9IF9nZXRJbmRleEFuZExvY2F0aW9uM1sxXTtcbiAgICBsaXN0ZW5lcnMuY2FsbCh7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaCh0bywgc3RhdGUpIHtcbiAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgIHZhciBuZXh0TG9jYXRpb24gPSBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKTtcblxuICAgIGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgcHVzaCh0bywgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChhbGxvd1R4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbiwgcmV0cnkpKSB7XG4gICAgICB2YXIgX2dldEhpc3RvcnlTdGF0ZUFuZFVyID0gZ2V0SGlzdG9yeVN0YXRlQW5kVXJsKG5leHRMb2NhdGlvbiwgaW5kZXggKyAxKSxcbiAgICAgICAgICBoaXN0b3J5U3RhdGUgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXJbMF0sXG4gICAgICAgICAgdXJsID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyWzFdOyAvLyBUT0RPOiBTdXBwb3J0IGZvcmNlZCByZWxvYWRpbmdcbiAgICAgIC8vIHRyeS4uLmNhdGNoIGJlY2F1c2UgaU9TIGxpbWl0cyB1cyB0byAxMDAgcHVzaFN0YXRlIGNhbGxzIDovXG5cblxuICAgICAgdHJ5IHtcbiAgICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgdXJsKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFRoZXkgYXJlIGdvaW5nIHRvIGxvc2Ugc3RhdGUgaGVyZSwgYnV0IHRoZXJlIGlzIG5vIHJlYWxcbiAgICAgICAgLy8gd2F5IHRvIHdhcm4gdGhlbSBhYm91dCBpdCBzaW5jZSB0aGUgcGFnZSB3aWxsIHJlZnJlc2guLi5cbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgICAgfVxuXG4gICAgICBhcHBseVR4KG5leHRBY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UodG8sIHN0YXRlKSB7XG4gICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICB2YXIgbmV4dExvY2F0aW9uID0gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSk7XG5cbiAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgIHJlcGxhY2UodG8sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgdmFyIF9nZXRIaXN0b3J5U3RhdGVBbmRVcjIgPSBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCksXG4gICAgICAgICAgaGlzdG9yeVN0YXRlID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyMlswXSxcbiAgICAgICAgICB1cmwgPSBfZ2V0SGlzdG9yeVN0YXRlQW5kVXIyWzFdOyAvLyBUT0RPOiBTdXBwb3J0IGZvcmNlZCByZWxvYWRpbmdcblxuXG4gICAgICBnbG9iYWxIaXN0b3J5LnJlcGxhY2VTdGF0ZShoaXN0b3J5U3RhdGUsICcnLCB1cmwpO1xuICAgICAgYXBwbHlUeChuZXh0QWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnbyhkZWx0YSkge1xuICAgIGdsb2JhbEhpc3RvcnkuZ28oZGVsdGEpO1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcblxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9LFxuXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGJhY2s6IGZ1bmN0aW9uIGJhY2soKSB7XG4gICAgICBnbygtMSk7XG4gICAgfSxcbiAgICBmb3J3YXJkOiBmdW5jdGlvbiBmb3J3YXJkKCkge1xuICAgICAgZ28oMSk7XG4gICAgfSxcbiAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIGJsb2NrOiBmdW5jdGlvbiBibG9jayhibG9ja2VyKSB7XG4gICAgICB2YXIgdW5ibG9jayA9IGJsb2NrZXJzLnB1c2goYmxvY2tlcik7XG5cbiAgICAgIGlmIChibG9ja2Vycy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoQmVmb3JlVW5sb2FkRXZlbnRUeXBlLCBwcm9tcHRCZWZvcmVVbmxvYWQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB1bmJsb2NrKCk7IC8vIFJlbW92ZSB0aGUgYmVmb3JldW5sb2FkIGxpc3RlbmVyIHNvIHRoZSBkb2N1bWVudCBtYXlcbiAgICAgICAgLy8gc3RpbGwgYmUgc2FsdmFnZWFibGUgaW4gdGhlIHBhZ2VoaWRlIGV2ZW50LlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jdW5sb2FkaW5nLWRvY3VtZW50c1xuXG4gICAgICAgIGlmICghYmxvY2tlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoQmVmb3JlVW5sb2FkRXZlbnRUeXBlLCBwcm9tcHRCZWZvcmVVbmxvYWQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG4vKipcclxuICogSGFzaCBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gd2luZG93LmxvY2F0aW9uLmhhc2guIFRoaXMgbWFrZXMgaXQgaWRlYWxcclxuICogZm9yIHNpdHVhdGlvbnMgd2hlcmUgeW91IGRvbid0IHdhbnQgdG8gc2VuZCB0aGUgbG9jYXRpb24gdG8gdGhlIHNlcnZlciBmb3JcclxuICogc29tZSByZWFzb24sIGVpdGhlciBiZWNhdXNlIHlvdSBkbyBjYW5ub3QgY29uZmlndXJlIGl0IG9yIHRoZSBVUkwgc3BhY2UgaXNcclxuICogcmVzZXJ2ZWQgZm9yIHNvbWV0aGluZyBlbHNlLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWhhc2hoaXN0b3J5XHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVIYXNoSGlzdG9yeShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMyID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zMiR3aW5kb3cgPSBfb3B0aW9uczIud2luZG93LFxuICAgICAgd2luZG93ID0gX29wdGlvbnMyJHdpbmRvdyA9PT0gdm9pZCAwID8gZG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBfb3B0aW9uczIkd2luZG93O1xuICB2YXIgZ2xvYmFsSGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xuXG4gIGZ1bmN0aW9uIGdldEluZGV4QW5kTG9jYXRpb24oKSB7XG4gICAgdmFyIF9wYXJzZVBhdGggPSBwYXJzZVBhdGgod2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpKSxcbiAgICAgICAgX3BhcnNlUGF0aCRwYXRobmFtZSA9IF9wYXJzZVBhdGgucGF0aG5hbWUsXG4gICAgICAgIHBhdGhuYW1lID0gX3BhcnNlUGF0aCRwYXRobmFtZSA9PT0gdm9pZCAwID8gJy8nIDogX3BhcnNlUGF0aCRwYXRobmFtZSxcbiAgICAgICAgX3BhcnNlUGF0aCRzZWFyY2ggPSBfcGFyc2VQYXRoLnNlYXJjaCxcbiAgICAgICAgc2VhcmNoID0gX3BhcnNlUGF0aCRzZWFyY2ggPT09IHZvaWQgMCA/ICcnIDogX3BhcnNlUGF0aCRzZWFyY2gsXG4gICAgICAgIF9wYXJzZVBhdGgkaGFzaCA9IF9wYXJzZVBhdGguaGFzaCxcbiAgICAgICAgaGFzaCA9IF9wYXJzZVBhdGgkaGFzaCA9PT0gdm9pZCAwID8gJycgOiBfcGFyc2VQYXRoJGhhc2g7XG5cbiAgICB2YXIgc3RhdGUgPSBnbG9iYWxIaXN0b3J5LnN0YXRlIHx8IHt9O1xuICAgIHJldHVybiBbc3RhdGUuaWR4LCByZWFkT25seSh7XG4gICAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICAgIGhhc2g6IGhhc2gsXG4gICAgICBzdGF0ZTogc3RhdGUudXNyIHx8IG51bGwsXG4gICAgICBrZXk6IHN0YXRlLmtleSB8fCAnZGVmYXVsdCdcbiAgICB9KV07XG4gIH1cblxuICB2YXIgYmxvY2tlZFBvcFR4ID0gbnVsbDtcblxuICBmdW5jdGlvbiBoYW5kbGVQb3AoKSB7XG4gICAgaWYgKGJsb2NrZWRQb3BUeCkge1xuICAgICAgYmxvY2tlcnMuY2FsbChibG9ja2VkUG9wVHgpO1xuICAgICAgYmxvY2tlZFBvcFR4ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUG9wO1xuXG4gICAgICB2YXIgX2dldEluZGV4QW5kTG9jYXRpb240ID0gZ2V0SW5kZXhBbmRMb2NhdGlvbigpLFxuICAgICAgICAgIG5leHRJbmRleCA9IF9nZXRJbmRleEFuZExvY2F0aW9uNFswXSxcbiAgICAgICAgICBuZXh0TG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjRbMV07XG5cbiAgICAgIGlmIChibG9ja2Vycy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKG5leHRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIGRlbHRhID0gaW5kZXggLSBuZXh0SW5kZXg7XG5cbiAgICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIC8vIFJldmVydCB0aGUgUE9QXG4gICAgICAgICAgICBibG9ja2VkUG9wVHggPSB7XG4gICAgICAgICAgICAgIGFjdGlvbjogbmV4dEFjdGlvbixcbiAgICAgICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICAgICAgcmV0cnk6IGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgICAgICAgICAgIGdvKGRlbHRhICogLTEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ28oZGVsdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUcnlpbmcgdG8gUE9QIHRvIGEgbG9jYXRpb24gd2l0aCBubyBpbmRleC4gV2UgZGlkIG5vdCBjcmVhdGVcbiAgICAgICAgICAvLyB0aGlzIGxvY2F0aW9uLCBzbyB3ZSBjYW4ndCBlZmZlY3RpdmVseSBibG9jayB0aGUgbmF2aWdhdGlvbi5cbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCAvLyBUT0RPOiBXcml0ZSB1cCBhIGRvYyB0aGF0IGV4cGxhaW5zIG91ciBibG9ja2luZyBzdHJhdGVneSBpblxuICAgICAgICAgIC8vIGRldGFpbCBhbmQgbGluayB0byBpdCBoZXJlIHNvIHBlb3BsZSBjYW4gdW5kZXJzdGFuZCBiZXR0ZXJcbiAgICAgICAgICAvLyB3aGF0IGlzIGdvaW5nIG9uIGFuZCBob3cgdG8gYXZvaWQgaXQuXG4gICAgICAgICAgXCJZb3UgYXJlIHRyeWluZyB0byBibG9jayBhIFBPUCBuYXZpZ2F0aW9uIHRvIGEgbG9jYXRpb24gdGhhdCB3YXMgbm90IFwiICsgXCJjcmVhdGVkIGJ5IHRoZSBoaXN0b3J5IGxpYnJhcnkuIFRoZSBibG9jayB3aWxsIGZhaWwgc2lsZW50bHkgaW4gXCIgKyBcInByb2R1Y3Rpb24sIGJ1dCBpbiBnZW5lcmFsIHlvdSBzaG91bGQgZG8gYWxsIG5hdmlnYXRpb24gd2l0aCB0aGUgXCIgKyBcImhpc3RvcnkgbGlicmFyeSAoaW5zdGVhZCBvZiB1c2luZyB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgZGlyZWN0bHkpIFwiICsgXCJ0byBhdm9pZCB0aGlzIHNpdHVhdGlvbi5cIikgOiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoUG9wU3RhdGVFdmVudFR5cGUsIGhhbmRsZVBvcCk7IC8vIHBvcHN0YXRlIGRvZXMgbm90IGZpcmUgb24gaGFzaGNoYW5nZSBpbiBJRSAxMSBhbmQgb2xkICh0cmlkZW50KSBFZGdlXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RlL2RvY3MvV2ViL0FQSS9XaW5kb3cvcG9wc3RhdGVfZXZlbnRcblxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihIYXNoQ2hhbmdlRXZlbnRUeXBlLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9nZXRJbmRleEFuZExvY2F0aW9uNSA9IGdldEluZGV4QW5kTG9jYXRpb24oKSxcbiAgICAgICAgbmV4dExvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb241WzFdOyAvLyBJZ25vcmUgZXh0cmFuZW91cyBoYXNoY2hhbmdlIGV2ZW50cy5cblxuXG4gICAgaWYgKGNyZWF0ZVBhdGgobmV4dExvY2F0aW9uKSAhPT0gY3JlYXRlUGF0aChsb2NhdGlvbikpIHtcbiAgICAgIGhhbmRsZVBvcCgpO1xuICAgIH1cbiAgfSk7XG4gIHZhciBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuXG4gIHZhciBfZ2V0SW5kZXhBbmRMb2NhdGlvbjYgPSBnZXRJbmRleEFuZExvY2F0aW9uKCksXG4gICAgICBpbmRleCA9IF9nZXRJbmRleEFuZExvY2F0aW9uNlswXSxcbiAgICAgIGxvY2F0aW9uID0gX2dldEluZGV4QW5kTG9jYXRpb242WzFdO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBjcmVhdGVFdmVudHMoKTtcbiAgdmFyIGJsb2NrZXJzID0gY3JlYXRlRXZlbnRzKCk7XG5cbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoX2V4dGVuZHMoe30sIGdsb2JhbEhpc3Rvcnkuc3RhdGUsIHtcbiAgICAgIGlkeDogaW5kZXhcbiAgICB9KSwgJycpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmFzZUhyZWYoKSB7XG4gICAgdmFyIGJhc2UgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdiYXNlJyk7XG4gICAgdmFyIGhyZWYgPSAnJztcblxuICAgIGlmIChiYXNlICYmIGJhc2UuZ2V0QXR0cmlidXRlKCdocmVmJykpIHtcbiAgICAgIHZhciB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgIHZhciBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgICAgaHJlZiA9IGhhc2hJbmRleCA9PT0gLTEgPyB1cmwgOiB1cmwuc2xpY2UoMCwgaGFzaEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaHJlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUhyZWYodG8pIHtcbiAgICByZXR1cm4gZ2V0QmFzZUhyZWYoKSArICcjJyArICh0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8gdG8gOiBjcmVhdGVQYXRoKHRvKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKSB7XG4gICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICAgIHN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVhZE9ubHkoX2V4dGVuZHMoe1xuICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgaGFzaDogJycsXG4gICAgICBzZWFyY2g6ICcnXG4gICAgfSwgdHlwZW9mIHRvID09PSAnc3RyaW5nJyA/IHBhcnNlUGF0aCh0bykgOiB0bywge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAga2V5OiBjcmVhdGVLZXkoKVxuICAgIH0pKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEhpc3RvcnlTdGF0ZUFuZFVybChuZXh0TG9jYXRpb24sIGluZGV4KSB7XG4gICAgcmV0dXJuIFt7XG4gICAgICB1c3I6IG5leHRMb2NhdGlvbi5zdGF0ZSxcbiAgICAgIGtleTogbmV4dExvY2F0aW9uLmtleSxcbiAgICAgIGlkeDogaW5kZXhcbiAgICB9LCBjcmVhdGVIcmVmKG5leHRMb2NhdGlvbildO1xuICB9XG5cbiAgZnVuY3Rpb24gYWxsb3dUeChhY3Rpb24sIGxvY2F0aW9uLCByZXRyeSkge1xuICAgIHJldHVybiAhYmxvY2tlcnMubGVuZ3RoIHx8IChibG9ja2Vycy5jYWxsKHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgcmV0cnk6IHJldHJ5XG4gICAgfSksIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5VHgobmV4dEFjdGlvbikge1xuICAgIGFjdGlvbiA9IG5leHRBY3Rpb247XG5cbiAgICB2YXIgX2dldEluZGV4QW5kTG9jYXRpb243ID0gZ2V0SW5kZXhBbmRMb2NhdGlvbigpO1xuXG4gICAgaW5kZXggPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjdbMF07XG4gICAgbG9jYXRpb24gPSBfZ2V0SW5kZXhBbmRMb2NhdGlvbjdbMV07XG4gICAgbGlzdGVuZXJzLmNhbGwoe1xuICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb25cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2godG8sIHN0YXRlKSB7XG4gICAgdmFyIG5leHRBY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICB2YXIgbmV4dExvY2F0aW9uID0gZ2V0TmV4dExvY2F0aW9uKHRvLCBzdGF0ZSk7XG5cbiAgICBmdW5jdGlvbiByZXRyeSgpIHtcbiAgICAgIHB1c2godG8sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKG5leHRMb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJywgXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goXCIgKyBKU09OLnN0cmluZ2lmeSh0bykgKyBcIilcIikgOiB2b2lkIDA7XG5cbiAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgdmFyIF9nZXRIaXN0b3J5U3RhdGVBbmRVcjMgPSBnZXRIaXN0b3J5U3RhdGVBbmRVcmwobmV4dExvY2F0aW9uLCBpbmRleCArIDEpLFxuICAgICAgICAgIGhpc3RvcnlTdGF0ZSA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVcjNbMF0sXG4gICAgICAgICAgdXJsID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyM1sxXTsgLy8gVE9ETzogU3VwcG9ydCBmb3JjZWQgcmVsb2FkaW5nXG4gICAgICAvLyB0cnkuLi5jYXRjaCBiZWNhdXNlIGlPUyBsaW1pdHMgdXMgdG8gMTAwIHB1c2hTdGF0ZSBjYWxscyA6L1xuXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGdsb2JhbEhpc3RvcnkucHVzaFN0YXRlKGhpc3RvcnlTdGF0ZSwgJycsIHVybCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBUaGV5IGFyZSBnb2luZyB0byBsb3NlIHN0YXRlIGhlcmUsIGJ1dCB0aGVyZSBpcyBubyByZWFsXG4gICAgICAgIC8vIHdheSB0byB3YXJuIHRoZW0gYWJvdXQgaXQgc2luY2UgdGhlIHBhZ2Ugd2lsbCByZWZyZXNoLi4uXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24odXJsKTtcbiAgICAgIH1cblxuICAgICAgYXBwbHlUeChuZXh0QWN0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XG4gICAgdmFyIG5leHRMb2NhdGlvbiA9IGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpO1xuXG4gICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICByZXBsYWNlKHRvLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhuZXh0TG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsIFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIGhhc2ggaGlzdG9yeS5yZXBsYWNlKFwiICsgSlNPTi5zdHJpbmdpZnkodG8pICsgXCIpXCIpIDogdm9pZCAwO1xuXG4gICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgIHZhciBfZ2V0SGlzdG9yeVN0YXRlQW5kVXI0ID0gZ2V0SGlzdG9yeVN0YXRlQW5kVXJsKG5leHRMb2NhdGlvbiwgaW5kZXgpLFxuICAgICAgICAgIGhpc3RvcnlTdGF0ZSA9IF9nZXRIaXN0b3J5U3RhdGVBbmRVcjRbMF0sXG4gICAgICAgICAgdXJsID0gX2dldEhpc3RvcnlTdGF0ZUFuZFVyNFsxXTsgLy8gVE9ETzogU3VwcG9ydCBmb3JjZWQgcmVsb2FkaW5nXG5cblxuICAgICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoaGlzdG9yeVN0YXRlLCAnJywgdXJsKTtcbiAgICAgIGFwcGx5VHgobmV4dEFjdGlvbik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ28oZGVsdGEpIHtcbiAgICBnbG9iYWxIaXN0b3J5LmdvKGRlbHRhKTtcbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGdldCBhY3Rpb24oKSB7XG4gICAgICByZXR1cm4gYWN0aW9uO1xuICAgIH0sXG5cbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gbG9jYXRpb247XG4gICAgfSxcblxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG4gICAgcHVzaDogcHVzaCxcbiAgICByZXBsYWNlOiByZXBsYWNlLFxuICAgIGdvOiBnbyxcbiAgICBiYWNrOiBmdW5jdGlvbiBiYWNrKCkge1xuICAgICAgZ28oLTEpO1xuICAgIH0sXG4gICAgZm9yd2FyZDogZnVuY3Rpb24gZm9yd2FyZCgpIHtcbiAgICAgIGdvKDEpO1xuICAgIH0sXG4gICAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfSxcbiAgICBibG9jazogZnVuY3Rpb24gYmxvY2soYmxvY2tlcikge1xuICAgICAgdmFyIHVuYmxvY2sgPSBibG9ja2Vycy5wdXNoKGJsb2NrZXIpO1xuXG4gICAgICBpZiAoYmxvY2tlcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKEJlZm9yZVVubG9hZEV2ZW50VHlwZSwgcHJvbXB0QmVmb3JlVW5sb2FkKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdW5ibG9jaygpOyAvLyBSZW1vdmUgdGhlIGJlZm9yZXVubG9hZCBsaXN0ZW5lciBzbyB0aGUgZG9jdW1lbnQgbWF5XG4gICAgICAgIC8vIHN0aWxsIGJlIHNhbHZhZ2VhYmxlIGluIHRoZSBwYWdlaGlkZSBldmVudC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI3VubG9hZGluZy1kb2N1bWVudHNcblxuICAgICAgICBpZiAoIWJsb2NrZXJzLmxlbmd0aCkge1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKEJlZm9yZVVubG9hZEV2ZW50VHlwZSwgcHJvbXB0QmVmb3JlVW5sb2FkKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuLyoqXHJcbiAqIE1lbW9yeSBoaXN0b3J5IHN0b3JlcyB0aGUgY3VycmVudCBsb2NhdGlvbiBpbiBtZW1vcnkuIEl0IGlzIGRlc2lnbmVkIGZvciB1c2VcclxuICogaW4gc3RhdGVmdWwgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIGxpa2UgdGVzdHMgYW5kIFJlYWN0IE5hdGl2ZS5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVtZW1vcnloaXN0b3J5XHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9uczMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMzJGluaXRpYWxFbnRyID0gX29wdGlvbnMzLmluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEVudHJpZXMgPSBfb3B0aW9uczMkaW5pdGlhbEVudHIgPT09IHZvaWQgMCA/IFsnLyddIDogX29wdGlvbnMzJGluaXRpYWxFbnRyLFxuICAgICAgaW5pdGlhbEluZGV4ID0gX29wdGlvbnMzLmluaXRpYWxJbmRleDtcbiAgdmFyIGVudHJpZXMgPSBpbml0aWFsRW50cmllcy5tYXAoZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgdmFyIGxvY2F0aW9uID0gcmVhZE9ubHkoX2V4dGVuZHMoe1xuICAgICAgcGF0aG5hbWU6ICcvJyxcbiAgICAgIHNlYXJjaDogJycsXG4gICAgICBoYXNoOiAnJyxcbiAgICAgIHN0YXRlOiBudWxsLFxuICAgICAga2V5OiBjcmVhdGVLZXkoKVxuICAgIH0sIHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycgPyBwYXJzZVBhdGgoZW50cnkpIDogZW50cnkpKTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nLCBcIlJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBjcmVhdGVNZW1vcnlIaXN0b3J5KHsgaW5pdGlhbEVudHJpZXMgfSkgKGludmFsaWQgZW50cnk6IFwiICsgSlNPTi5zdHJpbmdpZnkoZW50cnkpICsgXCIpXCIpIDogdm9pZCAwO1xuICAgIHJldHVybiBsb2NhdGlvbjtcbiAgfSk7XG4gIHZhciBpbmRleCA9IGNsYW1wKGluaXRpYWxJbmRleCA9PSBudWxsID8gZW50cmllcy5sZW5ndGggLSAxIDogaW5pdGlhbEluZGV4LCAwLCBlbnRyaWVzLmxlbmd0aCAtIDEpO1xuICB2YXIgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgdmFyIGxvY2F0aW9uID0gZW50cmllc1tpbmRleF07XG4gIHZhciBsaXN0ZW5lcnMgPSBjcmVhdGVFdmVudHMoKTtcbiAgdmFyIGJsb2NrZXJzID0gY3JlYXRlRXZlbnRzKCk7XG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZih0bykge1xuICAgIHJldHVybiB0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8gdG8gOiBjcmVhdGVQYXRoKHRvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkge1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZWFkT25seShfZXh0ZW5kcyh7XG4gICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICBzZWFyY2g6ICcnLFxuICAgICAgaGFzaDogJydcbiAgICB9LCB0eXBlb2YgdG8gPT09ICdzdHJpbmcnID8gcGFyc2VQYXRoKHRvKSA6IHRvLCB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBrZXk6IGNyZWF0ZUtleSgpXG4gICAgfSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWxsb3dUeChhY3Rpb24sIGxvY2F0aW9uLCByZXRyeSkge1xuICAgIHJldHVybiAhYmxvY2tlcnMubGVuZ3RoIHx8IChibG9ja2Vycy5jYWxsKHtcbiAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgcmV0cnk6IHJldHJ5XG4gICAgfSksIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uKSB7XG4gICAgYWN0aW9uID0gbmV4dEFjdGlvbjtcbiAgICBsb2NhdGlvbiA9IG5leHRMb2NhdGlvbjtcbiAgICBsaXN0ZW5lcnMuY2FsbCh7XG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaCh0bywgc3RhdGUpIHtcbiAgICB2YXIgbmV4dEFjdGlvbiA9IEFjdGlvbi5QdXNoO1xuICAgIHZhciBuZXh0TG9jYXRpb24gPSBnZXROZXh0TG9jYXRpb24odG8sIHN0YXRlKTtcblxuICAgIGZ1bmN0aW9uIHJldHJ5KCkge1xuICAgICAgcHVzaCh0bywgc3RhdGUpO1xuICAgIH1cblxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycsIFwiUmVsYXRpdmUgcGF0aG5hbWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIG1lbW9yeSBoaXN0b3J5LnB1c2goXCIgKyBKU09OLnN0cmluZ2lmeSh0bykgKyBcIilcIikgOiB2b2lkIDA7XG5cbiAgICBpZiAoYWxsb3dUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24sIHJldHJ5KSkge1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LCBlbnRyaWVzLmxlbmd0aCwgbmV4dExvY2F0aW9uKTtcbiAgICAgIGFwcGx5VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlJlcGxhY2U7XG4gICAgdmFyIG5leHRMb2NhdGlvbiA9IGdldE5leHRMb2NhdGlvbih0bywgc3RhdGUpO1xuXG4gICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICByZXBsYWNlKHRvLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJywgXCJSZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gbWVtb3J5IGhpc3RvcnkucmVwbGFjZShcIiArIEpTT04uc3RyaW5naWZ5KHRvKSArIFwiKVwiKSA6IHZvaWQgMDtcblxuICAgIGlmIChhbGxvd1R4KG5leHRBY3Rpb24sIG5leHRMb2NhdGlvbiwgcmV0cnkpKSB7XG4gICAgICBlbnRyaWVzW2luZGV4XSA9IG5leHRMb2NhdGlvbjtcbiAgICAgIGFwcGx5VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnbyhkZWx0YSkge1xuICAgIHZhciBuZXh0SW5kZXggPSBjbGFtcChpbmRleCArIGRlbHRhLCAwLCBlbnRyaWVzLmxlbmd0aCAtIDEpO1xuICAgIHZhciBuZXh0QWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICB2YXIgbmV4dExvY2F0aW9uID0gZW50cmllc1tuZXh0SW5kZXhdO1xuXG4gICAgZnVuY3Rpb24gcmV0cnkoKSB7XG4gICAgICBnbyhkZWx0YSk7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93VHgobmV4dEFjdGlvbiwgbmV4dExvY2F0aW9uLCByZXRyeSkpIHtcbiAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgYXBwbHlUeChuZXh0QWN0aW9uLCBuZXh0TG9jYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0ge1xuICAgIGdldCBpbmRleCgpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcblxuICAgIGdldCBsb2NhdGlvbigpIHtcbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9LFxuXG4gICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGJhY2s6IGZ1bmN0aW9uIGJhY2soKSB7XG4gICAgICBnbygtMSk7XG4gICAgfSxcbiAgICBmb3J3YXJkOiBmdW5jdGlvbiBmb3J3YXJkKCkge1xuICAgICAgZ28oMSk7XG4gICAgfSxcbiAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3RlbihsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9LFxuICAgIGJsb2NrOiBmdW5jdGlvbiBibG9jayhibG9ja2VyKSB7XG4gICAgICByZXR1cm4gYmxvY2tlcnMucHVzaChibG9ja2VyKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gVVRJTFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGNsYW1wKG4sIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpIHtcbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG4sIGxvd2VyQm91bmQpLCB1cHBlckJvdW5kKTtcbn1cblxuZnVuY3Rpb24gcHJvbXB0QmVmb3JlVW5sb2FkKGV2ZW50KSB7XG4gIC8vIENhbmNlbCB0aGUgZXZlbnQuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIENocm9tZSAoYW5kIGxlZ2FjeSBJRSkgcmVxdWlyZXMgcmV0dXJuVmFsdWUgdG8gYmUgc2V0LlxuXG4gIGV2ZW50LnJldHVyblZhbHVlID0gJyc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50cygpIHtcbiAgdmFyIGhhbmRsZXJzID0gW107XG4gIHJldHVybiB7XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgIHJldHVybiBoYW5kbGVycy5sZW5ndGg7XG4gICAgfSxcblxuICAgIHB1c2g6IGZ1bmN0aW9uIHB1c2goZm4pIHtcbiAgICAgIGhhbmRsZXJzLnB1c2goZm4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGFuZGxlcnMgPSBoYW5kbGVycy5maWx0ZXIoZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlciAhPT0gZm47XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LFxuICAgIGNhbGw6IGZ1bmN0aW9uIGNhbGwoYXJnKSB7XG4gICAgICBoYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4gJiYgZm4oYXJnKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDgpO1xufVxuLyoqXHJcbiAqIENyZWF0ZXMgYSBzdHJpbmcgVVJMIHBhdGggZnJvbSB0aGUgZ2l2ZW4gcGF0aG5hbWUsIHNlYXJjaCwgYW5kIGhhc2ggY29tcG9uZW50cy5cclxuICpcclxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL2hpc3RvcnkvdHJlZS9tYWluL2RvY3MvYXBpLXJlZmVyZW5jZS5tZCNjcmVhdGVwYXRoXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVBhdGgoX3JlZikge1xuICB2YXIgX3JlZiRwYXRobmFtZSA9IF9yZWYucGF0aG5hbWUsXG4gICAgICBwYXRobmFtZSA9IF9yZWYkcGF0aG5hbWUgPT09IHZvaWQgMCA/ICcvJyA6IF9yZWYkcGF0aG5hbWUsXG4gICAgICBfcmVmJHNlYXJjaCA9IF9yZWYuc2VhcmNoLFxuICAgICAgc2VhcmNoID0gX3JlZiRzZWFyY2ggPT09IHZvaWQgMCA/ICcnIDogX3JlZiRzZWFyY2gsXG4gICAgICBfcmVmJGhhc2ggPSBfcmVmLmhhc2gsXG4gICAgICBoYXNoID0gX3JlZiRoYXNoID09PSB2b2lkIDAgPyAnJyA6IF9yZWYkaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2ggIT09ICc/JykgcGF0aG5hbWUgKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gJz8nID8gc2VhcmNoIDogJz8nICsgc2VhcmNoO1xuICBpZiAoaGFzaCAmJiBoYXNoICE9PSAnIycpIHBhdGhuYW1lICs9IGhhc2guY2hhckF0KDApID09PSAnIycgPyBoYXNoIDogJyMnICsgaGFzaDtcbiAgcmV0dXJuIHBhdGhuYW1lO1xufVxuLyoqXHJcbiAqIFBhcnNlcyBhIHN0cmluZyBVUkwgcGF0aCBpbnRvIGl0cyBzZXBhcmF0ZSBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI3BhcnNlcGF0aFxyXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VQYXRoKHBhdGgpIHtcbiAgdmFyIHBhcnNlZFBhdGggPSB7fTtcblxuICBpZiAocGF0aCkge1xuICAgIHZhciBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoJyMnKTtcblxuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgcGFyc2VkUGF0aC5oYXNoID0gcGF0aC5zdWJzdHIoaGFzaEluZGV4KTtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cigwLCBoYXNoSW5kZXgpO1xuICAgIH1cblxuICAgIHZhciBzZWFyY2hJbmRleCA9IHBhdGguaW5kZXhPZignPycpO1xuXG4gICAgaWYgKHNlYXJjaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguc2VhcmNoID0gcGF0aC5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgICB9XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgcGFyc2VkUGF0aC5wYXRobmFtZSA9IHBhdGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnNlZFBhdGg7XG59XG5cbmV4cG9ydCB7IEFjdGlvbiwgY3JlYXRlQnJvd3Nlckhpc3RvcnksIGNyZWF0ZUhhc2hIaXN0b3J5LCBjcmVhdGVNZW1vcnlIaXN0b3J5LCBjcmVhdGVQYXRoLCBwYXJzZVBhdGggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIiwgImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59IiwgImltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHR5cGUge1xuICBIYXNoLFxuICBIaXN0b3J5LFxuICBJbml0aWFsRW50cnksXG4gIExvY2F0aW9uLFxuICBNZW1vcnlIaXN0b3J5LFxuICBQYXRoLFxuICBQYXRobmFtZSxcbiAgU2VhcmNoLFxuICBUbyxcbn0gZnJvbSBcImhpc3RvcnlcIjtcbmltcG9ydCB7XG4gIEFjdGlvbiBhcyBOYXZpZ2F0aW9uVHlwZSxcbiAgY3JlYXRlTWVtb3J5SGlzdG9yeSxcbiAgcGFyc2VQYXRoLFxuICBjcmVhdGVQYXRoLFxufSBmcm9tIFwiaGlzdG9yeVwiO1xuXG5leHBvcnQgeyBwYXJzZVBhdGgsIGNyZWF0ZVBhdGgsIE5hdmlnYXRpb25UeXBlIH07XG5leHBvcnQgdHlwZSB7IEhhc2gsIExvY2F0aW9uLCBQYXRoLCBQYXRobmFtZSwgU2VhcmNoLCBUbyB9O1xuXG5mdW5jdGlvbiBpbnZhcmlhbnQoY29uZDogYW55LCBtZXNzYWdlOiBzdHJpbmcpOiBhc3NlcnRzIGNvbmQge1xuICBpZiAoIWNvbmQpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbn1cblxuZnVuY3Rpb24gd2FybmluZyhjb25kOiBhbnksIG1lc3NhZ2U6IHN0cmluZyk6IHZvaWQge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IFJvdXRlciFcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuXG5jb25zdCBhbHJlYWR5V2FybmVkOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiA9IHt9O1xuZnVuY3Rpb24gd2FybmluZ09uY2Uoa2V5OiBzdHJpbmcsIGNvbmQ6IGJvb2xlYW4sIG1lc3NhZ2U6IHN0cmluZykge1xuICBpZiAoIWNvbmQgJiYgIWFscmVhZHlXYXJuZWRba2V5XSkge1xuICAgIGFscmVhZHlXYXJuZWRba2V5XSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgbWVzc2FnZSk7XG4gIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ09OVEVYVFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEEgTmF2aWdhdG9yIGlzIGEgXCJsb2NhdGlvbiBjaGFuZ2VyXCI7IGl0J3MgaG93IHlvdSBnZXQgdG8gZGlmZmVyZW50IGxvY2F0aW9ucy5cbiAqXG4gKiBFdmVyeSBoaXN0b3J5IGluc3RhbmNlIGNvbmZvcm1zIHRvIHRoZSBOYXZpZ2F0b3IgaW50ZXJmYWNlLCBidXQgdGhlXG4gKiBkaXN0aW5jdGlvbiBpcyB1c2VmdWwgcHJpbWFyaWx5IHdoZW4gaXQgY29tZXMgdG8gdGhlIGxvdy1sZXZlbCA8Um91dGVyPiBBUElcbiAqIHdoZXJlIGJvdGggdGhlIGxvY2F0aW9uIGFuZCBhIG5hdmlnYXRvciBtdXN0IGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgaW4gb3JkZXJcbiAqIHRvIGF2b2lkIFwidGVhcmluZ1wiIHRoYXQgbWF5IG9jY3VyIGluIGEgc3VzcGVuc2UtZW5hYmxlZCBhcHAgaWYgdGhlIGFjdGlvblxuICogYW5kL29yIGxvY2F0aW9uIHdlcmUgdG8gYmUgcmVhZCBkaXJlY3RseSBmcm9tIHRoZSBoaXN0b3J5IGluc3RhbmNlLlxuICovXG5leHBvcnQgdHlwZSBOYXZpZ2F0b3IgPSBQaWNrPEhpc3RvcnksIFwiZ29cIiB8IFwicHVzaFwiIHwgXCJyZXBsYWNlXCIgfCBcImNyZWF0ZUhyZWZcIj47XG5cbmludGVyZmFjZSBOYXZpZ2F0aW9uQ29udGV4dE9iamVjdCB7XG4gIGJhc2VuYW1lOiBzdHJpbmc7XG4gIG5hdmlnYXRvcjogTmF2aWdhdG9yO1xuICBzdGF0aWM6IGJvb2xlYW47XG59XG5cbmNvbnN0IE5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dDxOYXZpZ2F0aW9uQ29udGV4dE9iamVjdD4obnVsbCEpO1xuXG5pZiAoX19ERVZfXykge1xuICBOYXZpZ2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTmF2aWdhdGlvblwiO1xufVxuXG5pbnRlcmZhY2UgTG9jYXRpb25Db250ZXh0T2JqZWN0IHtcbiAgbG9jYXRpb246IExvY2F0aW9uO1xuICBuYXZpZ2F0aW9uVHlwZTogTmF2aWdhdGlvblR5cGU7XG59XG5cbmNvbnN0IExvY2F0aW9uQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8TG9jYXRpb25Db250ZXh0T2JqZWN0PihudWxsISk7XG5cbmlmIChfX0RFVl9fKSB7XG4gIExvY2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTG9jYXRpb25cIjtcbn1cblxuaW50ZXJmYWNlIFJvdXRlQ29udGV4dE9iamVjdCB7XG4gIG91dGxldDogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbDtcbiAgbWF0Y2hlczogUm91dGVNYXRjaFtdO1xufVxuXG5jb25zdCBSb3V0ZUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PFJvdXRlQ29udGV4dE9iamVjdD4oe1xuICBvdXRsZXQ6IG51bGwsXG4gIG1hdGNoZXM6IFtdLFxufSk7XG5cbmlmIChfX0RFVl9fKSB7XG4gIFJvdXRlQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVcIjtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ09NUE9ORU5UU1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgaW50ZXJmYWNlIE1lbW9yeVJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBpbml0aWFsRW50cmllcz86IEluaXRpYWxFbnRyeVtdO1xuICBpbml0aWFsSW5kZXg/OiBudW1iZXI7XG59XG5cbi8qKlxuICogQSA8Um91dGVyPiB0aGF0IHN0b3JlcyBhbGwgZW50cmllcyBpbiBtZW1vcnkuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNtZW1vcnlyb3V0ZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE1lbW9yeVJvdXRlcih7XG4gIGJhc2VuYW1lLFxuICBjaGlsZHJlbixcbiAgaW5pdGlhbEVudHJpZXMsXG4gIGluaXRpYWxJbmRleCxcbn06IE1lbW9yeVJvdXRlclByb3BzKTogUmVhY3QuUmVhY3RFbGVtZW50IHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8TWVtb3J5SGlzdG9yeT4oKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlTWVtb3J5SGlzdG9yeSh7IGluaXRpYWxFbnRyaWVzLCBpbml0aWFsSW5kZXggfSk7XG4gIH1cblxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVQcm9wcyB7XG4gIHRvOiBUbztcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xufVxuXG4vKipcbiAqIENoYW5nZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogTm90ZTogVGhpcyBBUEkgaXMgbW9zdGx5IHVzZWZ1bCBpbiBSZWFjdC5Db21wb25lbnQgc3ViY2xhc3NlcyB0aGF0IGFyZSBub3RcbiAqIGFibGUgdG8gdXNlIGhvb2tzLiBJbiBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIHdlIHJlY29tbWVuZCB5b3UgdXNlIHRoZVxuICogYHVzZU5hdmlnYXRlYCBob29rIGluc3RlYWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNuYXZpZ2F0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gTmF2aWdhdGUoeyB0bywgcmVwbGFjZSwgc3RhdGUgfTogTmF2aWdhdGVQcm9wcyk6IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2ZcbiAgICAvLyB0aGUgcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGA8TmF2aWdhdGU+IG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIHdhcm5pbmcoXG4gICAgIVJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpLnN0YXRpYyxcbiAgICBgPE5hdmlnYXRlPiBtdXN0IG5vdCBiZSB1c2VkIG9uIHRoZSBpbml0aWFsIHJlbmRlciBpbiBhIDxTdGF0aWNSb3V0ZXI+LiBgICtcbiAgICAgIGBUaGlzIGlzIGEgbm8tb3AsIGJ1dCB5b3Ugc2hvdWxkIG1vZGlmeSB5b3VyIGNvZGUgc28gdGhlIDxOYXZpZ2F0ZT4gaXMgYCArXG4gICAgICBgb25seSBldmVyIHJlbmRlcmVkIGluIHJlc3BvbnNlIHRvIHNvbWUgdXNlciBpbnRlcmFjdGlvbiBvciBzdGF0ZSBjaGFuZ2UuYFxuICApO1xuXG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbmF2aWdhdGUodG8sIHsgcmVwbGFjZSwgc3RhdGUgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE91dGxldFByb3BzIHtcbiAgY29udGV4dD86IHVua25vd247XG59XG5cbi8qKlxuICogUmVuZGVycyB0aGUgY2hpbGQgcm91dGUncyBlbGVtZW50LCBpZiB0aGVyZSBpcyBvbmUuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNvdXRsZXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE91dGxldChwcm9wczogT3V0bGV0UHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgcmV0dXJuIHVzZU91dGxldChwcm9wcy5jb250ZXh0KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb3V0ZVByb3BzIHtcbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgaW5kZXg/OiBib29sZWFuO1xuICBwYXRoPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBhdGhSb3V0ZVByb3BzIHtcbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBlbGVtZW50PzogUmVhY3QuUmVhY3ROb2RlIHwgbnVsbDtcbiAgaW5kZXg/OiBmYWxzZTtcbiAgcGF0aDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIExheW91dFJvdXRlUHJvcHMge1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5kZXhSb3V0ZVByb3BzIHtcbiAgZWxlbWVudD86IFJlYWN0LlJlYWN0Tm9kZSB8IG51bGw7XG4gIGluZGV4OiB0cnVlO1xufVxuXG4vKipcbiAqIERlY2xhcmVzIGFuIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQgYXQgYSBjZXJ0YWluIFVSTCBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcm91dGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFJvdXRlKFxuICBfcHJvcHM6IFBhdGhSb3V0ZVByb3BzIHwgTGF5b3V0Um91dGVQcm9wcyB8IEluZGV4Um91dGVQcm9wc1xuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICBmYWxzZSxcbiAgICBgQSA8Um91dGU+IGlzIG9ubHkgZXZlciB0byBiZSB1c2VkIGFzIHRoZSBjaGlsZCBvZiA8Um91dGVzPiBlbGVtZW50LCBgICtcbiAgICAgIGBuZXZlciByZW5kZXJlZCBkaXJlY3RseS4gUGxlYXNlIHdyYXAgeW91ciA8Um91dGU+IGluIGEgPFJvdXRlcz4uYFxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvdXRlclByb3BzIHtcbiAgYmFzZW5hbWU/OiBzdHJpbmc7XG4gIGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlO1xuICBsb2NhdGlvbjogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmc7XG4gIG5hdmlnYXRpb25UeXBlPzogTmF2aWdhdGlvblR5cGU7XG4gIG5hdmlnYXRvcjogTmF2aWdhdG9yO1xuICBzdGF0aWM/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFByb3ZpZGVzIGxvY2F0aW9uIGNvbnRleHQgZm9yIHRoZSByZXN0IG9mIHRoZSBhcHAuXG4gKlxuICogTm90ZTogWW91IHVzdWFsbHkgd29uJ3QgcmVuZGVyIGEgPFJvdXRlcj4gZGlyZWN0bHkuIEluc3RlYWQsIHlvdSdsbCByZW5kZXIgYVxuICogcm91dGVyIHRoYXQgaXMgbW9yZSBzcGVjaWZpYyB0byB5b3VyIGVudmlyb25tZW50IHN1Y2ggYXMgYSA8QnJvd3NlclJvdXRlcj5cbiAqIGluIHdlYiBicm93c2VycyBvciBhIDxTdGF0aWNSb3V0ZXI+IGZvciBzZXJ2ZXIgcmVuZGVyaW5nLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcm91dGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBSb3V0ZXIoe1xuICBiYXNlbmFtZTogYmFzZW5hbWVQcm9wID0gXCIvXCIsXG4gIGNoaWxkcmVuID0gbnVsbCxcbiAgbG9jYXRpb246IGxvY2F0aW9uUHJvcCxcbiAgbmF2aWdhdGlvblR5cGUgPSBOYXZpZ2F0aW9uVHlwZS5Qb3AsXG4gIG5hdmlnYXRvcixcbiAgc3RhdGljOiBzdGF0aWNQcm9wID0gZmFsc2UsXG59OiBSb3V0ZXJQcm9wcyk6IFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwge1xuICBpbnZhcmlhbnQoXG4gICAgIXVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIGBZb3UgY2Fubm90IHJlbmRlciBhIDxSb3V0ZXI+IGluc2lkZSBhbm90aGVyIDxSb3V0ZXI+LmAgK1xuICAgICAgYCBZb3Ugc2hvdWxkIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBpbiB5b3VyIGFwcC5gXG4gICk7XG5cbiAgbGV0IGJhc2VuYW1lID0gbm9ybWFsaXplUGF0aG5hbWUoYmFzZW5hbWVQcm9wKTtcbiAgbGV0IG5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiAoeyBiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWM6IHN0YXRpY1Byb3AgfSksXG4gICAgW2Jhc2VuYW1lLCBuYXZpZ2F0b3IsIHN0YXRpY1Byb3BdXG4gICk7XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvblByb3AgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsb2NhdGlvblByb3AgPSBwYXJzZVBhdGgobG9jYXRpb25Qcm9wKTtcbiAgfVxuXG4gIGxldCB7XG4gICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICAgIHN0YXRlID0gbnVsbCxcbiAgICBrZXkgPSBcImRlZmF1bHRcIixcbiAgfSA9IGxvY2F0aW9uUHJvcDtcblxuICBsZXQgbG9jYXRpb24gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKTtcblxuICAgIGlmICh0cmFpbGluZ1BhdGhuYW1lID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXRobmFtZTogdHJhaWxpbmdQYXRobmFtZSxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhhc2gsXG4gICAgICBzdGF0ZSxcbiAgICAgIGtleSxcbiAgICB9O1xuICB9LCBbYmFzZW5hbWUsIHBhdGhuYW1lLCBzZWFyY2gsIGhhc2gsIHN0YXRlLCBrZXldKTtcblxuICB3YXJuaW5nKFxuICAgIGxvY2F0aW9uICE9IG51bGwsXG4gICAgYDxSb3V0ZXIgYmFzZW5hbWU9XCIke2Jhc2VuYW1lfVwiPiBpcyBub3QgYWJsZSB0byBtYXRjaCB0aGUgVVJMIGAgK1xuICAgICAgYFwiJHtwYXRobmFtZX0ke3NlYXJjaH0ke2hhc2h9XCIgYmVjYXVzZSBpdCBkb2VzIG5vdCBzdGFydCB3aXRoIHRoZSBgICtcbiAgICAgIGBiYXNlbmFtZSwgc28gdGhlIDxSb3V0ZXI+IHdvbid0IHJlbmRlciBhbnl0aGluZy5gXG4gICk7XG5cbiAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAoXG4gICAgPE5hdmlnYXRpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXtuYXZpZ2F0aW9uQ29udGV4dH0+XG4gICAgICA8TG9jYXRpb25Db250ZXh0LlByb3ZpZGVyXG4gICAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgICAgdmFsdWU9e3sgbG9jYXRpb24sIG5hdmlnYXRpb25UeXBlIH19XG4gICAgICAvPlxuICAgIDwvTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVzUHJvcHMge1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgbG9jYXRpb24/OiBQYXJ0aWFsPExvY2F0aW9uPiB8IHN0cmluZztcbn1cblxuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYSBuZXN0ZWQgdHJlZSBvZiA8Um91dGU+IGVsZW1lbnRzIHRoYXQgcmVuZGVycyB0aGUgYnJhbmNoXG4gKiB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3JvdXRlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gUm91dGVzKHtcbiAgY2hpbGRyZW4sXG4gIGxvY2F0aW9uLFxufTogUm91dGVzUHJvcHMpOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgcmV0dXJuIHVzZVJvdXRlcyhjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4pLCBsb2NhdGlvbik7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEhPT0tTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnVsbCBocmVmIGZvciB0aGUgZ2l2ZW4gXCJ0b1wiIHZhbHVlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYnVpbGRpbmdcbiAqIGN1c3RvbSBsaW5rcyB0aGF0IGFyZSBhbHNvIGFjY2Vzc2libGUgYW5kIHByZXNlcnZlIHJpZ2h0LWNsaWNrIGJlaGF2aW9yLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlaHJlZlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSHJlZih0bzogVG8pOiBzdHJpbmcge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgYmFzZW5hbWUsIG5hdmlnYXRvciB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7IGhhc2gsIHBhdGhuYW1lLCBzZWFyY2ggfSA9IHVzZVJlc29sdmVkUGF0aCh0byk7XG5cbiAgbGV0IGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWU7XG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBsZXQgdG9QYXRobmFtZSA9IGdldFRvUGF0aG5hbWUodG8pO1xuICAgIGxldCBlbmRzV2l0aFNsYXNoID0gdG9QYXRobmFtZSAhPSBudWxsICYmIHRvUGF0aG5hbWUuZW5kc1dpdGgoXCIvXCIpO1xuICAgIGpvaW5lZFBhdGhuYW1lID1cbiAgICAgIHBhdGhuYW1lID09PSBcIi9cIlxuICAgICAgICA/IGJhc2VuYW1lICsgKGVuZHNXaXRoU2xhc2ggPyBcIi9cIiA6IFwiXCIpXG4gICAgICAgIDogam9pblBhdGhzKFtiYXNlbmFtZSwgcGF0aG5hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IuY3JlYXRlSHJlZih7IHBhdGhuYW1lOiBqb2luZWRQYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbXBvbmVudCBpcyBhIGRlc2NlbmRhbnQgb2YgYSA8Um91dGVyPi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZWlucm91dGVyY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW5Sb3V0ZXJDb250ZXh0KCk6IGJvb2xlYW4ge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpICE9IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsb2NhdGlvbiBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgVVJMIGluIHdlYlxuICogYnJvd3NlcnMuXG4gKlxuICogTm90ZTogSWYgeW91J3JlIHVzaW5nIHRoaXMgaXQgbWF5IG1lYW4geW91J3JlIGRvaW5nIHNvbWUgb2YgeW91ciBvd25cbiAqIFwicm91dGluZ1wiIGluIHlvdXIgYXBwLCBhbmQgd2UnZCBsaWtlIHRvIGtub3cgd2hhdCB5b3VyIHVzZSBjYXNlIGlzLiBXZSBtYXlcbiAqIGJlIGFibGUgdG8gcHJvdmlkZSBzb21ldGhpbmcgaGlnaGVyLWxldmVsIHRvIGJldHRlciBzdWl0IHlvdXIgbmVlZHMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2Vsb2NhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYXRpb24oKTogTG9jYXRpb24ge1xuICBpbnZhcmlhbnQoXG4gICAgdXNlSW5Sb3V0ZXJDb250ZXh0KCksXG4gICAgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gICAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICAgIGB1c2VMb2NhdGlvbigpIG1heSBiZSB1c2VkIG9ubHkgaW4gdGhlIGNvbnRleHQgb2YgYSA8Um91dGVyPiBjb21wb25lbnQuYFxuICApO1xuXG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubG9jYXRpb247XG59XG5cbnR5cGUgUGFyYW1QYXJzZUZhaWxlZCA9IHsgZmFpbGVkOiB0cnVlIH07XG5cbnR5cGUgUGFyYW1QYXJzZVNlZ21lbnQ8U2VnbWVudCBleHRlbmRzIHN0cmluZz4gPVxuICAvLyBDaGVjayBoZXJlIGlmIHRoZXJlIGV4aXN0cyBhIGZvcndhcmQgc2xhc2ggaW4gdGhlIHN0cmluZy5cbiAgU2VnbWVudCBleHRlbmRzIGAke2luZmVyIExlZnRTZWdtZW50fS8ke2luZmVyIFJpZ2h0U2VnbWVudH1gXG4gICAgPyAvLyBJZiB0aGVyZSBpcyBhIGZvcndhcmQgc2xhc2gsIHRoZW4gYXR0ZW1wdCB0byBwYXJzZSBlYWNoIHNpZGUgb2YgdGhlXG4gICAgICAvLyBmb3J3YXJkIHNsYXNoLlxuICAgICAgUGFyYW1QYXJzZVNlZ21lbnQ8TGVmdFNlZ21lbnQ+IGV4dGVuZHMgaW5mZXIgTGVmdFJlc3VsdFxuICAgICAgPyBQYXJhbVBhcnNlU2VnbWVudDxSaWdodFNlZ21lbnQ+IGV4dGVuZHMgaW5mZXIgUmlnaHRSZXN1bHRcbiAgICAgICAgPyBMZWZ0UmVzdWx0IGV4dGVuZHMgc3RyaW5nXG4gICAgICAgICAgPyAvLyBJZiB0aGUgbGVmdCBzaWRlIGlzIHN1Y2Nlc3NmdWxseSBwYXJzZWQgYXMgYSBwYXJhbSwgdGhlbiBjaGVjayBpZlxuICAgICAgICAgICAgLy8gdGhlIHJpZ2h0IHNpZGUgY2FuIGJlIHN1Y2Nlc3NmdWxseSBwYXJzZWQgYXMgd2VsbC4gSWYgYm90aCBzaWRlc1xuICAgICAgICAgICAgLy8gY2FuIGJlIHBhcnNlZCwgdGhlbiB0aGUgcmVzdWx0IGlzIGEgdW5pb24gb2YgdGhlIHR3byBzaWRlc1xuICAgICAgICAgICAgLy8gKHJlYWQ6IFwiZm9vXCIgfCBcImJhclwiKS5cbiAgICAgICAgICAgIFJpZ2h0UmVzdWx0IGV4dGVuZHMgc3RyaW5nXG4gICAgICAgICAgICA/IExlZnRSZXN1bHQgfCBSaWdodFJlc3VsdFxuICAgICAgICAgICAgOiBMZWZ0UmVzdWx0XG4gICAgICAgICAgOiAvLyBJZiB0aGUgbGVmdCBzaWRlIGlzIG5vdCBzdWNjZXNzZnVsbHkgcGFyc2VkIGFzIGEgcGFyYW0sIHRoZW4gY2hlY2tcbiAgICAgICAgICAvLyBpZiBvbmx5IHRoZSByaWdodCBzaWRlIGNhbiBiZSBzdWNjZXNzZnVsbHkgcGFyc2UgYXMgYSBwYXJhbS4gSWYgaXRcbiAgICAgICAgICAvLyBjYW4sIHRoZW4gdGhlIHJlc3VsdCBpcyBqdXN0IHJpZ2h0LCBlbHNlIGl0J3MgYSBmYWlsdXJlLlxuICAgICAgICAgIFJpZ2h0UmVzdWx0IGV4dGVuZHMgc3RyaW5nXG4gICAgICAgICAgPyBSaWdodFJlc3VsdFxuICAgICAgICAgIDogUGFyYW1QYXJzZUZhaWxlZFxuICAgICAgICA6IFBhcmFtUGFyc2VGYWlsZWRcbiAgICAgIDogLy8gSWYgdGhlIGxlZnQgc2lkZSBkaWRuJ3QgcGFyc2UgaW50byBhIHBhcmFtLCB0aGVuIGp1c3QgY2hlY2sgdGhlIHJpZ2h0XG4gICAgICAvLyBzaWRlLlxuICAgICAgUGFyYW1QYXJzZVNlZ21lbnQ8UmlnaHRTZWdtZW50PiBleHRlbmRzIGluZmVyIFJpZ2h0UmVzdWx0XG4gICAgICA/IFJpZ2h0UmVzdWx0IGV4dGVuZHMgc3RyaW5nXG4gICAgICAgID8gUmlnaHRSZXN1bHRcbiAgICAgICAgOiBQYXJhbVBhcnNlRmFpbGVkXG4gICAgICA6IFBhcmFtUGFyc2VGYWlsZWRcbiAgICA6IC8vIElmIHRoZXJlJ3Mgbm8gZm9yd2FyZCBzbGFzaCwgdGhlbiBjaGVjayBpZiB0aGlzIHNlZ21lbnQgc3RhcnRzIHdpdGggYVxuICAgIC8vIGNvbG9uLiBJZiBpdCBkb2VzLCB0aGVuIHRoaXMgaXMgYSBkeW5hbWljIHNlZ21lbnQsIHNvIHRoZSByZXN1bHQgaXNcbiAgICAvLyBqdXN0IHRoZSByZW1haW5kZXIgb2YgdGhlIHN0cmluZy4gT3RoZXJ3aXNlLCBpdCdzIGEgZmFpbHVyZS5cbiAgICBTZWdtZW50IGV4dGVuZHMgYDoke2luZmVyIFJlbWFpbmluZ31gXG4gICAgPyBSZW1haW5pbmdcbiAgICA6IFBhcmFtUGFyc2VGYWlsZWQ7XG5cbi8vIEF0dGVtcHQgdG8gcGFyc2UgdGhlIGdpdmVuIHN0cmluZyBzZWdtZW50LiBJZiBpdCBmYWlscywgdGhlbiBqdXN0IHJldHVybiB0aGVcbi8vIHBsYWluIHN0cmluZyB0eXBlIGFzIGEgZGVmYXVsdCBmYWxsYmFjay4gT3RoZXJ3aXNlIHJldHVybiB0aGUgdW5pb24gb2YgdGhlXG4vLyBwYXJzZWQgc3RyaW5nIGxpdGVyYWxzIHRoYXQgd2VyZSByZWZlcmVuY2VkIGFzIGR5bmFtaWMgc2VnbWVudHMgaW4gdGhlIHJvdXRlLlxudHlwZSBQYXJhbVBhcnNlS2V5PFNlZ21lbnQgZXh0ZW5kcyBzdHJpbmc+ID1cbiAgUGFyYW1QYXJzZVNlZ21lbnQ8U2VnbWVudD4gZXh0ZW5kcyBzdHJpbmdcbiAgICA/IFBhcmFtUGFyc2VTZWdtZW50PFNlZ21lbnQ+XG4gICAgOiBzdHJpbmc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGFjdGlvbiB3aGljaCBkZXNjcmliZXMgaG93IHRoZSByb3V0ZXIgY2FtZSB0b1xuICogdGhlIGN1cnJlbnQgbG9jYXRpb24sIGVpdGhlciBieSBhIHBvcCwgcHVzaCwgb3IgcmVwbGFjZSBvbiB0aGUgaGlzdG9yeSBzdGFjay5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW5hdmlnYXRpb250eXBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZpZ2F0aW9uVHlwZSgpOiBOYXZpZ2F0aW9uVHlwZSB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KExvY2F0aW9uQ29udGV4dCkubmF2aWdhdGlvblR5cGU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBVUkwgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUgbWF0Y2hlcyB0aGUgY3VycmVudCBVUkwuXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgY29tcG9uZW50cyB0aGF0IG5lZWQgdG8ga25vdyBcImFjdGl2ZVwiIHN0YXRlLCBlLmcuXG4gKiA8TmF2TGluaz4uXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2VtYXRjaFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWF0Y2g8XG4gIFBhcmFtS2V5IGV4dGVuZHMgUGFyYW1QYXJzZUtleTxQYXRoPixcbiAgUGF0aCBleHRlbmRzIHN0cmluZ1xuPihwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgpOiBQYXRoTWF0Y2g8UGFyYW1LZXk+IHwgbnVsbCB7XG4gIGludmFyaWFudChcbiAgICB1c2VJblJvdXRlckNvbnRleHQoKSxcbiAgICAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gICAgYHVzZU1hdGNoKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgcGF0aG5hbWUgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIHJldHVybiBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+IG1hdGNoUGF0aDxQYXJhbUtleSwgUGF0aD4ocGF0dGVybiwgcGF0aG5hbWUpLFxuICAgIFtwYXRobmFtZSwgcGF0dGVybl1cbiAgKTtcbn1cblxuLyoqXG4gKiBUaGUgaW50ZXJmYWNlIGZvciB0aGUgbmF2aWdhdGUoKSBmdW5jdGlvbiByZXR1cm5lZCBmcm9tIHVzZU5hdmlnYXRlKCkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVGdW5jdGlvbiB7XG4gICh0bzogVG8sIG9wdGlvbnM/OiBOYXZpZ2F0ZU9wdGlvbnMpOiB2b2lkO1xuICAoZGVsdGE6IG51bWJlcik6IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2aWdhdGVPcHRpb25zIHtcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gaW1wZXJhdGl2ZSBtZXRob2QgZm9yIGNoYW5naW5nIHRoZSBsb2NhdGlvbi4gVXNlZCBieSA8TGluaz5zLCBidXRcbiAqIG1heSBhbHNvIGJlIHVzZWQgYnkgb3RoZXIgZWxlbWVudHMgdG8gY2hhbmdlIHRoZSBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZW5hdmlnYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VOYXZpZ2F0ZSgpOiBOYXZpZ2F0ZUZ1bmN0aW9uIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlTmF2aWdhdGUoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LmBcbiAgKTtcblxuICBsZXQgeyBiYXNlbmFtZSwgbmF2aWdhdG9yIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHsgbWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgeyBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZSB9ID0gdXNlTG9jYXRpb24oKTtcblxuICBsZXQgcm91dGVQYXRobmFtZXNKc29uID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PiBtYXRjaC5wYXRobmFtZUJhc2UpXG4gICk7XG5cbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcblxuICBsZXQgbmF2aWdhdGU6IE5hdmlnYXRlRnVuY3Rpb24gPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAodG86IFRvIHwgbnVtYmVyLCBvcHRpb25zOiBOYXZpZ2F0ZU9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgd2FybmluZyhcbiAgICAgICAgYWN0aXZlUmVmLmN1cnJlbnQsXG4gICAgICAgIGBZb3Ugc2hvdWxkIGNhbGwgbmF2aWdhdGUoKSBpbiBhIFJlYWN0LnVzZUVmZmVjdCgpLCBub3Qgd2hlbiBgICtcbiAgICAgICAgICBgeW91ciBjb21wb25lbnQgaXMgZmlyc3QgcmVuZGVyZWQuYFxuICAgICAgKTtcblxuICAgICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIG5hdmlnYXRvci5nbyh0byk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IHBhdGggPSByZXNvbHZlVG8oXG4gICAgICAgIHRvLFxuICAgICAgICBKU09OLnBhcnNlKHJvdXRlUGF0aG5hbWVzSnNvbiksXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWVcbiAgICAgICk7XG5cbiAgICAgIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICAgICAgcGF0aC5wYXRobmFtZSA9IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgICAgIH1cblxuICAgICAgKCEhb3B0aW9ucy5yZXBsYWNlID8gbmF2aWdhdG9yLnJlcGxhY2UgOiBuYXZpZ2F0b3IucHVzaCkoXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9wdGlvbnMuc3RhdGVcbiAgICAgICk7XG4gICAgfSxcbiAgICBbYmFzZW5hbWUsIG5hdmlnYXRvciwgcm91dGVQYXRobmFtZXNKc29uLCBsb2NhdGlvblBhdGhuYW1lXVxuICApO1xuXG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cblxuY29uc3QgT3V0bGV0Q29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQ8dW5rbm93bj4obnVsbCk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29udGV4dCAoaWYgcHJvdmlkZWQpIGZvciB0aGUgY2hpbGQgcm91dGUgYXQgdGhpcyBsZXZlbCBvZiB0aGUgcm91dGVcbiAqIGhpZXJhcmNoeS5cbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlb3V0bGV0Y29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlT3V0bGV0Q29udGV4dDxDb250ZXh0ID0gdW5rbm93bj4oKTogQ29udGV4dCB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KE91dGxldENvbnRleHQpIGFzIENvbnRleHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBmb3IgdGhlIGNoaWxkIHJvdXRlIGF0IHRoaXMgbGV2ZWwgb2YgdGhlIHJvdXRlXG4gKiBoaWVyYXJjaHkuIFVzZWQgaW50ZXJuYWxseSBieSA8T3V0bGV0PiB0byByZW5kZXIgY2hpbGQgcm91dGVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjdXNlb3V0bGV0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPdXRsZXQoY29udGV4dD86IHVua25vd24pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgbGV0IG91dGxldCA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KS5vdXRsZXQ7XG4gIGlmIChvdXRsZXQpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPE91dGxldENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHR9PntvdXRsZXR9PC9PdXRsZXRDb250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG91dGxldDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMgb2YgdGhlIGR5bmFtaWMgcGFyYW1zIGZyb20gdGhlIGN1cnJlbnRcbiAqIFVSTCB0aGF0IHdlcmUgbWF0Y2hlZCBieSB0aGUgcm91dGUgcGF0aC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZXBhcmFtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFyYW1zPFxuICBQYXJhbXNPcktleSBleHRlbmRzIHN0cmluZyB8IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSBzdHJpbmdcbj4oKTogUmVhZG9ubHk8XG4gIFtQYXJhbXNPcktleV0gZXh0ZW5kcyBbc3RyaW5nXSA/IFBhcmFtczxQYXJhbXNPcktleT4gOiBQYXJ0aWFsPFBhcmFtc09yS2V5PlxuPiB7XG4gIGxldCB7IG1hdGNoZXMgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHJvdXRlTWF0Y2ggPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV07XG4gIHJldHVybiByb3V0ZU1hdGNoID8gKHJvdXRlTWF0Y2gucGFyYW1zIGFzIGFueSkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyB0aGUgcGF0aG5hbWUgb2YgdGhlIGdpdmVuIGB0b2AgdmFsdWUgYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI3VzZXJlc29sdmVkcGF0aFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVzb2x2ZWRQYXRoKHRvOiBUbyk6IFBhdGgge1xuICBsZXQgeyBtYXRjaGVzIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7IHBhdGhuYW1lOiBsb2NhdGlvblBhdGhuYW1lIH0gPSB1c2VMb2NhdGlvbigpO1xuXG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShcbiAgICBtYXRjaGVzLm1hcCgobWF0Y2gpID0+IG1hdGNoLnBhdGhuYW1lQmFzZSlcbiAgKTtcblxuICByZXR1cm4gUmVhY3QudXNlTWVtbyhcbiAgICAoKSA9PiByZXNvbHZlVG8odG8sIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSwgbG9jYXRpb25QYXRobmFtZSksXG4gICAgW3RvLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWVdXG4gICk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgcm91dGUgdGhhdCBtYXRjaGVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBwcmVwYXJlZFxuICogd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0IHRvIHJlbmRlciB0aGUgcmVtYWluZGVyIG9mIHRoZSByb3V0ZSB0cmVlLiBSb3V0ZVxuICogZWxlbWVudHMgaW4gdGhlIHRyZWUgbXVzdCByZW5kZXIgYW4gPE91dGxldD4gdG8gcmVuZGVyIHRoZWlyIGNoaWxkIHJvdXRlJ3NcbiAqIGVsZW1lbnQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSN1c2Vyb3V0ZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdXRlcyhcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBsb2NhdGlvbkFyZz86IFBhcnRpYWw8TG9jYXRpb24+IHwgc3RyaW5nXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaW52YXJpYW50KFxuICAgIHVzZUluUm91dGVyQ29udGV4dCgpLFxuICAgIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAgIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgICBgdXNlUm91dGVzKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5gXG4gICk7XG5cbiAgbGV0IHsgbWF0Y2hlczogcGFyZW50TWF0Y2hlcyB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IHBhcmVudE1hdGNoZXNbcGFyZW50TWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgbGV0IHBhcmVudFBhcmFtcyA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xuICBsZXQgcGFyZW50UGF0aG5hbWUgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50UGF0aG5hbWVCYXNlID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWVCYXNlIDogXCIvXCI7XG4gIGxldCBwYXJlbnRSb3V0ZSA9IHJvdXRlTWF0Y2ggJiYgcm91dGVNYXRjaC5yb3V0ZTtcblxuICBpZiAoX19ERVZfXykge1xuICAgIC8vIFlvdSB3b24ndCBnZXQgYSB3YXJuaW5nIGFib3V0IDIgZGlmZmVyZW50IDxSb3V0ZXM+IHVuZGVyIGEgPFJvdXRlPlxuICAgIC8vIHdpdGhvdXQgYSB0cmFpbGluZyAqLCBidXQgdGhpcyBpcyBhIGJlc3QtZWZmb3J0IHdhcm5pbmcgYW55d2F5IHNpbmNlIHdlXG4gICAgLy8gY2Fubm90IGV2ZW4gZ2l2ZSB0aGUgd2FybmluZyB1bmxlc3MgdGhleSBsYW5kIGF0IHRoZSBwYXJlbnQgcm91dGUuXG4gICAgLy9cbiAgICAvLyBFeGFtcGxlOlxuICAgIC8vXG4gICAgLy8gPFJvdXRlcz5cbiAgICAvLyAgIHsvKiBUaGlzIHJvdXRlIHBhdGggTVVTVCBlbmQgd2l0aCAvKiBiZWNhdXNlIG90aGVyd2lzZVxuICAgIC8vICAgICAgIGl0IHdpbGwgbmV2ZXIgbWF0Y2ggL2Jsb2cvcG9zdC8xMjMgKi99XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2dcIiBlbGVtZW50PXs8QmxvZyAvPn0gLz5cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZy9mZWVkXCIgZWxlbWVudD17PEJsb2dGZWVkIC8+fSAvPlxuICAgIC8vIDwvUm91dGVzPlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gQmxvZygpIHtcbiAgICAvLyAgIHJldHVybiAoXG4gICAgLy8gICAgIDxSb3V0ZXM+XG4gICAgLy8gICAgICAgPFJvdXRlIHBhdGg9XCJwb3N0LzppZFwiIGVsZW1lbnQ9ezxQb3N0IC8+fSAvPlxuICAgIC8vICAgICA8L1JvdXRlcz5cbiAgICAvLyAgICk7XG4gICAgLy8gfVxuICAgIGxldCBwYXJlbnRQYXRoID0gKHBhcmVudFJvdXRlICYmIHBhcmVudFJvdXRlLnBhdGgpIHx8IFwiXCI7XG4gICAgd2FybmluZ09uY2UoXG4gICAgICBwYXJlbnRQYXRobmFtZSxcbiAgICAgICFwYXJlbnRSb3V0ZSB8fCBwYXJlbnRQYXRoLmVuZHNXaXRoKFwiKlwiKSxcbiAgICAgIGBZb3UgcmVuZGVyZWQgZGVzY2VuZGFudCA8Um91dGVzPiAob3IgY2FsbGVkIFxcYHVzZVJvdXRlcygpXFxgKSBhdCBgICtcbiAgICAgICAgYFwiJHtwYXJlbnRQYXRobmFtZX1cIiAodW5kZXIgPFJvdXRlIHBhdGg9XCIke3BhcmVudFBhdGh9XCI+KSBidXQgdGhlIGAgK1xuICAgICAgICBgcGFyZW50IHJvdXRlIHBhdGggaGFzIG5vIHRyYWlsaW5nIFwiKlwiLiBUaGlzIG1lYW5zIGlmIHlvdSBuYXZpZ2F0ZSBgICtcbiAgICAgICAgYGRlZXBlciwgdGhlIHBhcmVudCB3b24ndCBtYXRjaCBhbnltb3JlIGFuZCB0aGVyZWZvcmUgdGhlIGNoaWxkIGAgK1xuICAgICAgICBgcm91dGVzIHdpbGwgbmV2ZXIgcmVuZGVyLlxcblxcbmAgK1xuICAgICAgICBgUGxlYXNlIGNoYW5nZSB0aGUgcGFyZW50IDxSb3V0ZSBwYXRoPVwiJHtwYXJlbnRQYXRofVwiPiB0byA8Um91dGUgYCArXG4gICAgICAgIGBwYXRoPVwiJHtwYXJlbnRQYXRoID09PSBcIi9cIiA/IFwiKlwiIDogYCR7cGFyZW50UGF0aH0vKmB9XCI+LmBcbiAgICApO1xuICB9XG5cbiAgbGV0IGxvY2F0aW9uRnJvbUNvbnRleHQgPSB1c2VMb2NhdGlvbigpO1xuXG4gIGxldCBsb2NhdGlvbjtcbiAgaWYgKGxvY2F0aW9uQXJnKSB7XG4gICAgbGV0IHBhcnNlZExvY2F0aW9uQXJnID1cbiAgICAgIHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcblxuICAgIGludmFyaWFudChcbiAgICAgIHBhcmVudFBhdGhuYW1lQmFzZSA9PT0gXCIvXCIgfHxcbiAgICAgICAgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWU/LnN0YXJ0c1dpdGgocGFyZW50UGF0aG5hbWVCYXNlKSxcbiAgICAgIGBXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIFxcYDxSb3V0ZXMgbG9jYXRpb24+XFxgIG9yIFxcYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKVxcYCwgYCArXG4gICAgICAgIGB0aGUgbG9jYXRpb24gcGF0aG5hbWUgbXVzdCBiZWdpbiB3aXRoIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgYCArXG4gICAgICAgIGBtYXRjaGVkIGJ5IGFsbCBwYXJlbnQgcm91dGVzLiBUaGUgY3VycmVudCBwYXRobmFtZSBiYXNlIGlzIFwiJHtwYXJlbnRQYXRobmFtZUJhc2V9XCIgYCArXG4gICAgICAgIGBidXQgcGF0aG5hbWUgXCIke3BhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lfVwiIHdhcyBnaXZlbiBpbiB0aGUgXFxgbG9jYXRpb25cXGAgcHJvcC5gXG4gICAgKTtcblxuICAgIGxvY2F0aW9uID0gcGFyc2VkTG9jYXRpb25Bcmc7XG4gIH0gZWxzZSB7XG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbkZyb21Db250ZXh0O1xuICB9XG5cbiAgbGV0IHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUgfHwgXCIvXCI7XG4gIGxldCByZW1haW5pbmdQYXRobmFtZSA9XG4gICAgcGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIlxuICAgICAgPyBwYXRobmFtZVxuICAgICAgOiBwYXRobmFtZS5zbGljZShwYXJlbnRQYXRobmFtZUJhc2UubGVuZ3RoKSB8fCBcIi9cIjtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHsgcGF0aG5hbWU6IHJlbWFpbmluZ1BhdGhuYW1lIH0pO1xuXG4gIGlmIChfX0RFVl9fKSB7XG4gICAgd2FybmluZyhcbiAgICAgIHBhcmVudFJvdXRlIHx8IG1hdGNoZXMgIT0gbnVsbCxcbiAgICAgIGBObyByb3V0ZXMgbWF0Y2hlZCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGBcbiAgICApO1xuXG4gICAgd2FybmluZyhcbiAgICAgIG1hdGNoZXMgPT0gbnVsbCB8fFxuICAgICAgICBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuZWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuICAgICAgYE1hdGNoZWQgbGVhZiByb3V0ZSBhdCBsb2NhdGlvbiBcIiR7bG9jYXRpb24ucGF0aG5hbWV9JHtsb2NhdGlvbi5zZWFyY2h9JHtsb2NhdGlvbi5oYXNofVwiIGRvZXMgbm90IGhhdmUgYW4gZWxlbWVudC4gYCArXG4gICAgICAgIGBUaGlzIG1lYW5zIGl0IHdpbGwgcmVuZGVyIGFuIDxPdXRsZXQgLz4gd2l0aCBhIG51bGwgdmFsdWUgYnkgZGVmYXVsdCByZXN1bHRpbmcgaW4gYW4gXCJlbXB0eVwiIHBhZ2UuYFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gX3JlbmRlck1hdGNoZXMoXG4gICAgbWF0Y2hlcyAmJlxuICAgICAgbWF0Y2hlcy5tYXAoKG1hdGNoKSA9PlxuICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBtYXRjaCwge1xuICAgICAgICAgIHBhcmFtczogT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50UGFyYW1zLCBtYXRjaC5wYXJhbXMpLFxuICAgICAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW3BhcmVudFBhdGhuYW1lQmFzZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgICAgICBwYXRobmFtZUJhc2U6XG4gICAgICAgICAgICBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiXG4gICAgICAgICAgICAgID8gcGFyZW50UGF0aG5hbWVCYXNlXG4gICAgICAgICAgICAgIDogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsIG1hdGNoLnBhdGhuYW1lQmFzZV0pLFxuICAgICAgICB9KVxuICAgICAgKSxcbiAgICBwYXJlbnRNYXRjaGVzXG4gICk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFVUSUxTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ3JlYXRlcyBhIHJvdXRlIGNvbmZpZyBmcm9tIGEgUmVhY3QgXCJjaGlsZHJlblwiIG9iamVjdCwgd2hpY2ggaXMgdXN1YWxseVxuICogZWl0aGVyIGEgYDxSb3V0ZT5gIGVsZW1lbnQgb3IgYW4gYXJyYXkgb2YgdGhlbS4gVXNlZCBpbnRlcm5hbGx5IGJ5XG4gKiBgPFJvdXRlcz5gIHRvIGNyZWF0ZSBhIHJvdXRlIGNvbmZpZyBmcm9tIGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI2NyZWF0ZXJvdXRlc2Zyb21jaGlsZHJlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuKFxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4pOiBSb3V0ZU9iamVjdFtdIHtcbiAgbGV0IHJvdXRlczogUm91dGVPYmplY3RbXSA9IFtdO1xuXG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChlbGVtZW50KSA9PiB7XG4gICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gSWdub3JlIG5vbi1lbGVtZW50cy4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIG1vcmUgZWFzaWx5IGlubGluZVxuICAgICAgLy8gY29uZGl0aW9uYWxzIGluIHRoZWlyIHJvdXRlIGNvbmZpZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgICAgLy8gVHJhbnNwYXJlbnRseSBzdXBwb3J0IFJlYWN0LkZyYWdtZW50IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICByb3V0ZXMucHVzaC5hcHBseShcbiAgICAgICAgcm91dGVzLFxuICAgICAgICBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbilcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52YXJpYW50KFxuICAgICAgZWxlbWVudC50eXBlID09PSBSb3V0ZSxcbiAgICAgIGBbJHtcbiAgICAgICAgdHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnQudHlwZSA6IGVsZW1lbnQudHlwZS5uYW1lXG4gICAgICB9XSBpcyBub3QgYSA8Um91dGU+IGNvbXBvbmVudC4gQWxsIGNvbXBvbmVudCBjaGlsZHJlbiBvZiA8Um91dGVzPiBtdXN0IGJlIGEgPFJvdXRlPiBvciA8UmVhY3QuRnJhZ21lbnQ+YFxuICAgICk7XG5cbiAgICBsZXQgcm91dGU6IFJvdXRlT2JqZWN0ID0ge1xuICAgICAgY2FzZVNlbnNpdGl2ZTogZWxlbWVudC5wcm9wcy5jYXNlU2Vuc2l0aXZlLFxuICAgICAgZWxlbWVudDogZWxlbWVudC5wcm9wcy5lbGVtZW50LFxuICAgICAgaW5kZXg6IGVsZW1lbnQucHJvcHMuaW5kZXgsXG4gICAgICBwYXRoOiBlbGVtZW50LnByb3BzLnBhdGgsXG4gICAgfTtcblxuICAgIGlmIChlbGVtZW50LnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICByb3V0ZS5jaGlsZHJlbiA9IGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICByb3V0ZXMucHVzaChyb3V0ZSk7XG4gIH0pO1xuXG4gIHJldHVybiByb3V0ZXM7XG59XG5cbi8qKlxuICogVGhlIHBhcmFtZXRlcnMgdGhhdCB3ZXJlIHBhcnNlZCBmcm9tIHRoZSBVUkwgcGF0aC5cbiAqL1xuZXhwb3J0IHR5cGUgUGFyYW1zPEtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4gPSB7XG4gIHJlYWRvbmx5IFtrZXkgaW4gS2V5XTogc3RyaW5nIHwgdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBBIHJvdXRlIG9iamVjdCByZXByZXNlbnRzIGEgbG9naWNhbCByb3V0ZSwgd2l0aCAob3B0aW9uYWxseSkgaXRzIGNoaWxkXG4gKiByb3V0ZXMgb3JnYW5pemVkIGluIGEgdHJlZS1saWtlIHN0cnVjdHVyZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSb3V0ZU9iamVjdCB7XG4gIGNhc2VTZW5zaXRpdmU/OiBib29sZWFuO1xuICBjaGlsZHJlbj86IFJvdXRlT2JqZWN0W107XG4gIGVsZW1lbnQ/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGluZGV4PzogYm9vbGVhbjtcbiAgcGF0aD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0aCB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNnZW5lcmF0ZXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUGF0aChwYXRoOiBzdHJpbmcsIHBhcmFtczogUGFyYW1zID0ge30pOiBzdHJpbmcge1xuICByZXR1cm4gcGF0aFxuICAgIC5yZXBsYWNlKC86KFxcdyspL2csIChfLCBrZXkpID0+IHtcbiAgICAgIGludmFyaWFudChwYXJhbXNba2V5XSAhPSBudWxsLCBgTWlzc2luZyBcIjoke2tleX1cIiBwYXJhbWApO1xuICAgICAgcmV0dXJuIHBhcmFtc1trZXldITtcbiAgICB9KVxuICAgIC5yZXBsYWNlKC9cXC8qXFwqJC8sIChfKSA9PlxuICAgICAgcGFyYW1zW1wiKlwiXSA9PSBudWxsID8gXCJcIiA6IHBhcmFtc1tcIipcIl0ucmVwbGFjZSgvXlxcLyovLCBcIi9cIilcbiAgICApO1xufVxuXG4vKipcbiAqIEEgUm91dGVNYXRjaCBjb250YWlucyBpbmZvIGFib3V0IGhvdyBhIHJvdXRlIG1hdGNoZWQgYSBVUkwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUm91dGVNYXRjaDxQYXJhbUtleSBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogVGhlIG5hbWVzIGFuZCB2YWx1ZXMgb2YgZHluYW1pYyBwYXJhbWV0ZXJzIGluIHRoZSBVUkwuXG4gICAqL1xuICBwYXJhbXM6IFBhcmFtczxQYXJhbUtleT47XG4gIC8qKlxuICAgKiBUaGUgcG9ydGlvbiBvZiB0aGUgVVJMIHBhdGhuYW1lIHRoYXQgd2FzIG1hdGNoZWQuXG4gICAqL1xuICBwYXRobmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkIGJlZm9yZSBjaGlsZCByb3V0ZXMuXG4gICAqL1xuICBwYXRobmFtZUJhc2U6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSByb3V0ZSBvYmplY3QgdGhhdCB3YXMgdXNlZCB0byBtYXRjaC5cbiAgICovXG4gIHJvdXRlOiBSb3V0ZU9iamVjdDtcbn1cblxuLyoqXG4gKiBNYXRjaGVzIHRoZSBnaXZlbiByb3V0ZXMgdG8gYSBsb2NhdGlvbiBhbmQgcmV0dXJucyB0aGUgbWF0Y2ggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2RvY3MvZW4vdjYvYXBpI21hdGNocm91dGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaFJvdXRlcyhcbiAgcm91dGVzOiBSb3V0ZU9iamVjdFtdLFxuICBsb2NhdGlvbkFyZzogUGFydGlhbDxMb2NhdGlvbj4gfCBzdHJpbmcsXG4gIGJhc2VuYW1lID0gXCIvXCJcbik6IFJvdXRlTWF0Y2hbXSB8IG51bGwge1xuICBsZXQgbG9jYXRpb24gPVxuICAgIHR5cGVvZiBsb2NhdGlvbkFyZyA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbkFyZykgOiBsb2NhdGlvbkFyZztcblxuICBsZXQgcGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiLCBiYXNlbmFtZSk7XG5cbiAgaWYgKHBhdGhuYW1lID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGxldCBicmFuY2hlcyA9IGZsYXR0ZW5Sb3V0ZXMocm91dGVzKTtcbiAgcmFua1JvdXRlQnJhbmNoZXMoYnJhbmNoZXMpO1xuXG4gIGxldCBtYXRjaGVzID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IG1hdGNoZXMgPT0gbnVsbCAmJiBpIDwgYnJhbmNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICBtYXRjaGVzID0gbWF0Y2hSb3V0ZUJyYW5jaChicmFuY2hlc1tpXSwgcGF0aG5hbWUpO1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmludGVyZmFjZSBSb3V0ZU1ldGEge1xuICByZWxhdGl2ZVBhdGg6IHN0cmluZztcbiAgY2FzZVNlbnNpdGl2ZTogYm9vbGVhbjtcbiAgY2hpbGRyZW5JbmRleDogbnVtYmVyO1xuICByb3V0ZTogUm91dGVPYmplY3Q7XG59XG5cbmludGVyZmFjZSBSb3V0ZUJyYW5jaCB7XG4gIHBhdGg6IHN0cmluZztcbiAgc2NvcmU6IG51bWJlcjtcbiAgcm91dGVzTWV0YTogUm91dGVNZXRhW107XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5Sb3V0ZXMoXG4gIHJvdXRlczogUm91dGVPYmplY3RbXSxcbiAgYnJhbmNoZXM6IFJvdXRlQnJhbmNoW10gPSBbXSxcbiAgcGFyZW50c01ldGE6IFJvdXRlTWV0YVtdID0gW10sXG4gIHBhcmVudFBhdGggPSBcIlwiXG4pOiBSb3V0ZUJyYW5jaFtdIHtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIGxldCBtZXRhOiBSb3V0ZU1ldGEgPSB7XG4gICAgICByZWxhdGl2ZVBhdGg6IHJvdXRlLnBhdGggfHwgXCJcIixcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09IHRydWUsXG4gICAgICBjaGlsZHJlbkluZGV4OiBpbmRleCxcbiAgICAgIHJvdXRlLFxuICAgIH07XG5cbiAgICBpZiAobWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgbWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChwYXJlbnRQYXRoKSxcbiAgICAgICAgYEFic29sdXRlIHJvdXRlIHBhdGggXCIke21ldGEucmVsYXRpdmVQYXRofVwiIG5lc3RlZCB1bmRlciBwYXRoIGAgK1xuICAgICAgICAgIGBcIiR7cGFyZW50UGF0aH1cIiBpcyBub3QgdmFsaWQuIEFuIGFic29sdXRlIGNoaWxkIHJvdXRlIHBhdGggYCArXG4gICAgICAgICAgYG11c3Qgc3RhcnQgd2l0aCB0aGUgY29tYmluZWQgcGF0aCBvZiBhbGwgaXRzIHBhcmVudCByb3V0ZXMuYFxuICAgICAgKTtcblxuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgbGV0IHBhdGggPSBqb2luUGF0aHMoW3BhcmVudFBhdGgsIG1ldGEucmVsYXRpdmVQYXRoXSk7XG4gICAgbGV0IHJvdXRlc01ldGEgPSBwYXJlbnRzTWV0YS5jb25jYXQobWV0YSk7XG5cbiAgICAvLyBBZGQgdGhlIGNoaWxkcmVuIGJlZm9yZSBhZGRpbmcgdGhpcyByb3V0ZSB0byB0aGUgYXJyYXkgc28gd2UgdHJhdmVyc2UgdGhlXG4gICAgLy8gcm91dGUgdHJlZSBkZXB0aC1maXJzdCBhbmQgY2hpbGQgcm91dGVzIGFwcGVhciBiZWZvcmUgdGhlaXIgcGFyZW50cyBpblxuICAgIC8vIHRoZSBcImZsYXR0ZW5lZFwiIHZlcnNpb24uXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgICAgcm91dGUuaW5kZXggIT09IHRydWUsXG4gICAgICAgIGBJbmRleCByb3V0ZXMgbXVzdCBub3QgaGF2ZSBjaGlsZCByb3V0ZXMuIFBsZWFzZSByZW1vdmUgYCArXG4gICAgICAgICAgYGFsbCBjaGlsZCByb3V0ZXMgZnJvbSByb3V0ZSBwYXRoIFwiJHtwYXRofVwiLmBcbiAgICAgICk7XG5cbiAgICAgIGZsYXR0ZW5Sb3V0ZXMocm91dGUuY2hpbGRyZW4sIGJyYW5jaGVzLCByb3V0ZXNNZXRhLCBwYXRoKTtcbiAgICB9XG5cbiAgICAvLyBSb3V0ZXMgd2l0aG91dCBhIHBhdGggc2hvdWxkbid0IGV2ZXIgbWF0Y2ggYnkgdGhlbXNlbHZlcyB1bmxlc3MgdGhleSBhcmVcbiAgICAvLyBpbmRleCByb3V0ZXMsIHNvIGRvbid0IGFkZCB0aGVtIHRvIHRoZSBsaXN0IG9mIHBvc3NpYmxlIGJyYW5jaGVzLlxuICAgIGlmIChyb3V0ZS5wYXRoID09IG51bGwgJiYgIXJvdXRlLmluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYnJhbmNoZXMucHVzaCh7IHBhdGgsIHNjb3JlOiBjb21wdXRlU2NvcmUocGF0aCwgcm91dGUuaW5kZXgpLCByb3V0ZXNNZXRhIH0pO1xuICB9KTtcblxuICByZXR1cm4gYnJhbmNoZXM7XG59XG5cbmZ1bmN0aW9uIHJhbmtSb3V0ZUJyYW5jaGVzKGJyYW5jaGVzOiBSb3V0ZUJyYW5jaFtdKTogdm9pZCB7XG4gIGJyYW5jaGVzLnNvcnQoKGEsIGIpID0+XG4gICAgYS5zY29yZSAhPT0gYi5zY29yZVxuICAgICAgPyBiLnNjb3JlIC0gYS5zY29yZSAvLyBIaWdoZXIgc2NvcmUgZmlyc3RcbiAgICAgIDogY29tcGFyZUluZGV4ZXMoXG4gICAgICAgICAgYS5yb3V0ZXNNZXRhLm1hcCgobWV0YSkgPT4gbWV0YS5jaGlsZHJlbkluZGV4KSxcbiAgICAgICAgICBiLnJvdXRlc01ldGEubWFwKChtZXRhKSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpXG4gICAgICAgIClcbiAgKTtcbn1cblxuY29uc3QgcGFyYW1SZSA9IC9eOlxcdyskLztcbmNvbnN0IGR5bmFtaWNTZWdtZW50VmFsdWUgPSAzO1xuY29uc3QgaW5kZXhSb3V0ZVZhbHVlID0gMjtcbmNvbnN0IGVtcHR5U2VnbWVudFZhbHVlID0gMTtcbmNvbnN0IHN0YXRpY1NlZ21lbnRWYWx1ZSA9IDEwO1xuY29uc3Qgc3BsYXRQZW5hbHR5ID0gLTI7XG5jb25zdCBpc1NwbGF0ID0gKHM6IHN0cmluZykgPT4gcyA9PT0gXCIqXCI7XG5cbmZ1bmN0aW9uIGNvbXB1dGVTY29yZShwYXRoOiBzdHJpbmcsIGluZGV4OiBib29sZWFuIHwgdW5kZWZpbmVkKTogbnVtYmVyIHtcbiAgbGV0IHNlZ21lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG4gIGxldCBpbml0aWFsU2NvcmUgPSBzZWdtZW50cy5sZW5ndGg7XG4gIGlmIChzZWdtZW50cy5zb21lKGlzU3BsYXQpKSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IHNwbGF0UGVuYWx0eTtcbiAgfVxuXG4gIGlmIChpbmRleCkge1xuICAgIGluaXRpYWxTY29yZSArPSBpbmRleFJvdXRlVmFsdWU7XG4gIH1cblxuICByZXR1cm4gc2VnbWVudHNcbiAgICAuZmlsdGVyKChzKSA9PiAhaXNTcGxhdChzKSlcbiAgICAucmVkdWNlKFxuICAgICAgKHNjb3JlLCBzZWdtZW50KSA9PlxuICAgICAgICBzY29yZSArXG4gICAgICAgIChwYXJhbVJlLnRlc3Qoc2VnbWVudClcbiAgICAgICAgICA/IGR5bmFtaWNTZWdtZW50VmFsdWVcbiAgICAgICAgICA6IHNlZ21lbnQgPT09IFwiXCJcbiAgICAgICAgICA/IGVtcHR5U2VnbWVudFZhbHVlXG4gICAgICAgICAgOiBzdGF0aWNTZWdtZW50VmFsdWUpLFxuICAgICAgaW5pdGlhbFNjb3JlXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYTogbnVtYmVyW10sIGI6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgbGV0IHNpYmxpbmdzID1cbiAgICBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuXG4gIHJldHVybiBzaWJsaW5nc1xuICAgID8gLy8gSWYgdHdvIHJvdXRlcyBhcmUgc2libGluZ3MsIHdlIHNob3VsZCB0cnkgdG8gbWF0Y2ggdGhlIGVhcmxpZXIgc2libGluZ1xuICAgICAgLy8gZmlyc3QuIFRoaXMgYWxsb3dzIHBlb3BsZSB0byBoYXZlIGZpbmUtZ3JhaW5lZCBjb250cm9sIG92ZXIgdGhlIG1hdGNoaW5nXG4gICAgICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgICAgIC8vIHdhbnQgdGhlbSB0cmllZC5cbiAgICAgIGFbYS5sZW5ndGggLSAxXSAtIGJbYi5sZW5ndGggLSAxXVxuICAgIDogLy8gT3RoZXJ3aXNlLCBpdCBkb2Vzbid0IHJlYWxseSBtYWtlIHNlbnNlIHRvIHJhbmsgbm9uLXNpYmxpbmdzIGJ5IGluZGV4LFxuICAgICAgLy8gc28gdGhleSBzb3J0IGVxdWFsbHkuXG4gICAgICAwO1xufVxuXG5mdW5jdGlvbiBtYXRjaFJvdXRlQnJhbmNoPFBhcmFtS2V5IGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihcbiAgYnJhbmNoOiBSb3V0ZUJyYW5jaCxcbiAgcGF0aG5hbWU6IHN0cmluZ1xuKTogUm91dGVNYXRjaDxQYXJhbUtleT5bXSB8IG51bGwge1xuICBsZXQgeyByb3V0ZXNNZXRhIH0gPSBicmFuY2g7XG5cbiAgbGV0IG1hdGNoZWRQYXJhbXMgPSB7fTtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IFwiL1wiO1xuICBsZXQgbWF0Y2hlczogUm91dGVNYXRjaFtdID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9XG4gICAgICBtYXRjaGVkUGF0aG5hbWUgPT09IFwiL1wiXG4gICAgICAgID8gcGF0aG5hbWVcbiAgICAgICAgOiBwYXRobmFtZS5zbGljZShtYXRjaGVkUGF0aG5hbWUubGVuZ3RoKSB8fCBcIi9cIjtcbiAgICBsZXQgbWF0Y2ggPSBtYXRjaFBhdGgoXG4gICAgICB7IHBhdGg6IG1ldGEucmVsYXRpdmVQYXRoLCBjYXNlU2Vuc2l0aXZlOiBtZXRhLmNhc2VTZW5zaXRpdmUsIGVuZCB9LFxuICAgICAgcmVtYWluaW5nUGF0aG5hbWVcbiAgICApO1xuXG4gICAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XG5cbiAgICBsZXQgcm91dGUgPSBtZXRhLnJvdXRlO1xuXG4gICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbm9ybWFsaXplUGF0aG5hbWUoXG4gICAgICAgIGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKVxuICAgICAgKSxcbiAgICAgIHJvdXRlLFxuICAgIH0pO1xuXG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn1cblxuLyoqXG4gKiBSZW5kZXJzIHRoZSByZXN1bHQgb2YgYG1hdGNoUm91dGVzKClgIGludG8gYSBSZWFjdCBlbGVtZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyTWF0Y2hlcyhcbiAgbWF0Y2hlczogUm91dGVNYXRjaFtdIHwgbnVsbFxuKTogUmVhY3QuUmVhY3RFbGVtZW50IHwgbnVsbCB7XG4gIHJldHVybiBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzKTtcbn1cblxuZnVuY3Rpb24gX3JlbmRlck1hdGNoZXMoXG4gIG1hdGNoZXM6IFJvdXRlTWF0Y2hbXSB8IG51bGwsXG4gIHBhcmVudE1hdGNoZXM6IFJvdXRlTWF0Y2hbXSA9IFtdXG4pOiBSZWFjdC5SZWFjdEVsZW1lbnQgfCBudWxsIHtcbiAgaWYgKG1hdGNoZXMgPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgcmV0dXJuIG1hdGNoZXMucmVkdWNlUmlnaHQoKG91dGxldCwgbWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxSb3V0ZUNvbnRleHQuUHJvdmlkZXJcbiAgICAgICAgY2hpbGRyZW49e1xuICAgICAgICAgIG1hdGNoLnJvdXRlLmVsZW1lbnQgIT09IHVuZGVmaW5lZCA/IG1hdGNoLnJvdXRlLmVsZW1lbnQgOiBvdXRsZXRcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZT17e1xuICAgICAgICAgIG91dGxldCxcbiAgICAgICAgICBtYXRjaGVzOiBwYXJlbnRNYXRjaGVzLmNvbmNhdChtYXRjaGVzLnNsaWNlKDAsIGluZGV4ICsgMSkpLFxuICAgICAgICB9fVxuICAgICAgLz5cbiAgICApO1xuICB9LCBudWxsIGFzIFJlYWN0LlJlYWN0RWxlbWVudCB8IG51bGwpO1xufVxuXG4vKipcbiAqIEEgUGF0aFBhdHRlcm4gaXMgdXNlZCB0byBtYXRjaCBvbiBzb21lIHBvcnRpb24gb2YgYSBVUkwgcGF0aG5hbWUuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGF0aFBhdHRlcm48UGF0aCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4ge1xuICAvKipcbiAgICogQSBzdHJpbmcgdG8gbWF0Y2ggYWdhaW5zdCBhIFVSTCBwYXRobmFtZS4gTWF5IGNvbnRhaW4gYDppZGAtc3R5bGUgc2VnbWVudHNcbiAgICogdG8gaW5kaWNhdGUgcGxhY2Vob2xkZXJzIGZvciBkeW5hbWljIHBhcmFtZXRlcnMuIE1heSBhbHNvIGVuZCB3aXRoIGAvKmAgdG9cbiAgICogaW5kaWNhdGUgbWF0Y2hpbmcgdGhlIHJlc3Qgb2YgdGhlIFVSTCBwYXRobmFtZS5cbiAgICovXG4gIHBhdGg6IFBhdGg7XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoZSBzdGF0aWMgcG9ydGlvbnMgb2YgdGhlIGBwYXRoYCBzaG91bGQgYmUgbWF0Y2hlZCBpblxuICAgKiB0aGUgc2FtZSBjYXNlLlxuICAgKi9cbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBTaG91bGQgYmUgYHRydWVgIGlmIHRoaXMgcGF0dGVybiBzaG91bGQgbWF0Y2ggdGhlIGVudGlyZSBVUkwgcGF0aG5hbWUuXG4gICAqL1xuICBlbmQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEEgUGF0aE1hdGNoIGNvbnRhaW5zIGluZm8gYWJvdXQgaG93IGEgUGF0aFBhdHRlcm4gbWF0Y2hlZCBvbiBhIFVSTCBwYXRobmFtZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXRoTWF0Y2g8UGFyYW1LZXkgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+IHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBhbmQgdmFsdWVzIG9mIGR5bmFtaWMgcGFyYW1ldGVycyBpbiB0aGUgVVJMLlxuICAgKi9cbiAgcGFyYW1zOiBQYXJhbXM8UGFyYW1LZXk+O1xuICAvKipcbiAgICogVGhlIHBvcnRpb24gb2YgdGhlIFVSTCBwYXRobmFtZSB0aGF0IHdhcyBtYXRjaGVkLlxuICAgKi9cbiAgcGF0aG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgbWF0Y2hlZCBiZWZvcmUgY2hpbGQgcm91dGVzLlxuICAgKi9cbiAgcGF0aG5hbWVCYXNlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgcGF0dGVybiB0aGF0IHdhcyB1c2VkIHRvIG1hdGNoLlxuICAgKi9cbiAgcGF0dGVybjogUGF0aFBhdHRlcm47XG59XG5cbnR5cGUgTXV0YWJsZTxUPiA9IHtcbiAgLXJlYWRvbmx5IFtQIGluIGtleW9mIFRdOiBUW1BdO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBwYXR0ZXJuIG1hdGNoaW5nIG9uIGEgVVJMIHBhdGhuYW1lIGFuZCByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgbWF0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9kb2NzL2VuL3Y2L2FwaSNtYXRjaHBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoUGF0aDxcbiAgUGFyYW1LZXkgZXh0ZW5kcyBQYXJhbVBhcnNlS2V5PFBhdGg+LFxuICBQYXRoIGV4dGVuZHMgc3RyaW5nXG4+KFxuICBwYXR0ZXJuOiBQYXRoUGF0dGVybjxQYXRoPiB8IFBhdGgsXG4gIHBhdGhuYW1lOiBzdHJpbmdcbik6IFBhdGhNYXRjaDxQYXJhbUtleT4gfCBudWxsIHtcbiAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgcGF0dGVybiA9IHsgcGF0aDogcGF0dGVybiwgY2FzZVNlbnNpdGl2ZTogZmFsc2UsIGVuZDogdHJ1ZSB9O1xuICB9XG5cbiAgbGV0IFttYXRjaGVyLCBwYXJhbU5hbWVzXSA9IGNvbXBpbGVQYXRoKFxuICAgIHBhdHRlcm4ucGF0aCxcbiAgICBwYXR0ZXJuLmNhc2VTZW5zaXRpdmUsXG4gICAgcGF0dGVybi5lbmRcbiAgKTtcblxuICBsZXQgbWF0Y2ggPSBwYXRobmFtZS5tYXRjaChtYXRjaGVyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtczogUGFyYW1zID0gcGFyYW1OYW1lcy5yZWR1Y2U8TXV0YWJsZTxQYXJhbXM+PihcbiAgICAobWVtbywgcGFyYW1OYW1lLCBpbmRleCkgPT4ge1xuICAgICAgLy8gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBwYXRobmFtZUJhc2UgaGVyZSB1c2luZyB0aGUgcmF3IHNwbGF0IHZhbHVlXG4gICAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHBhcmFtc1tcIipcIl0gbGF0ZXIgYmVjYXVzZSBpdCB3aWxsIGJlIGRlY29kZWQgdGhlblxuICAgICAgaWYgKHBhcmFtTmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgbGV0IHNwbGF0VmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XSB8fCBcIlwiO1xuICAgICAgICBwYXRobmFtZUJhc2UgPSBtYXRjaGVkUGF0aG5hbWVcbiAgICAgICAgICAuc2xpY2UoMCwgbWF0Y2hlZFBhdGhuYW1lLmxlbmd0aCAtIHNwbGF0VmFsdWUubGVuZ3RoKVxuICAgICAgICAgIC5yZXBsYWNlKC8oLilcXC8rJC8sIFwiJDFcIik7XG4gICAgICB9XG5cbiAgICAgIG1lbW9bcGFyYW1OYW1lXSA9IHNhZmVseURlY29kZVVSSUNvbXBvbmVudChcbiAgICAgICAgY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIixcbiAgICAgICAgcGFyYW1OYW1lXG4gICAgICApO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSxcbiAgICB7fVxuICApO1xuXG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm4sXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKFxuICBwYXRoOiBzdHJpbmcsXG4gIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgZW5kID0gdHJ1ZVxuKTogW1JlZ0V4cCwgc3RyaW5nW11dIHtcbiAgd2FybmluZyhcbiAgICBwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLFxuICAgIGBSb3V0ZSBwYXRoIFwiJHtwYXRofVwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIGAgK1xuICAgICAgYFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiIGJlY2F1c2UgdGhlIFxcYCpcXGAgY2hhcmFjdGVyIG11c3QgYCArXG4gICAgICBgYWx3YXlzIGZvbGxvdyBhIFxcYC9cXGAgaW4gdGhlIHBhdHRlcm4uIFRvIGdldCByaWQgb2YgdGhpcyB3YXJuaW5nLCBgICtcbiAgICAgIGBwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFwiJHtwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpfVwiLmBcbiAgKTtcblxuICBsZXQgcGFyYW1OYW1lczogc3RyaW5nW10gPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9XG4gICAgXCJeXCIgK1xuICAgIHBhdGhcbiAgICAgIC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKSAvLyBJZ25vcmUgdHJhaWxpbmcgLyBhbmQgLyosIHdlJ2xsIGhhbmRsZSBpdCBiZWxvd1xuICAgICAgLnJlcGxhY2UoL15cXC8qLywgXCIvXCIpIC8vIE1ha2Ugc3VyZSBpdCBoYXMgYSBsZWFkaW5nIC9cbiAgICAgIC5yZXBsYWNlKC9bXFxcXC4qK14kP3t9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcnNcbiAgICAgIC5yZXBsYWNlKC86KFxcdyspL2csIChfOiBzdHJpbmcsIHBhcmFtTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgIHBhcmFtTmFtZXMucHVzaChwYXJhbU5hbWUpO1xuICAgICAgICByZXR1cm4gXCIoW15cXFxcL10rKVwiO1xuICAgICAgfSk7XG5cbiAgaWYgKHBhdGguZW5kc1dpdGgoXCIqXCIpKSB7XG4gICAgcGFyYW1OYW1lcy5wdXNoKFwiKlwiKTtcbiAgICByZWdleHBTb3VyY2UgKz1cbiAgICAgIHBhdGggPT09IFwiKlwiIHx8IHBhdGggPT09IFwiLypcIlxuICAgICAgICA/IFwiKC4qKSRcIiAvLyBBbHJlYWR5IG1hdGNoZWQgdGhlIGluaXRpYWwgLywganVzdCBtYXRjaCB0aGUgcmVzdFxuICAgICAgICA6IFwiKD86XFxcXC8oLispfFxcXFwvKikkXCI7IC8vIERvbid0IGluY2x1ZGUgdGhlIC8gaW4gcGFyYW1zW1wiKlwiXVxuICB9IGVsc2Uge1xuICAgIHJlZ2V4cFNvdXJjZSArPSBlbmRcbiAgICAgID8gXCJcXFxcLyokXCIgLy8gV2hlbiBtYXRjaGluZyB0byB0aGUgZW5kLCBpZ25vcmUgdHJhaWxpbmcgc2xhc2hlc1xuICAgICAgOiAvLyBPdGhlcndpc2UsIG1hdGNoIGEgd29yZCBib3VuZGFyeSBvciBhIHByb2NlZWRpbmcgLy4gVGhlIHdvcmQgYm91bmRhcnkgcmVzdHJpY3RzXG4gICAgICAgIC8vIHBhcmVudCByb3V0ZXMgdG8gbWF0Y2hpbmcgb25seSB0aGVpciBvd24gd29yZHMgYW5kIG5vdGhpbmcgbW9yZSwgZS5nLiBwYXJlbnRcbiAgICAgICAgLy8gcm91dGUgXCIvaG9tZVwiIHNob3VsZCBub3QgbWF0Y2ggXCIvaG9tZTJcIi5cbiAgICAgICAgLy8gQWRkaXRpb25hbGx5LCBhbGxvdyBwYXRocyBzdGFydGluZyB3aXRoIGAuYCwgYC1gLCBgfmAsIGFuZCB1cmwtZW5jb2RlZCBlbnRpdGllcyxcbiAgICAgICAgLy8gYnV0IGRvIG5vdCBjb25zdW1lIHRoZSBjaGFyYWN0ZXIgaW4gdGhlIG1hdGNoZWQgcGF0aCBzbyB0aGV5IGNhbiBtYXRjaCBhZ2FpbnN0XG4gICAgICAgIC8vIG5lc3RlZCBwYXRocy5cbiAgICAgICAgXCIoPzooPz1bLn4tXXwlWzAtOUEtRl17Mn0pfFxcXFxifFxcXFwvfCQpXCI7XG4gIH1cblxuICBsZXQgbWF0Y2hlciA9IG5ldyBSZWdFeHAocmVnZXhwU291cmNlLCBjYXNlU2Vuc2l0aXZlID8gdW5kZWZpbmVkIDogXCJpXCIpO1xuXG4gIHJldHVybiBbbWF0Y2hlciwgcGFyYW1OYW1lc107XG59XG5cbmZ1bmN0aW9uIHNhZmVseURlY29kZVVSSUNvbXBvbmVudCh2YWx1ZTogc3RyaW5nLCBwYXJhbU5hbWU6IHN0cmluZykge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHdhcm5pbmcoXG4gICAgICBmYWxzZSxcbiAgICAgIGBUaGUgdmFsdWUgZm9yIHRoZSBVUkwgcGFyYW0gXCIke3BhcmFtTmFtZX1cIiB3aWxsIG5vdCBiZSBkZWNvZGVkIGJlY2F1c2VgICtcbiAgICAgICAgYCB0aGUgc3RyaW5nIFwiJHt2YWx1ZX1cIiBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseWAgK1xuICAgICAgICBgIGR1ZSB0byBhIGJhZCBwZXJjZW50IGVuY29kaW5nICgke2Vycm9yfSkuYFxuICAgICk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcmVzb2x2ZWQgcGF0aCBvYmplY3QgcmVsYXRpdmUgdG8gdGhlIGdpdmVuIHBhdGhuYW1lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vZG9jcy9lbi92Ni9hcGkjcmVzb2x2ZXBhdGhcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQYXRoKHRvOiBUbywgZnJvbVBhdGhuYW1lID0gXCIvXCIpOiBQYXRoIHtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogdG9QYXRobmFtZSxcbiAgICBzZWFyY2ggPSBcIlwiLFxuICAgIGhhc2ggPSBcIlwiLFxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuXG4gIGxldCBwYXRobmFtZSA9IHRvUGF0aG5hbWVcbiAgICA/IHRvUGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIilcbiAgICAgID8gdG9QYXRobmFtZVxuICAgICAgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKVxuICAgIDogZnJvbVBhdGhuYW1lO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoOiBub3JtYWxpemVTZWFyY2goc2VhcmNoKSxcbiAgICBoYXNoOiBub3JtYWxpemVIYXNoKGhhc2gpLFxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlUGF0aG5hbWUocmVsYXRpdmVQYXRoOiBzdHJpbmcsIGZyb21QYXRobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgbGV0IHNlZ21lbnRzID0gZnJvbVBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICBsZXQgcmVsYXRpdmVTZWdtZW50cyA9IHJlbGF0aXZlUGF0aC5zcGxpdChcIi9cIik7XG5cbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKChzZWdtZW50KSA9PiB7XG4gICAgaWYgKHNlZ21lbnQgPT09IFwiLi5cIikge1xuICAgICAgLy8gS2VlcCB0aGUgcm9vdCBcIlwiIHNlZ21lbnQgc28gdGhlIHBhdGhuYW1lIHN0YXJ0cyBhdCAvXG4gICAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkgc2VnbWVudHMucG9wKCk7XG4gICAgfSBlbHNlIGlmIChzZWdtZW50ICE9PSBcIi5cIikge1xuICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBzZWdtZW50cy5sZW5ndGggPiAxID8gc2VnbWVudHMuam9pbihcIi9cIikgOiBcIi9cIjtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVRvKFxuICB0b0FyZzogVG8sXG4gIHJvdXRlUGF0aG5hbWVzOiBzdHJpbmdbXSxcbiAgbG9jYXRpb25QYXRobmFtZTogc3RyaW5nXG4pOiBQYXRoIHtcbiAgbGV0IHRvID0gdHlwZW9mIHRvQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvQXJnKSA6IHRvQXJnO1xuICBsZXQgdG9QYXRobmFtZSA9IHRvQXJnID09PSBcIlwiIHx8IHRvLnBhdGhuYW1lID09PSBcIlwiID8gXCIvXCIgOiB0by5wYXRobmFtZTtcblxuICAvLyBJZiBhIHBhdGhuYW1lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gYHRvYCwgaXQgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAvLyByb3V0ZSBjb250ZXh0LiBUaGlzIGlzIGV4cGxhaW5lZCBpbiBgTm90ZSBvbiBgPExpbmsgdG8+YCB2YWx1ZXNgIGluIG91clxuICAvLyBtaWdyYXRpb24gZ3VpZGUgZnJvbSB2NSBhcyBhIG1lYW5zIG9mIGRpc2FtYmlndWF0aW9uIGJldHdlZW4gYHRvYCB2YWx1ZXNcbiAgLy8gdGhhdCBiZWdpbiB3aXRoIGAvYCBhbmQgdGhvc2UgdGhhdCBkbyBub3QuIEhvd2V2ZXIsIHRoaXMgaXMgcHJvYmxlbWF0aWMgZm9yXG4gIC8vIGB0b2AgdmFsdWVzIHRoYXQgZG8gbm90IHByb3ZpZGUgYSBwYXRobmFtZS4gYHRvYCBjYW4gc2ltcGx5IGJlIGEgc2VhcmNoIG9yXG4gIC8vIGhhc2ggc3RyaW5nLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBhc3N1bWUgdGhhdCB0aGUgbmF2aWdhdGlvbiBpcyByZWxhdGl2ZVxuICAvLyB0byB0aGUgY3VycmVudCBsb2NhdGlvbidzIHBhdGhuYW1lIGFuZCAqbm90KiB0aGUgcm91dGUgcGF0aG5hbWUuXG4gIGxldCBmcm9tOiBzdHJpbmc7XG4gIGlmICh0b1BhdGhuYW1lID09IG51bGwpIHtcbiAgICBmcm9tID0gbG9jYXRpb25QYXRobmFtZTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcm91dGVQYXRobmFtZUluZGV4ID0gcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMTtcblxuICAgIGlmICh0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcblxuICAgICAgLy8gRWFjaCBsZWFkaW5nIC4uIHNlZ21lbnQgbWVhbnMgXCJnbyB1cCBvbmUgcm91dGVcIiBpbnN0ZWFkIG9mIFwiZ28gdXAgb25lXG4gICAgICAvLyBVUkwgc2VnbWVudFwiLiAgVGhpcyBpcyBhIGtleSBkaWZmZXJlbmNlIGZyb20gaG93IDxhIGhyZWY+IHdvcmtzIGFuZCBhXG4gICAgICAvLyBtYWpvciByZWFzb24gd2UgY2FsbCB0aGlzIGEgXCJ0b1wiIHZhbHVlIGluc3RlYWQgb2YgYSBcImhyZWZcIi5cbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cblxuICAgICAgdG8ucGF0aG5hbWUgPSB0b1NlZ21lbnRzLmpvaW4oXCIvXCIpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIFwiLi5cIiBzZWdtZW50cyB0aGFuIHBhcmVudCByb3V0ZXMsIHJlc29sdmUgcmVsYXRpdmUgdG9cbiAgICAvLyB0aGUgcm9vdCAvIFVSTC5cbiAgICBmcm9tID0gcm91dGVQYXRobmFtZUluZGV4ID49IDAgPyByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lSW5kZXhdIDogXCIvXCI7XG4gIH1cblxuICBsZXQgcGF0aCA9IHJlc29sdmVQYXRoKHRvLCBmcm9tKTtcblxuICAvLyBFbnN1cmUgdGhlIHBhdGhuYW1lIGhhcyBhIHRyYWlsaW5nIHNsYXNoIGlmIHRoZSBvcmlnaW5hbCB0byB2YWx1ZSBoYWQgb25lLlxuICBpZiAoXG4gICAgdG9QYXRobmFtZSAmJlxuICAgIHRvUGF0aG5hbWUgIT09IFwiL1wiICYmXG4gICAgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIikgJiZcbiAgICAhcGF0aC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIilcbiAgKSB7XG4gICAgcGF0aC5wYXRobmFtZSArPSBcIi9cIjtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuXG5mdW5jdGlvbiBnZXRUb1BhdGhuYW1lKHRvOiBUbyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIC8vIEVtcHR5IHN0cmluZ3Mgc2hvdWxkIGJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgLyBwYXRoc1xuICByZXR1cm4gdG8gPT09IFwiXCIgfHwgKHRvIGFzIFBhdGgpLnBhdGhuYW1lID09PSBcIlwiXG4gICAgPyBcIi9cIlxuICAgIDogdHlwZW9mIHRvID09PSBcInN0cmluZ1wiXG4gICAgPyBwYXJzZVBhdGgodG8pLnBhdGhuYW1lXG4gICAgOiB0by5wYXRobmFtZTtcbn1cblxuZnVuY3Rpb24gc3RyaXBCYXNlbmFtZShwYXRobmFtZTogc3RyaW5nLCBiYXNlbmFtZTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIGlmIChiYXNlbmFtZSA9PT0gXCIvXCIpIHJldHVybiBwYXRobmFtZTtcblxuICBpZiAoIXBhdGhuYW1lLnRvTG93ZXJDYXNlKCkuc3RhcnRzV2l0aChiYXNlbmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbGV0IG5leHRDaGFyID0gcGF0aG5hbWUuY2hhckF0KGJhc2VuYW1lLmxlbmd0aCk7XG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICAvLyBwYXRobmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIGJhc2VuYW1lL1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnNsaWNlKGJhc2VuYW1lLmxlbmd0aCkgfHwgXCIvXCI7XG59XG5cbmNvbnN0IGpvaW5QYXRocyA9IChwYXRoczogc3RyaW5nW10pOiBzdHJpbmcgPT5cbiAgcGF0aHMuam9pbihcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIik7XG5cbmNvbnN0IG5vcm1hbGl6ZVBhdGhuYW1lID0gKHBhdGhuYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgcGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcblxuY29uc3Qgbm9ybWFsaXplU2VhcmNoID0gKHNlYXJjaDogc3RyaW5nKTogc3RyaW5nID0+XG4gICFzZWFyY2ggfHwgc2VhcmNoID09PSBcIj9cIlxuICAgID8gXCJcIlxuICAgIDogc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpXG4gICAgPyBzZWFyY2hcbiAgICA6IFwiP1wiICsgc2VhcmNoO1xuXG5jb25zdCBub3JtYWxpemVIYXNoID0gKGhhc2g6IHN0cmluZyk6IHN0cmluZyA9PlxuICAhaGFzaCB8fCBoYXNoID09PSBcIiNcIiA/IFwiXCIgOiBoYXNoLnN0YXJ0c1dpdGgoXCIjXCIpID8gaGFzaCA6IFwiI1wiICsgaGFzaDtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gREFOR0VSISBQTEVBU0UgUkVBRCBNRSFcbi8vIFdlIHByb3ZpZGUgdGhlc2UgZXhwb3J0cyBhcyBhbiBlc2NhcGUgaGF0Y2ggaW4gdGhlIGV2ZW50IHRoYXQgeW91IG5lZWQgYW55XG4vLyByb3V0aW5nIGRhdGEgdGhhdCB3ZSBkb24ndCBwcm92aWRlIGFuIGV4cGxpY2l0IEFQSSBmb3IuIFdpdGggdGhhdCBzYWlkLCB3ZVxuLy8gd2FudCB0byBjb3ZlciB5b3VyIHVzZSBjYXNlIGlmIHdlIGNhbiwgc28gaWYgeW91IGZlZWwgdGhlIG5lZWQgdG8gdXNlIHRoZXNlXG4vLyB3ZSB3YW50IHRvIGhlYXIgZnJvbSB5b3UuIExldCB1cyBrbm93IHdoYXQgeW91J3JlIGJ1aWxkaW5nIGFuZCB3ZSdsbCBkbyBvdXJcbi8vIGJlc3QgdG8gbWFrZSBzdXJlIHdlIGNhbiBzdXBwb3J0IHlvdSFcbi8vXG4vLyBXZSBjb25zaWRlciB0aGVzZSBleHBvcnRzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBhbmQgZG8gbm90IGd1YXJhbnRlZVxuLy8gYWdhaW5zdCBhbnkgYnJlYWtpbmcgY2hhbmdlcywgcmVnYXJkbGVzcyBvZiB0aGUgc2VtdmVyIHJlbGVhc2UuIFVzZSB3aXRoXG4vLyBleHRyZW1lIGNhdXRpb24gYW5kIG9ubHkgaWYgeW91IHVuZGVyc3RhbmQgdGhlIGNvbnNlcXVlbmNlcy4gR29kc3BlZWQuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCB7XG4gIE5hdmlnYXRpb25Db250ZXh0IGFzIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCxcbiAgTG9jYXRpb25Db250ZXh0IGFzIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsXG4gIFJvdXRlQ29udGV4dCBhcyBVTlNBRkVfUm91dGVDb250ZXh0LFxufTtcbiIsICJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB0eXBlIHsgQnJvd3Nlckhpc3RvcnksIEhhc2hIaXN0b3J5LCBIaXN0b3J5IH0gZnJvbSBcImhpc3RvcnlcIjtcbmltcG9ydCB7IGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSB9IGZyb20gXCJoaXN0b3J5XCI7XG5pbXBvcnQge1xuICBNZW1vcnlSb3V0ZXIsXG4gIE5hdmlnYXRlLFxuICBPdXRsZXQsXG4gIFJvdXRlLFxuICBSb3V0ZXIsXG4gIFJvdXRlcyxcbiAgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLFxuICBnZW5lcmF0ZVBhdGgsXG4gIG1hdGNoUm91dGVzLFxuICBtYXRjaFBhdGgsXG4gIGNyZWF0ZVBhdGgsXG4gIHBhcnNlUGF0aCxcbiAgcmVzb2x2ZVBhdGgsXG4gIHJlbmRlck1hdGNoZXMsXG4gIHVzZUhyZWYsXG4gIHVzZUluUm91dGVyQ29udGV4dCxcbiAgdXNlTG9jYXRpb24sXG4gIHVzZU1hdGNoLFxuICB1c2VOYXZpZ2F0ZSxcbiAgdXNlTmF2aWdhdGlvblR5cGUsXG4gIHVzZU91dGxldCxcbiAgdXNlUGFyYW1zLFxuICB1c2VSZXNvbHZlZFBhdGgsXG4gIHVzZVJvdXRlcyxcbiAgdXNlT3V0bGV0Q29udGV4dCxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuaW1wb3J0IHR5cGUgeyBUbyB9IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcblxuZnVuY3Rpb24gd2FybmluZyhjb25kOiBib29sZWFuLCBtZXNzYWdlOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpIGNvbnNvbGUud2FybihtZXNzYWdlKTtcblxuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCBSb3V0ZXIhXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB5b3UgY2FuIG1vcmUgZWFzaWx5XG4gICAgICAvLyBmaW5kIHRoZSBzb3VyY2UgZm9yIGEgd2FybmluZyB0aGF0IGFwcGVhcnMgaW4gdGhlIGNvbnNvbGUgYnlcbiAgICAgIC8vIGVuYWJsaW5nIFwicGF1c2Ugb24gZXhjZXB0aW9uc1wiIGluIHlvdXIgSmF2YVNjcmlwdCBkZWJ1Z2dlci5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFJFLUVYUE9SVFNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8vIE5vdGU6IEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJvdXRlciBleHBvcnRzIVxuZXhwb3J0IHtcbiAgTWVtb3J5Um91dGVyLFxuICBOYXZpZ2F0ZSxcbiAgT3V0bGV0LFxuICBSb3V0ZSxcbiAgUm91dGVyLFxuICBSb3V0ZXMsXG4gIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbixcbiAgZ2VuZXJhdGVQYXRoLFxuICBtYXRjaFJvdXRlcyxcbiAgbWF0Y2hQYXRoLFxuICBjcmVhdGVQYXRoLFxuICBwYXJzZVBhdGgsXG4gIHJlbmRlck1hdGNoZXMsXG4gIHJlc29sdmVQYXRoLFxuICB1c2VIcmVmLFxuICB1c2VJblJvdXRlckNvbnRleHQsXG4gIHVzZUxvY2F0aW9uLFxuICB1c2VNYXRjaCxcbiAgdXNlTmF2aWdhdGUsXG4gIHVzZU5hdmlnYXRpb25UeXBlLFxuICB1c2VPdXRsZXQsXG4gIHVzZVBhcmFtcyxcbiAgdXNlUmVzb2x2ZWRQYXRoLFxuICB1c2VSb3V0ZXMsXG4gIHVzZU91dGxldENvbnRleHQsXG59O1xuXG5leHBvcnQgeyBOYXZpZ2F0aW9uVHlwZSB9IGZyb20gXCJyZWFjdC1yb3V0ZXJcIjtcbmV4cG9ydCB0eXBlIHtcbiAgSGFzaCxcbiAgTG9jYXRpb24sXG4gIFBhdGgsXG4gIFRvLFxuICBNZW1vcnlSb3V0ZXJQcm9wcyxcbiAgTmF2aWdhdGVGdW5jdGlvbixcbiAgTmF2aWdhdGVPcHRpb25zLFxuICBOYXZpZ2F0ZVByb3BzLFxuICBOYXZpZ2F0b3IsXG4gIE91dGxldFByb3BzLFxuICBQYXJhbXMsXG4gIFBhdGhNYXRjaCxcbiAgUm91dGVNYXRjaCxcbiAgUm91dGVPYmplY3QsXG4gIFJvdXRlUHJvcHMsXG4gIFBhdGhSb3V0ZVByb3BzLFxuICBMYXlvdXRSb3V0ZVByb3BzLFxuICBJbmRleFJvdXRlUHJvcHMsXG4gIFJvdXRlclByb3BzLFxuICBQYXRobmFtZSxcbiAgU2VhcmNoLFxuICBSb3V0ZXNQcm9wcyxcbn0gZnJvbSBcInJlYWN0LXJvdXRlclwiO1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBEQU5HRVIhIFBMRUFTRSBSRUFEIE1FIVxuLy8gV2UgcHJvdmlkZSB0aGVzZSBleHBvcnRzIGFzIGFuIGVzY2FwZSBoYXRjaCBpbiB0aGUgZXZlbnQgdGhhdCB5b3UgbmVlZCBhbnlcbi8vIHJvdXRpbmcgZGF0YSB0aGF0IHdlIGRvbid0IHByb3ZpZGUgYW4gZXhwbGljaXQgQVBJIGZvci4gV2l0aCB0aGF0IHNhaWQsIHdlXG4vLyB3YW50IHRvIGNvdmVyIHlvdXIgdXNlIGNhc2UgaWYgd2UgY2FuLCBzbyBpZiB5b3UgZmVlbCB0aGUgbmVlZCB0byB1c2UgdGhlc2Vcbi8vIHdlIHdhbnQgdG8gaGVhciBmcm9tIHlvdS4gTGV0IHVzIGtub3cgd2hhdCB5b3UncmUgYnVpbGRpbmcgYW5kIHdlJ2xsIGRvIG91clxuLy8gYmVzdCB0byBtYWtlIHN1cmUgd2UgY2FuIHN1cHBvcnQgeW91IVxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZXNlIGV4cG9ydHMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIGFuZCBkbyBub3QgZ3VhcmFudGVlXG4vLyBhZ2FpbnN0IGFueSBicmVha2luZyBjaGFuZ2VzLCByZWdhcmRsZXNzIG9mIHRoZSBzZW12ZXIgcmVsZWFzZS4gVXNlIHdpdGhcbi8vIGV4dHJlbWUgY2F1dGlvbiBhbmQgb25seSBpZiB5b3UgdW5kZXJzdGFuZCB0aGUgY29uc2VxdWVuY2VzLiBHb2RzcGVlZC5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IHtcbiAgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LFxuICBVTlNBRkVfTG9jYXRpb25Db250ZXh0LFxuICBVTlNBRkVfUm91dGVDb250ZXh0LFxufSBmcm9tIFwicmVhY3Qtcm91dGVyXCI7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBDT01QT05FTlRTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5leHBvcnQgaW50ZXJmYWNlIEJyb3dzZXJSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgd2luZG93PzogV2luZG93O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gUHJvdmlkZXMgdGhlIGNsZWFuZXN0IFVSTHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBCcm93c2VyUm91dGVyKHtcbiAgYmFzZW5hbWUsXG4gIGNoaWxkcmVuLFxuICB3aW5kb3csXG59OiBCcm93c2VyUm91dGVyUHJvcHMpIHtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWY8QnJvd3Nlckhpc3Rvcnk+KCk7XG4gIGlmIChoaXN0b3J5UmVmLmN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGhpc3RvcnlSZWYuY3VycmVudCA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5KHsgd2luZG93IH0pO1xuICB9XG5cbiAgbGV0IGhpc3RvcnkgPSBoaXN0b3J5UmVmLmN1cnJlbnQ7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uLFxuICB9KTtcblxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gaGlzdG9yeS5saXN0ZW4oc2V0U3RhdGUpLCBbaGlzdG9yeV0pO1xuXG4gIHJldHVybiAoXG4gICAgPFJvdXRlclxuICAgICAgYmFzZW5hbWU9e2Jhc2VuYW1lfVxuICAgICAgY2hpbGRyZW49e2NoaWxkcmVufVxuICAgICAgbG9jYXRpb249e3N0YXRlLmxvY2F0aW9ufVxuICAgICAgbmF2aWdhdGlvblR5cGU9e3N0YXRlLmFjdGlvbn1cbiAgICAgIG5hdmlnYXRvcj17aGlzdG9yeX1cbiAgICAvPlxuICApO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEhhc2hSb3V0ZXJQcm9wcyB7XG4gIGJhc2VuYW1lPzogc3RyaW5nO1xuICBjaGlsZHJlbj86IFJlYWN0LlJlYWN0Tm9kZTtcbiAgd2luZG93PzogV2luZG93O1xufVxuXG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gU3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB0aGUgaGFzaFxuICogcG9ydGlvbiBvZiB0aGUgVVJMIHNvIGl0IGlzIG5vdCBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBIYXNoUm91dGVyKHsgYmFzZW5hbWUsIGNoaWxkcmVuLCB3aW5kb3cgfTogSGFzaFJvdXRlclByb3BzKSB7XG4gIGxldCBoaXN0b3J5UmVmID0gUmVhY3QudXNlUmVmPEhhc2hIaXN0b3J5PigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVIYXNoSGlzdG9yeSh7IHdpbmRvdyB9KTtcbiAgfVxuXG4gIGxldCBoaXN0b3J5ID0gaGlzdG9yeVJlZi5jdXJyZW50O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZSh7XG4gICAgYWN0aW9uOiBoaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgfSk7XG5cbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnldKTtcblxuICByZXR1cm4gKFxuICAgIDxSb3V0ZXJcbiAgICAgIGJhc2VuYW1lPXtiYXNlbmFtZX1cbiAgICAgIGNoaWxkcmVuPXtjaGlsZHJlbn1cbiAgICAgIGxvY2F0aW9uPXtzdGF0ZS5sb2NhdGlvbn1cbiAgICAgIG5hdmlnYXRpb25UeXBlPXtzdGF0ZS5hY3Rpb259XG4gICAgICBuYXZpZ2F0b3I9e2hpc3Rvcnl9XG4gICAgLz5cbiAgKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBIaXN0b3J5Um91dGVyUHJvcHMge1xuICBiYXNlbmFtZT86IHN0cmluZztcbiAgY2hpbGRyZW4/OiBSZWFjdC5SZWFjdE5vZGU7XG4gIGhpc3Rvcnk6IEhpc3Rvcnk7XG59XG5cbi8qKlxuICogQSBgPFJvdXRlcj5gIHRoYXQgYWNjZXB0cyBhIHByZS1pbnN0YW50aWF0ZWQgaGlzdG9yeSBvYmplY3QuIEl0J3MgaW1wb3J0YW50XG4gKiB0byBub3RlIHRoYXQgdXNpbmcgeW91ciBvd24gaGlzdG9yeSBvYmplY3QgaXMgaGlnaGx5IGRpc2NvdXJhZ2VkIGFuZCBtYXkgYWRkXG4gKiB0d28gdmVyc2lvbnMgb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0byB5b3VyIGJ1bmRsZXMgdW5sZXNzIHlvdSB1c2UgdGhlIHNhbWVcbiAqIHZlcnNpb24gb2YgdGhlIGhpc3RvcnkgbGlicmFyeSB0aGF0IFJlYWN0IFJvdXRlciB1c2VzIGludGVybmFsbHkuXG4gKi9cbmZ1bmN0aW9uIEhpc3RvcnlSb3V0ZXIoeyBiYXNlbmFtZSwgY2hpbGRyZW4sIGhpc3RvcnkgfTogSGlzdG9yeVJvdXRlclByb3BzKSB7XG4gIGNvbnN0IFtzdGF0ZSwgc2V0U3RhdGVdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gIH0pO1xuXG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5XSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Um91dGVyXG4gICAgICBiYXNlbmFtZT17YmFzZW5hbWV9XG4gICAgICBjaGlsZHJlbj17Y2hpbGRyZW59XG4gICAgICBsb2NhdGlvbj17c3RhdGUubG9jYXRpb259XG4gICAgICBuYXZpZ2F0aW9uVHlwZT17c3RhdGUuYWN0aW9ufVxuICAgICAgbmF2aWdhdG9yPXtoaXN0b3J5fVxuICAgIC8+XG4gICk7XG59XG5cbmlmIChfX0RFVl9fKSB7XG4gIEhpc3RvcnlSb3V0ZXIuZGlzcGxheU5hbWUgPSBcInVuc3RhYmxlX0hpc3RvcnlSb3V0ZXJcIjtcbn1cblxuZXhwb3J0IHsgSGlzdG9yeVJvdXRlciBhcyB1bnN0YWJsZV9IaXN0b3J5Um91dGVyIH07XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudDogUmVhY3QuTW91c2VFdmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTGlua1Byb3BzXG4gIGV4dGVuZHMgT21pdDxSZWFjdC5BbmNob3JIVE1MQXR0cmlidXRlczxIVE1MQW5jaG9yRWxlbWVudD4sIFwiaHJlZlwiPiB7XG4gIHJlbG9hZERvY3VtZW50PzogYm9vbGVhbjtcbiAgcmVwbGFjZT86IGJvb2xlYW47XG4gIHN0YXRlPzogYW55O1xuICB0bzogVG87XG59XG5cbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgPGE+LlxuICovXG5leHBvcnQgY29uc3QgTGluayA9IFJlYWN0LmZvcndhcmRSZWY8SFRNTEFuY2hvckVsZW1lbnQsIExpbmtQcm9wcz4oXG4gIGZ1bmN0aW9uIExpbmtXaXRoUmVmKFxuICAgIHsgb25DbGljaywgcmVsb2FkRG9jdW1lbnQsIHJlcGxhY2UgPSBmYWxzZSwgc3RhdGUsIHRhcmdldCwgdG8sIC4uLnJlc3QgfSxcbiAgICByZWZcbiAgKSB7XG4gICAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvKTtcbiAgICBsZXQgaW50ZXJuYWxPbkNsaWNrID0gdXNlTGlua0NsaWNrSGFuZGxlcih0bywgeyByZXBsYWNlLCBzdGF0ZSwgdGFyZ2V0IH0pO1xuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKFxuICAgICAgZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTEFuY2hvckVsZW1lbnQsIE1vdXNlRXZlbnQ+XG4gICAgKSB7XG4gICAgICBpZiAob25DbGljaykgb25DbGljayhldmVudCk7XG4gICAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgJiYgIXJlbG9hZERvY3VtZW50KSB7XG4gICAgICAgIGludGVybmFsT25DbGljayhldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBqc3gtYTExeS9hbmNob3ItaGFzLWNvbnRlbnRcbiAgICAgIDxhXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICBocmVmPXtocmVmfVxuICAgICAgICBvbkNsaWNrPXtoYW5kbGVDbGlja31cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHRhcmdldD17dGFyZ2V0fVxuICAgICAgLz5cbiAgICApO1xuICB9XG4pO1xuXG5pZiAoX19ERVZfXykge1xuICBMaW5rLmRpc3BsYXlOYW1lID0gXCJMaW5rXCI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmF2TGlua1Byb3BzXG4gIGV4dGVuZHMgT21pdDxMaW5rUHJvcHMsIFwiY2xhc3NOYW1lXCIgfCBcInN0eWxlXCIgfCBcImNoaWxkcmVuXCI+IHtcbiAgY2hpbGRyZW46XG4gICAgfCBSZWFjdC5SZWFjdE5vZGVcbiAgICB8ICgocHJvcHM6IHsgaXNBY3RpdmU6IGJvb2xlYW4gfSkgPT4gUmVhY3QuUmVhY3ROb2RlKTtcbiAgY2FzZVNlbnNpdGl2ZT86IGJvb2xlYW47XG4gIGNsYXNzTmFtZT86IHN0cmluZyB8ICgocHJvcHM6IHsgaXNBY3RpdmU6IGJvb2xlYW4gfSkgPT4gc3RyaW5nIHwgdW5kZWZpbmVkKTtcbiAgZW5kPzogYm9vbGVhbjtcbiAgc3R5bGU/OlxuICAgIHwgUmVhY3QuQ1NTUHJvcGVydGllc1xuICAgIHwgKChwcm9wczogeyBpc0FjdGl2ZTogYm9vbGVhbiB9KSA9PiBSZWFjdC5DU1NQcm9wZXJ0aWVzKTtcbn1cblxuLyoqXG4gKiBBIDxMaW5rPiB3cmFwcGVyIHRoYXQga25vd3MgaWYgaXQncyBcImFjdGl2ZVwiIG9yIG5vdC5cbiAqL1xuZXhwb3J0IGNvbnN0IE5hdkxpbmsgPSBSZWFjdC5mb3J3YXJkUmVmPEhUTUxBbmNob3JFbGVtZW50LCBOYXZMaW5rUHJvcHM+KFxuICBmdW5jdGlvbiBOYXZMaW5rV2l0aFJlZihcbiAgICB7XG4gICAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudFByb3AgPSBcInBhZ2VcIixcbiAgICAgIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lUHJvcCA9IFwiXCIsXG4gICAgICBlbmQgPSBmYWxzZSxcbiAgICAgIHN0eWxlOiBzdHlsZVByb3AsXG4gICAgICB0byxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgLi4ucmVzdFxuICAgIH0sXG4gICAgcmVmXG4gICkge1xuICAgIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gICAgbGV0IHBhdGggPSB1c2VSZXNvbHZlZFBhdGgodG8pO1xuXG4gICAgbGV0IGxvY2F0aW9uUGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICBsZXQgdG9QYXRobmFtZSA9IHBhdGgucGF0aG5hbWU7XG4gICAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgICBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdG9QYXRobmFtZSA9IHRvUGF0aG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBsZXQgaXNBY3RpdmUgPVxuICAgICAgbG9jYXRpb25QYXRobmFtZSA9PT0gdG9QYXRobmFtZSB8fFxuICAgICAgKCFlbmQgJiZcbiAgICAgICAgbG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmXG4gICAgICAgIGxvY2F0aW9uUGF0aG5hbWUuY2hhckF0KHRvUGF0aG5hbWUubGVuZ3RoKSA9PT0gXCIvXCIpO1xuXG4gICAgbGV0IGFyaWFDdXJyZW50ID0gaXNBY3RpdmUgPyBhcmlhQ3VycmVudFByb3AgOiB1bmRlZmluZWQ7XG5cbiAgICBsZXQgY2xhc3NOYW1lOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiBjbGFzc05hbWVQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVByb3AoeyBpc0FjdGl2ZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGNsYXNzTmFtZSBwcm9wIGlzIG5vdCBhIGZ1bmN0aW9uLCB3ZSB1c2UgYSBkZWZhdWx0IGBhY3RpdmVgXG4gICAgICAvLyBjbGFzcyBmb3IgPE5hdkxpbmsgLz5zIHRoYXQgYXJlIGFjdGl2ZS4gSW4gdjUgYGFjdGl2ZWAgd2FzIHRoZSBkZWZhdWx0XG4gICAgICAvLyB2YWx1ZSBmb3IgYGFjdGl2ZUNsYXNzTmFtZWAsIGJ1dCB3ZSBhcmUgcmVtb3ZpbmcgdGhhdCBBUEkgYW5kIGNhbiBzdGlsbFxuICAgICAgLy8gdXNlIHRoZSBvbGQgZGVmYXVsdCBiZWhhdmlvciBmb3IgYSBjbGVhbmVyIHVwZ3JhZGUgcGF0aCBhbmQga2VlcCB0aGVcbiAgICAgIC8vIHNpbXBsZSBzdHlsaW5nIHJ1bGVzIHdvcmtpbmcgYXMgdGhleSBjdXJyZW50bHkgZG8uXG4gICAgICBjbGFzc05hbWUgPSBbY2xhc3NOYW1lUHJvcCwgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbF1cbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbihcIiBcIik7XG4gICAgfVxuXG4gICAgbGV0IHN0eWxlID1cbiAgICAgIHR5cGVvZiBzdHlsZVByb3AgPT09IFwiZnVuY3Rpb25cIiA/IHN0eWxlUHJvcCh7IGlzQWN0aXZlIH0pIDogc3R5bGVQcm9wO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxMaW5rXG4gICAgICAgIHsuLi5yZXN0fVxuICAgICAgICBhcmlhLWN1cnJlbnQ9e2FyaWFDdXJyZW50fVxuICAgICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgICAgcmVmPXtyZWZ9XG4gICAgICAgIHN0eWxlPXtzdHlsZX1cbiAgICAgICAgdG89e3RvfVxuICAgICAgPlxuICAgICAgICB7dHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbih7IGlzQWN0aXZlIH0pIDogY2hpbGRyZW59XG4gICAgICA8L0xpbms+XG4gICAgKTtcbiAgfVxuKTtcblxuaWYgKF9fREVWX18pIHtcbiAgTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSE9PS1Ncbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogSGFuZGxlcyB0aGUgY2xpY2sgYmVoYXZpb3IgZm9yIHJvdXRlciBgPExpbms+YCBjb21wb25lbnRzLiBUaGlzIGlzIHVzZWZ1bCBpZlxuICogeW91IG5lZWQgdG8gY3JlYXRlIGN1c3RvbSBgPExpbms+YCBjb21wb25lbnRzIHdpdGggdGhlIHNhbWUgY2xpY2sgYmVoYXZpb3Igd2VcbiAqIHVzZSBpbiBvdXIgZXhwb3J0ZWQgYDxMaW5rPmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaW5rQ2xpY2tIYW5kbGVyPEUgZXh0ZW5kcyBFbGVtZW50ID0gSFRNTEFuY2hvckVsZW1lbnQ+KFxuICB0bzogVG8sXG4gIHtcbiAgICB0YXJnZXQsXG4gICAgcmVwbGFjZTogcmVwbGFjZVByb3AsXG4gICAgc3RhdGUsXG4gIH06IHtcbiAgICB0YXJnZXQ/OiBSZWFjdC5IVE1MQXR0cmlidXRlQW5jaG9yVGFyZ2V0O1xuICAgIHJlcGxhY2U/OiBib29sZWFuO1xuICAgIHN0YXRlPzogYW55O1xuICB9ID0ge31cbik6IChldmVudDogUmVhY3QuTW91c2VFdmVudDxFLCBNb3VzZUV2ZW50PikgPT4gdm9pZCB7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvKTtcblxuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEUsIE1vdXNlRXZlbnQ+KSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAvLyBJZ25vcmUgZXZlcnl0aGluZyBidXQgbGVmdCBjbGlja3NcbiAgICAgICAgKCF0YXJnZXQgfHwgdGFyZ2V0ID09PSBcIl9zZWxmXCIpICYmIC8vIExldCBicm93c2VyIGhhbmRsZSBcInRhcmdldD1fYmxhbmtcIiBldGMuXG4gICAgICAgICFpc01vZGlmaWVkRXZlbnQoZXZlbnQpIC8vIElnbm9yZSBjbGlja3Mgd2l0aCBtb2RpZmllciBrZXlzXG4gICAgICApIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBJZiB0aGUgVVJMIGhhc24ndCBjaGFuZ2VkLCBhIHJlZ3VsYXIgPGE+IHdpbGwgZG8gYSByZXBsYWNlIGluc3RlYWQgb2ZcbiAgICAgICAgLy8gYSBwdXNoLCBzbyBkbyB0aGUgc2FtZSBoZXJlLlxuICAgICAgICBsZXQgcmVwbGFjZSA9XG4gICAgICAgICAgISFyZXBsYWNlUHJvcCB8fCBjcmVhdGVQYXRoKGxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChwYXRoKTtcblxuICAgICAgICBuYXZpZ2F0ZSh0bywgeyByZXBsYWNlLCBzdGF0ZSB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFtsb2NhdGlvbiwgbmF2aWdhdGUsIHBhdGgsIHJlcGxhY2VQcm9wLCBzdGF0ZSwgdGFyZ2V0LCB0b11cbiAgKTtcbn1cblxuLyoqXG4gKiBBIGNvbnZlbmllbnQgd3JhcHBlciBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBzZWFyY2ggcGFyYW1ldGVycyB2aWEgdGhlXG4gKiBVUkxTZWFyY2hQYXJhbXMgaW50ZXJmYWNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zKGRlZmF1bHRJbml0PzogVVJMU2VhcmNoUGFyYW1zSW5pdCkge1xuICB3YXJuaW5nKFxuICAgIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09IFwidW5kZWZpbmVkXCIsXG4gICAgYFlvdSBjYW5ub3QgdXNlIHRoZSBcXGB1c2VTZWFyY2hQYXJhbXNcXGAgaG9vayBpbiBhIGJyb3dzZXIgdGhhdCBkb2VzIG5vdCBgICtcbiAgICAgIGBzdXBwb3J0IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJLiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IEludGVybmV0IGAgK1xuICAgICAgYEV4cGxvcmVyIDExLCB3ZSByZWNvbW1lbmQgeW91IGxvYWQgYSBwb2x5ZmlsbCBzdWNoIGFzIGAgK1xuICAgICAgYGh0dHBzOi8vZ2l0aHViLmNvbS91bmdhcC91cmwtc2VhcmNoLXBhcmFtc1xcblxcbmAgK1xuICAgICAgYElmIHlvdSdyZSB1bnN1cmUgaG93IHRvIGxvYWQgcG9seWZpbGxzLCB3ZSByZWNvbW1lbmQgeW91IGNoZWNrIG91dCBgICtcbiAgICAgIGBodHRwczovL3BvbHlmaWxsLmlvL3YzLyB3aGljaCBwcm92aWRlcyBzb21lIHJlY29tbWVuZGF0aW9ucyBhYm91dCBob3cgYCArXG4gICAgICBgdG8gbG9hZCBwb2x5ZmlsbHMgb25seSBmb3IgdXNlcnMgdGhhdCBuZWVkIHRoZW0sIGluc3RlYWQgb2YgZm9yIGV2ZXJ5IGAgK1xuICAgICAgYHVzZXIuYFxuICApO1xuXG4gIGxldCBkZWZhdWx0U2VhcmNoUGFyYW1zUmVmID0gUmVhY3QudXNlUmVmKGNyZWF0ZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkpO1xuXG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgc2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKGxvY2F0aW9uLnNlYXJjaCk7XG5cbiAgICBmb3IgKGxldCBrZXkgb2YgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50LmtleXMoKSkge1xuICAgICAgaWYgKCFzZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50LmdldEFsbChrZXkpLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbiAgfSwgW2xvY2F0aW9uLnNlYXJjaF0pO1xuXG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBzZXRTZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoXG4gICAgICBuZXh0SW5pdDogVVJMU2VhcmNoUGFyYW1zSW5pdCxcbiAgICAgIG5hdmlnYXRlT3B0aW9ucz86IHsgcmVwbGFjZT86IGJvb2xlYW47IHN0YXRlPzogYW55IH1cbiAgICApID0+IHtcbiAgICAgIG5hdmlnYXRlKFwiP1wiICsgY3JlYXRlU2VhcmNoUGFyYW1zKG5leHRJbml0KSwgbmF2aWdhdGVPcHRpb25zKTtcbiAgICB9LFxuICAgIFtuYXZpZ2F0ZV1cbiAgKTtcblxuICByZXR1cm4gW3NlYXJjaFBhcmFtcywgc2V0U2VhcmNoUGFyYW1zXSBhcyBjb25zdDtcbn1cblxuZXhwb3J0IHR5cGUgUGFyYW1LZXlWYWx1ZVBhaXIgPSBbc3RyaW5nLCBzdHJpbmddO1xuXG5leHBvcnQgdHlwZSBVUkxTZWFyY2hQYXJhbXNJbml0ID1cbiAgfCBzdHJpbmdcbiAgfCBQYXJhbUtleVZhbHVlUGFpcltdXG4gIHwgUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgc3RyaW5nW10+XG4gIHwgVVJMU2VhcmNoUGFyYW1zO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBpbml0aWFsaXplci5cbiAqXG4gKiBUaGlzIGlzIGlkZW50aWNhbCB0byBgbmV3IFVSTFNlYXJjaFBhcmFtcyhpbml0KWAgZXhjZXB0IGl0IGFsc29cbiAqIHN1cHBvcnRzIGFycmF5cyBhcyB2YWx1ZXMgaW4gdGhlIG9iamVjdCBmb3JtIG9mIHRoZSBpbml0aWFsaXplclxuICogaW5zdGVhZCBvZiBqdXN0IHN0cmluZ3MuIFRoaXMgaXMgY29udmVuaWVudCB3aGVuIHlvdSBuZWVkIG11bHRpcGxlXG4gKiB2YWx1ZXMgZm9yIGEgZ2l2ZW4ga2V5LCBidXQgZG9uJ3Qgd2FudCB0byB1c2UgYW4gYXJyYXkgaW5pdGlhbGl6ZXIuXG4gKlxuICogRm9yIGV4YW1wbGUsIGluc3RlYWQgb2Y6XG4gKlxuICogICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gKiAgICAgWydzb3J0JywgJ25hbWUnXSxcbiAqICAgICBbJ3NvcnQnLCAncHJpY2UnXVxuICogICBdKTtcbiAqXG4gKiB5b3UgY2FuIGRvOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyh7XG4gKiAgICAgc29ydDogWyduYW1lJywgJ3ByaWNlJ11cbiAqICAgfSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTZWFyY2hQYXJhbXMoXG4gIGluaXQ6IFVSTFNlYXJjaFBhcmFtc0luaXQgPSBcIlwiXG4pOiBVUkxTZWFyY2hQYXJhbXMge1xuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyhcbiAgICB0eXBlb2YgaW5pdCA9PT0gXCJzdHJpbmdcIiB8fFxuICAgIEFycmF5LmlzQXJyYXkoaW5pdCkgfHxcbiAgICBpbml0IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zXG4gICAgICA/IGluaXRcbiAgICAgIDogT2JqZWN0LmtleXMoaW5pdCkucmVkdWNlKChtZW1vLCBrZXkpID0+IHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBpbml0W2tleV07XG4gICAgICAgICAgcmV0dXJuIG1lbW8uY29uY2F0KFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAoKHYpID0+IFtrZXksIHZdKSA6IFtba2V5LCB2YWx1ZV1dXG4gICAgICAgICAgKTtcbiAgICAgICAgfSwgW10gYXMgUGFyYW1LZXlWYWx1ZVBhaXJbXSlcbiAgKTtcbn1cbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4zXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbi8qKlxuICogVGhlIG1vZGUgdG8gdXNlIHdoZW4gcnVubmluZyB0aGUgc2VydmVyLlxuICovXG5sZXQgU2VydmVyTW9kZTtcblxuKGZ1bmN0aW9uIChTZXJ2ZXJNb2RlKSB7XG4gIFNlcnZlck1vZGVbXCJEZXZlbG9wbWVudFwiXSA9IFwiZGV2ZWxvcG1lbnRcIjtcbiAgU2VydmVyTW9kZVtcIlByb2R1Y3Rpb25cIl0gPSBcInByb2R1Y3Rpb25cIjtcbiAgU2VydmVyTW9kZVtcIlRlc3RcIl0gPSBcInRlc3RcIjtcbn0pKFNlcnZlck1vZGUgfHwgKFNlcnZlck1vZGUgPSB7fSkpO1xuXG5mdW5jdGlvbiBpc1NlcnZlck1vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBTZXJ2ZXJNb2RlLkRldmVsb3BtZW50IHx8IHZhbHVlID09PSBTZXJ2ZXJNb2RlLlByb2R1Y3Rpb24gfHwgdmFsdWUgPT09IFNlcnZlck1vZGUuVGVzdDtcbn1cblxuZXhwb3J0IHsgU2VydmVyTW9kZSwgaXNTZXJ2ZXJNb2RlIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3NlcnZlci1ydW50aW1lIHYxLjIuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vLyBOT1RFOiBtYWtlIHN1cmUgdG8gY2hhbmdlIHRoZSBSb3V0ZSBpbiByZW1peC1yZWFjdCBpZiB5b3UgY2hhbmdlIHRoaXNcbi8vIE5PVEU6IG1ha2Ugc3VyZSB0byBjaGFuZ2UgdGhlIEVudHJ5Um91dGUgaW4gcmVtaXgtcmVhY3QgaWYgeW91IGNoYW5nZSB0aGlzXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXMobWFuaWZlc3QsIHBhcmVudElkKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhtYW5pZmVzdCkuZmlsdGVyKGtleSA9PiBtYW5pZmVzdFtrZXldLnBhcmVudElkID09PSBwYXJlbnRJZCkubWFwKGlkID0+ICh7IC4uLm1hbmlmZXN0W2lkXSxcbiAgICBjaGlsZHJlbjogY3JlYXRlUm91dGVzKG1hbmlmZXN0LCBpZClcbiAgfSkpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVSb3V0ZXMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUgdjEuMi4zXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCBqc2VzYyBmcm9tICdqc2VzYyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcoc2VydmVySGFuZG9mZikge1xuICAvLyBVc2UganNlc2MgdG8gZXNjYXBlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgbG9hZGVycy4gVGhpcyBzdHJpbmcgaXNcbiAgLy8gaW5zZXJ0ZWQgZGlyZWN0bHkgaW50byB0aGUgSFRNTCBpbiB0aGUgYDxTY3JpcHRzPmAgZWxlbWVudC5cbiAgcmV0dXJuIGpzZXNjKHNlcnZlckhhbmRvZmYsIHtcbiAgICBpc1NjcmlwdENvbnRleHQ6IHRydWVcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVNlcnZlckhhbmRvZmZTdHJpbmcgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyB2MS4yLjNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgY3JlYXRlUmVxdWVzdEhhbmRsZXIgYXMgY3JlYXRlUmVxdWVzdEhhbmRsZXIkMSB9IGZyb20gJ0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUnO1xuXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0SGFuZGxlcih7XG4gIGJ1aWxkLFxuICBnZXRMb2FkQ29udGV4dCxcbiAgbW9kZVxufSkge1xuICBsZXQgcGxhdGZvcm0gPSB7fTtcbiAgbGV0IGhhbmRsZVJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0SGFuZGxlciQxKGJ1aWxkLCBwbGF0Zm9ybSwgbW9kZSk7XG4gIHJldHVybiBjb250ZXh0ID0+IHtcbiAgICBsZXQgbG9hZENvbnRleHQgPSB0eXBlb2YgZ2V0TG9hZENvbnRleHQgPT09IFwiZnVuY3Rpb25cIiA/IGdldExvYWRDb250ZXh0KGNvbnRleHQpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiBoYW5kbGVSZXF1ZXN0KGNvbnRleHQucmVxdWVzdCwgbG9hZENvbnRleHQpO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGFnZXNGdW5jdGlvbkhhbmRsZXIoe1xuICBidWlsZCxcbiAgZ2V0TG9hZENvbnRleHQsXG4gIG1vZGVcbn0pIHtcbiAgY29uc3QgaGFuZGxlUmVxdWVzdCA9IGNyZWF0ZVJlcXVlc3RIYW5kbGVyKHtcbiAgICBidWlsZCxcbiAgICBnZXRMb2FkQ29udGV4dCxcbiAgICBtb2RlXG4gIH0pO1xuXG4gIGNvbnN0IGhhbmRsZUZldGNoID0gYXN5bmMgY29udGV4dCA9PiB7XG4gICAgbGV0IHJlc3BvbnNlOyAvLyBodHRwczovL2dpdGh1Yi5jb20vY2xvdWRmbGFyZS93cmFuZ2xlcjIvaXNzdWVzLzExN1xuXG4gICAgY29udGV4dC5yZXF1ZXN0LmhlYWRlcnMuZGVsZXRlKFwiaWYtbm9uZS1tYXRjaFwiKTtcblxuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGNvbnRleHQuZW52LkFTU0VUUy5mZXRjaChjb250ZXh0LnJlcXVlc3QudXJsLCBjb250ZXh0LnJlcXVlc3QuY2xvbmUoKSk7XG4gICAgICByZXNwb25zZSA9IHJlc3BvbnNlICYmIHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgNDAwID8gbmV3IFJlc3BvbnNlKHJlc3BvbnNlLmJvZHksIHJlc3BvbnNlKSA6IHVuZGVmaW5lZDtcbiAgICB9IGNhdGNoIHt9XG5cbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IGhhbmRsZVJlcXVlc3QoY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xuXG4gIHJldHVybiBhc3luYyBjb250ZXh0ID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGhhbmRsZUZldGNoKGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiICYmIGUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGUubWVzc2FnZSB8fCBlLnRvU3RyaW5nKCksIHtcbiAgICAgICAgICBzdGF0dXM6IDUwMFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShcIkludGVybmFsIEVycm9yXCIsIHtcbiAgICAgICAgc3RhdHVzOiA1MDBcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlUGFnZXNGdW5jdGlvbkhhbmRsZXIsIGNyZWF0ZVJlcXVlc3RIYW5kbGVyIH07XG4iLCAiXG5pbXBvcnQgKiBhcyBlbnRyeVNlcnZlciBmcm9tIFwiL1VzZXJzL2RlbmlzLmZldGluaW4vZGV2L3BvcnRmb2xpby9hcHAvZW50cnkuc2VydmVyLnRzeFwiO1xuaW1wb3J0ICogYXMgcm91dGUwIGZyb20gXCIvVXNlcnMvZGVuaXMuZmV0aW5pbi9kZXYvcG9ydGZvbGlvL2FwcC9yb290LnRzeFwiO1xuaW1wb3J0ICogYXMgcm91dGUxIGZyb20gXCIvVXNlcnMvZGVuaXMuZmV0aW5pbi9kZXYvcG9ydGZvbGlvL2FwcC9yb3V0ZXMvaW5kZXgudHN4XCI7XG4gIGV4cG9ydCB7IGRlZmF1bHQgYXMgYXNzZXRzIH0gZnJvbSBcIkByZW1peC1ydW4vZGV2L2Fzc2V0cy1tYW5pZmVzdFwiO1xuICBleHBvcnQgY29uc3QgZW50cnkgPSB7IG1vZHVsZTogZW50cnlTZXJ2ZXIgfTtcbiAgZXhwb3J0IGNvbnN0IHJvdXRlcyA9IHtcbiAgICBcInJvb3RcIjoge1xuICAgICAgaWQ6IFwicm9vdFwiLFxuICAgICAgcGFyZW50SWQ6IHVuZGVmaW5lZCxcbiAgICAgIHBhdGg6IFwiXCIsXG4gICAgICBpbmRleDogdW5kZWZpbmVkLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogdW5kZWZpbmVkLFxuICAgICAgbW9kdWxlOiByb3V0ZTBcbiAgICB9LFxuICBcInJvdXRlcy9pbmRleFwiOiB7XG4gICAgICBpZDogXCJyb3V0ZXMvaW5kZXhcIixcbiAgICAgIHBhcmVudElkOiBcInJvb3RcIixcbiAgICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICAgIGluZGV4OiB0cnVlLFxuICAgICAgY2FzZVNlbnNpdGl2ZTogdW5kZWZpbmVkLFxuICAgICAgbW9kdWxlOiByb3V0ZTFcbiAgICB9XG4gIH07IiwgImltcG9ydCB7IHJlbmRlclRvU3RyaW5nIH0gZnJvbSBcInJlYWN0LWRvbS9zZXJ2ZXJcIjtcbmltcG9ydCB7IFJlbWl4U2VydmVyIH0gZnJvbSBcInJlbWl4XCI7XG5pbXBvcnQgdHlwZSB7IEVudHJ5Q29udGV4dCB9IGZyb20gXCJyZW1peFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0KFxuICByZXF1ZXN0OiBSZXF1ZXN0LFxuICByZXNwb25zZVN0YXR1c0NvZGU6IG51bWJlcixcbiAgcmVzcG9uc2VIZWFkZXJzOiBIZWFkZXJzLFxuICByZW1peENvbnRleHQ6IEVudHJ5Q29udGV4dFxuKSB7XG4gIGNvbnN0IG1hcmt1cCA9IHJlbmRlclRvU3RyaW5nKFxuICAgIDxSZW1peFNlcnZlciBjb250ZXh0PXtyZW1peENvbnRleHR9IHVybD17cmVxdWVzdC51cmx9IC8+XG4gICk7XG5cbiAgcmVzcG9uc2VIZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcInRleHQvaHRtbFwiKTtcblxuICByZXR1cm4gbmV3IFJlc3BvbnNlKFwiPCFET0NUWVBFIGh0bWw+XCIgKyBtYXJrdXAsIHtcbiAgICBzdGF0dXM6IHJlc3BvbnNlU3RhdHVzQ29kZSxcbiAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gIH0pO1xufVxuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9jbG91ZGZsYXJlLXBhZ2VzIHYxLjIuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5leHBvcnQgeyBjcmVhdGVDbG91ZGZsYXJlS1ZTZXNzaW9uU3RvcmFnZSB9IGZyb20gJ0ByZW1peC1ydW4vY2xvdWRmbGFyZS1wYWdlcyc7XG5cbi8qKlxuICogQHJlbWl4LXJ1bi9zZXJ2ZXItcnVudGltZSB2MS4yLjNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuZXhwb3J0IHsgY3JlYXRlQ29va2llLCBjcmVhdGVDb29raWVTZXNzaW9uU3RvcmFnZSwgY3JlYXRlTWVtb3J5U2Vzc2lvblN0b3JhZ2UsIGNyZWF0ZVNlc3Npb24sIGNyZWF0ZVNlc3Npb25TdG9yYWdlLCBpc0Nvb2tpZSwgaXNTZXNzaW9uLCBqc29uLCByZWRpcmVjdCB9IGZyb20gJ0ByZW1peC1ydW4vc2VydmVyLXJ1bnRpbWUnO1xuXG4vKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4zXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmV4cG9ydCB7IEZvcm0sIExpbmssIExpbmtzLCBMaXZlUmVsb2FkLCBNZXRhLCBOYXZMaW5rLCBPdXRsZXQsIFByZWZldGNoUGFnZUxpbmtzLCBSZW1peEJyb3dzZXIsIFJlbWl4U2VydmVyLCBTY3JpcHRzLCBTY3JvbGxSZXN0b3JhdGlvbiwgdXNlQWN0aW9uRGF0YSwgdXNlQmVmb3JlVW5sb2FkLCB1c2VDYXRjaCwgdXNlRmV0Y2hlciwgdXNlRmV0Y2hlcnMsIHVzZUZvcm1BY3Rpb24sIHVzZUhyZWYsIHVzZUxvYWRlckRhdGEsIHVzZUxvY2F0aW9uLCB1c2VNYXRjaGVzLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVNlYXJjaFBhcmFtcywgdXNlU3VibWl0LCB1c2VUcmFuc2l0aW9uIH0gZnJvbSAnQHJlbWl4LXJ1bi9yZWFjdCc7XG5cbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4zXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmV4cG9ydCB7IFJlbWl4QnJvd3NlciB9IGZyb20gJy4vYnJvd3Nlci5qcyc7XG5leHBvcnQgeyBPdXRsZXQsIHVzZUhyZWYsIHVzZUxvY2F0aW9uLCB1c2VOYXZpZ2F0ZSwgdXNlTmF2aWdhdGlvblR5cGUsIHVzZU91dGxldCwgdXNlT3V0bGV0Q29udGV4dCwgdXNlUGFyYW1zLCB1c2VSZXNvbHZlZFBhdGgsIHVzZVNlYXJjaFBhcmFtcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuZXhwb3J0IHsgRm9ybSwgTGluaywgTGlua3MsIExpdmVSZWxvYWQsIE1ldGEsIE5hdkxpbmssIFByZWZldGNoUGFnZUxpbmtzLCBTY3JpcHRzLCB1c2VBY3Rpb25EYXRhLCB1c2VCZWZvcmVVbmxvYWQsIHVzZUZldGNoZXIsIHVzZUZldGNoZXJzLCB1c2VGb3JtQWN0aW9uLCB1c2VMb2FkZXJEYXRhLCB1c2VNYXRjaGVzLCB1c2VTdWJtaXQsIHVzZVRyYW5zaXRpb24gfSBmcm9tICcuL2NvbXBvbmVudHMuanMnO1xuZXhwb3J0IHsgdXNlQ2F0Y2ggfSBmcm9tICcuL2Vycm9yQm91bmRhcmllcy5qcyc7XG5leHBvcnQgeyBTY3JvbGxSZXN0b3JhdGlvbiB9IGZyb20gJy4vc2Nyb2xsLXJlc3RvcmF0aW9uLmpzJztcbmV4cG9ydCB7IFJlbWl4U2VydmVyIH0gZnJvbSAnLi9zZXJ2ZXIuanMnO1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgZXh0ZW5kcyBhcyBfZXh0ZW5kcyB9IGZyb20gJy4vX3ZpcnR1YWwvX3JvbGx1cFBsdWdpbkJhYmVsSGVscGVycy5qcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VIcmVmLCBOYXZMaW5rIGFzIE5hdkxpbmskMSwgTGluayBhcyBMaW5rJDEsIHVzZUxvY2F0aW9uLCB1c2VSZXNvbHZlZFBhdGgsIHVzZU5hdmlnYXRlLCBSb3V0ZXIsIHVzZVJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuaW1wb3J0IHsgUmVtaXhFcnJvckJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSwgUmVtaXhDYXRjaEJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSB9IGZyb20gJy4vZXJyb3JCb3VuZGFyaWVzLmpzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnLi9pbnZhcmlhbnQuanMnO1xuaW1wb3J0IHsgZ2V0TGlua3NGb3JNYXRjaGVzLCBpc1BhZ2VMaW5rRGVzY3JpcHRvciwgZ2V0TmV3TWF0Y2hlc0ZvckxpbmtzLCBnZXREYXRhTGlua0hyZWZzLCBnZXRNb2R1bGVMaW5rSHJlZnMsIGdldFN0eWxlc2hlZXRQcmVmZXRjaExpbmtzIH0gZnJvbSAnLi9saW5rcy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIdG1sIH0gZnJvbSAnLi9tYXJrdXAuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2xpZW50Um91dGVzIH0gZnJvbSAnLi9yb3V0ZXMuanMnO1xuaW1wb3J0IHsgbWF0Y2hDbGllbnRSb3V0ZXMgfSBmcm9tICcuL3JvdXRlTWF0Y2hpbmcuanMnO1xuaW1wb3J0IHsgY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgfSBmcm9tICcuL3RyYW5zaXRpb24uanMnO1xuXG5jb25zdCBSZW1peEVudHJ5Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5cbmZ1bmN0aW9uIHVzZVJlbWl4RW50cnlDb250ZXh0KCkge1xuICBsZXQgY29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoUmVtaXhFbnRyeUNvbnRleHQpO1xuICBpbnZhcmlhbnQoY29udGV4dCwgXCJZb3UgbXVzdCByZW5kZXIgdGhpcyBlbGVtZW50IGluc2lkZSBhIDxSZW1peD4gZWxlbWVudFwiKTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIFJlbWl4RW50cnkoe1xuICBjb250ZXh0OiBlbnRyeUNvbnRleHQsXG4gIGFjdGlvbixcbiAgbG9jYXRpb246IGhpc3RvcnlMb2NhdGlvbixcbiAgbmF2aWdhdG9yOiBfbmF2aWdhdG9yLFxuICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZVxufSkge1xuICBsZXQge1xuICAgIG1hbmlmZXN0LFxuICAgIHJvdXRlRGF0YTogZG9jdW1lbnRMb2FkZXJEYXRhLFxuICAgIGFjdGlvbkRhdGE6IGRvY3VtZW50QWN0aW9uRGF0YSxcbiAgICByb3V0ZU1vZHVsZXMsXG4gICAgc2VydmVySGFuZG9mZlN0cmluZyxcbiAgICBhcHBTdGF0ZTogZW50cnlDb21wb25lbnREaWRDYXRjaEVtdWxhdG9yXG4gIH0gPSBlbnRyeUNvbnRleHQ7XG4gIGxldCBjbGllbnRSb3V0ZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGNyZWF0ZUNsaWVudFJvdXRlcyhtYW5pZmVzdC5yb3V0ZXMsIHJvdXRlTW9kdWxlcywgUmVtaXhSb3V0ZSksIFttYW5pZmVzdCwgcm91dGVNb2R1bGVzXSk7XG4gIGxldCBbY2xpZW50U3RhdGUsIHNldENsaWVudFN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGVudHJ5Q29tcG9uZW50RGlkQ2F0Y2hFbXVsYXRvcik7XG4gIGxldCBbdHJhbnNpdGlvbk1hbmFnZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcih7XG4gICAgICByb3V0ZXM6IGNsaWVudFJvdXRlcyxcbiAgICAgIGFjdGlvbkRhdGE6IGRvY3VtZW50QWN0aW9uRGF0YSxcbiAgICAgIGxvYWRlckRhdGE6IGRvY3VtZW50TG9hZGVyRGF0YSxcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5TG9jYXRpb24sXG4gICAgICBjYXRjaDogZW50cnlDb21wb25lbnREaWRDYXRjaEVtdWxhdG9yLmNhdGNoLFxuICAgICAgY2F0Y2hCb3VuZGFyeUlkOiBlbnRyeUNvbXBvbmVudERpZENhdGNoRW11bGF0b3IuY2F0Y2hCb3VuZGFyeVJvdXRlSWQsXG4gICAgICBvblJlZGlyZWN0OiBfbmF2aWdhdG9yLnJlcGxhY2UsXG4gICAgICBvbkNoYW5nZTogc3RhdGUgPT4ge1xuICAgICAgICBzZXRDbGllbnRTdGF0ZSh7XG4gICAgICAgICAgY2F0Y2g6IHN0YXRlLmNhdGNoLFxuICAgICAgICAgIGVycm9yOiBzdGF0ZS5lcnJvcixcbiAgICAgICAgICBjYXRjaEJvdW5kYXJ5Um91dGVJZDogc3RhdGUuY2F0Y2hCb3VuZGFyeUlkLFxuICAgICAgICAgIGxvYWRlckJvdW5kYXJ5Um91dGVJZDogc3RhdGUuZXJyb3JCb3VuZGFyeUlkLFxuICAgICAgICAgIHJlbmRlckJvdW5kYXJ5Um91dGVJZDogbnVsbCxcbiAgICAgICAgICB0cmFja0JvdW5kYXJpZXM6IGZhbHNlLFxuICAgICAgICAgIHRyYWNrQ2F0Y2hCb3VuZGFyaWVzOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7IC8vIEVuc3VyZXMgcHVzaGVzIGludGVycnVwdGluZyBwZW5kaW5nIG5hdmlnYXRpb25zIHVzZSByZXBsYWNlXG4gIC8vIFRPRE86IE1vdmUgdGhpcyB0byBSZWFjdCBSb3V0ZXJcblxuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHB1c2ggPSAodG8sIHN0YXRlKSA9PiB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKS50cmFuc2l0aW9uLnN0YXRlICE9PSBcImlkbGVcIiA/IF9uYXZpZ2F0b3IucmVwbGFjZSh0bywgc3RhdGUpIDogX25hdmlnYXRvci5wdXNoKHRvLCBzdGF0ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7IC4uLl9uYXZpZ2F0b3IsXG4gICAgICBwdXNoXG4gICAgfTtcbiAgfSwgW19uYXZpZ2F0b3IsIHRyYW5zaXRpb25NYW5hZ2VyXSk7XG4gIGxldCB7XG4gICAgbG9jYXRpb24sXG4gICAgbWF0Y2hlcyxcbiAgICBsb2FkZXJEYXRhLFxuICAgIGFjdGlvbkRhdGFcbiAgfSA9IHRyYW5zaXRpb25NYW5hZ2VyLmdldFN0YXRlKCk7IC8vIFNlbmQgbmV3IGxvY2F0aW9uIHRvIHRoZSB0cmFuc2l0aW9uIG1hbmFnZXJcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB7XG4gICAgICBsb2NhdGlvblxuICAgIH0gPSB0cmFuc2l0aW9uTWFuYWdlci5nZXRTdGF0ZSgpO1xuICAgIGlmIChoaXN0b3J5TG9jYXRpb24gPT09IGxvY2F0aW9uKSByZXR1cm47XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuc2VuZCh7XG4gICAgICB0eXBlOiBcIm5hdmlnYXRpb25cIixcbiAgICAgIGxvY2F0aW9uOiBoaXN0b3J5TG9jYXRpb24sXG4gICAgICBzdWJtaXNzaW9uOiBjb25zdW1lTmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uKCksXG4gICAgICBhY3Rpb25cbiAgICB9KTtcbiAgfSwgW3RyYW5zaXRpb25NYW5hZ2VyLCBoaXN0b3J5TG9jYXRpb24sIGFjdGlvbl0pOyAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoZSBhcHAgdGhyZXcgYmVmb3JlIHJlbmRlcmluZyBhbnlcbiAgLy8gcm91dGVzLCBnZXQgdGhlIGVycm9yIGFuZCBwYXNzIGl0IHRvIHRoZSBFcnJvckJvdW5kYXJ5IHRvIGVtdWxhdGVcbiAgLy8gYGNvbXBvbmVudERpZENhdGNoYFxuXG4gIGxldCBzc3JFcnJvckJlZm9yZVJvdXRlc1JlbmRlcmVkID0gY2xpZW50U3RhdGUuZXJyb3IgJiYgY2xpZW50U3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID09PSBudWxsICYmIGNsaWVudFN0YXRlLmxvYWRlckJvdW5kYXJ5Um91dGVJZCA9PT0gbnVsbCA/IGRlc2VyaWFsaXplRXJyb3IoY2xpZW50U3RhdGUuZXJyb3IpIDogdW5kZWZpbmVkO1xuICBsZXQgc3NyQ2F0Y2hCZWZvcmVSb3V0ZXNSZW5kZXJlZCA9IGNsaWVudFN0YXRlLmNhdGNoICYmIGNsaWVudFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID09PSBudWxsID8gY2xpZW50U3RhdGUuY2F0Y2ggOiB1bmRlZmluZWQ7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVudHJ5Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB7XG4gICAgICBtYXRjaGVzLFxuICAgICAgbWFuaWZlc3QsXG4gICAgICBhcHBTdGF0ZTogY2xpZW50U3RhdGUsXG4gICAgICByb3V0ZU1vZHVsZXMsXG4gICAgICBzZXJ2ZXJIYW5kb2ZmU3RyaW5nLFxuICAgICAgY2xpZW50Um91dGVzLFxuICAgICAgcm91dGVEYXRhOiBsb2FkZXJEYXRhLFxuICAgICAgYWN0aW9uRGF0YSxcbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVycm9yQm91bmRhcnksIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY29tcG9uZW50OiBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSxcbiAgICBlcnJvcjogc3NyRXJyb3JCZWZvcmVSb3V0ZXNSZW5kZXJlZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peENhdGNoQm91bmRhcnksIHtcbiAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgY29tcG9uZW50OiBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSxcbiAgICBjYXRjaDogc3NyQ2F0Y2hCZWZvcmVSb3V0ZXNSZW5kZXJlZFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBuYXZpZ2F0aW9uVHlwZTogYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICBuYXZpZ2F0b3I6IG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3BcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVzLCBudWxsKSkpKSk7XG59XG5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplRXJyb3IoZGF0YSkge1xuICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgZXJyb3Iuc3RhY2sgPSBkYXRhLnN0YWNrO1xuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIFJvdXRlcygpIHtcbiAgLy8gVE9ETzogQWRkIGByZW5kZXJNYXRjaGVzYCBmdW5jdGlvbiB0byBSUiB0aGF0IHdlIGNhbiB1c2UgYW5kIHRoZW4gd2UgZG9uJ3RcbiAgLy8gbmVlZCB0aGlzIGNvbXBvbmVudCwgd2UgY2FuIGp1c3QgYHJlbmRlck1hdGNoZXNgIGZyb20gUmVtaXhFbnRyeVxuICBsZXQge1xuICAgIGNsaWVudFJvdXRlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTsgLy8gZmFsbGJhY2sgdG8gdGhlIHJvb3QgaWYgd2UgZG9uJ3QgaGF2ZSBhIG1hdGNoXG5cbiAgbGV0IGVsZW1lbnQgPSB1c2VSb3V0ZXMoY2xpZW50Um91dGVzKSB8fCBjbGllbnRSb3V0ZXNbMF0uZWxlbWVudDtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBSZW1peFJvdXRlXG5cblxuY29uc3QgUmVtaXhSb3V0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xuXG5mdW5jdGlvbiB1c2VSZW1peFJvdXRlQ29udGV4dCgpIHtcbiAgbGV0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFJlbWl4Um91dGVDb250ZXh0KTtcbiAgaW52YXJpYW50KGNvbnRleHQsIFwiWW91IG11c3QgcmVuZGVyIHRoaXMgZWxlbWVudCBpbiBhIHJlbWl4IHJvdXRlIGVsZW1lbnRcIik7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBEZWZhdWx0Um91dGVDb21wb25lbnQoe1xuICBpZFxufSkge1xuICB0aHJvdyBuZXcgRXJyb3IoYFJvdXRlIFwiJHtpZH1cIiBoYXMgbm8gY29tcG9uZW50ISBQbGVhc2UgZ28gYWRkIGEgXFxgZGVmYXVsdFxcYCBleHBvcnQgaW4gdGhlIHJvdXRlIG1vZHVsZSBmaWxlLlxcbmAgKyBcIklmIHlvdSB3ZXJlIHRyeWluZyB0byBuYXZpZ2F0ZSBvciBzdWJtaXQgdG8gYSByZXNvdXJjZSByb3V0ZSwgdXNlIGA8YT5gIGluc3RlYWQgb2YgYDxMaW5rPmAgb3IgYDxGb3JtIHJlbG9hZERvY3VtZW50PmAuXCIpO1xufVxuXG5mdW5jdGlvbiBSZW1peFJvdXRlKHtcbiAgaWRcbn0pIHtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHtcbiAgICByb3V0ZURhdGEsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIGFwcFN0YXRlXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgZGF0YSA9IHJvdXRlRGF0YVtpZF07XG4gIGxldCB7XG4gICAgZGVmYXVsdDogQ29tcG9uZW50LFxuICAgIENhdGNoQm91bmRhcnksXG4gICAgRXJyb3JCb3VuZGFyeVxuICB9ID0gcm91dGVNb2R1bGVzW2lkXTtcbiAgbGV0IGVsZW1lbnQgPSBDb21wb25lbnQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIG51bGwpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVmYXVsdFJvdXRlQ29tcG9uZW50LCB7XG4gICAgaWQ6IGlkXG4gIH0pO1xuICBsZXQgY29udGV4dCA9IHtcbiAgICBkYXRhLFxuICAgIGlkXG4gIH07XG5cbiAgaWYgKENhdGNoQm91bmRhcnkpIHtcbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoaXMgcm91dGUgdGhyZXcgdGhlIGVycm9yLCBmaW5kIGl0XG4gICAgLy8gYW5kIHBhc3MgaXQgdG8gdGhlIEVycm9yQm91bmRhcnkgdG8gZW11bGF0ZSBgY29tcG9uZW50RGlkQ2F0Y2hgXG4gICAgbGV0IG1heWJlU2VydmVyQ2F1Z2h0ID0gYXBwU3RhdGUuY2F0Y2ggJiYgYXBwU3RhdGUuY2F0Y2hCb3VuZGFyeVJvdXRlSWQgPT09IGlkID8gYXBwU3RhdGUuY2F0Y2ggOiB1bmRlZmluZWQ7IC8vIFRoaXMgbmVlZHMgdG8gcnVuIGFmdGVyIHdlIGNoZWNrIGZvciB0aGUgZXJyb3IgZnJvbSBhIHByZXZpb3VzIHJlbmRlcixcbiAgICAvLyBvdGhlcndpc2Ugd2Ugd2lsbCBpbmNvcnJlY3RseSByZW5kZXIgdGhpcyBib3VuZGFyeSBmb3IgYSBsb2FkZXIgZXJyb3JcbiAgICAvLyBkZWVwZXIgaW4gdGhlIHRyZWUuXG5cbiAgICBpZiAoYXBwU3RhdGUudHJhY2tDYXRjaEJvdW5kYXJpZXMpIHtcbiAgICAgIGFwcFN0YXRlLmNhdGNoQm91bmRhcnlSb3V0ZUlkID0gaWQ7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IG1heWJlU2VydmVyQ2F1Z2h0ID8ge1xuICAgICAgaWQsXG5cbiAgICAgIGdldCBkYXRhKCkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiWW91IGNhbm5vdCBgdXNlTG9hZGVyRGF0YWAgaW4gYSBjYXRjaCBib3VuZGFyeS5cIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IDoge1xuICAgICAgaWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICBlbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhDYXRjaEJvdW5kYXJ5LCB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBjb21wb25lbnQ6IENhdGNoQm91bmRhcnksXG4gICAgICBjYXRjaDogbWF5YmVTZXJ2ZXJDYXVnaHRcbiAgICB9LCBlbGVtZW50KTtcbiAgfSAvLyBPbmx5IHdyYXAgaW4gZXJyb3IgYm91bmRhcnkgaWYgdGhlIHJvdXRlIGRlZmluZWQgb25lLCBvdGhlcndpc2UgbGV0IHRoZVxuICAvLyBlcnJvciBidWJibGUgdG8gdGhlIHBhcmVudCBib3VuZGFyeS4gV2UgY291bGQgZGVmYXVsdCB0byB1c2luZyBlcnJvclxuICAvLyBib3VuZGFyaWVzIGFyb3VuZCBldmVyeSByb3V0ZSwgYnV0IG5vdyBpZiB0aGUgYXBwIGRvZXNuJ3Qgd2FudCB1c2Vyc1xuICAvLyBzZWVpbmcgdGhlIGRlZmF1bHQgUmVtaXggRXJyb3JCb3VuZGFyeSBjb21wb25lbnQsIHRoZXkgKm11c3QqIGRlZmluZSBhblxuICAvLyBlcnJvciBib3VuZGFyeSBmb3IgKmV2ZXJ5KiByb3V0ZSBhbmQgdGhhdCB3b3VsZCBiZSBhbm5veWluZy4gTWlnaHQgYXNcbiAgLy8gd2VsbCBtYWtlIGl0IHJlcXVpcmVkIGF0IHRoYXQgcG9pbnQuXG4gIC8vXG4gIC8vIEJ5IGNvbmRpdGlvbmFsbHkgd3JhcHBpbmcgbGlrZSB0aGlzLCB3ZSBhbGxvdyBhcHBzIHRvIGRlZmluZSBhIHRvcCBsZXZlbFxuICAvLyBFcnJvckJvdW5kYXJ5IGNvbXBvbmVudCBhbmQgYmUgZG9uZSB3aXRoIGl0LiBUaGVuLCBpZiB0aGV5IHdhbnQgdG8sIHRoZXlcbiAgLy8gY2FuIGFkZCBtb3JlIHNwZWNpZmljIGJvdW5kYXJpZXMgYnkgZXhwb3J0aW5nIEVycm9yQm91bmRhcnkgY29tcG9uZW50c1xuICAvLyBmb3Igd2hpY2hldmVyIHJvdXRlcyB0aGV5IHBsZWFzZS5cbiAgLy9cbiAgLy8gTk9URTogdGhpcyBraW5kIG9mIGxvZ2ljIHdpbGwgbW92ZSBpbnRvIFJlYWN0IFJvdXRlclxuXG5cbiAgaWYgKEVycm9yQm91bmRhcnkpIHtcbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZW5kZXIgYW5kIGZhaWxlZCwgYW5kIHRoaXMgcm91dGUgdGhyZXcgdGhlIGVycm9yLCBmaW5kIGl0XG4gICAgLy8gYW5kIHBhc3MgaXQgdG8gdGhlIEVycm9yQm91bmRhcnkgdG8gZW11bGF0ZSBgY29tcG9uZW50RGlkQ2F0Y2hgXG4gICAgbGV0IG1heWJlU2VydmVyUmVuZGVyRXJyb3IgPSBhcHBTdGF0ZS5lcnJvciAmJiAoYXBwU3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID09PSBpZCB8fCBhcHBTdGF0ZS5sb2FkZXJCb3VuZGFyeVJvdXRlSWQgPT09IGlkKSA/IGRlc2VyaWFsaXplRXJyb3IoYXBwU3RhdGUuZXJyb3IpIDogdW5kZWZpbmVkOyAvLyBUaGlzIG5lZWRzIHRvIHJ1biBhZnRlciB3ZSBjaGVjayBmb3IgdGhlIGVycm9yIGZyb20gYSBwcmV2aW91cyByZW5kZXIsXG4gICAgLy8gb3RoZXJ3aXNlIHdlIHdpbGwgaW5jb3JyZWN0bHkgcmVuZGVyIHRoaXMgYm91bmRhcnkgZm9yIGEgbG9hZGVyIGVycm9yXG4gICAgLy8gZGVlcGVyIGluIHRoZSB0cmVlLlxuXG4gICAgaWYgKGFwcFN0YXRlLnRyYWNrQm91bmRhcmllcykge1xuICAgICAgYXBwU3RhdGUucmVuZGVyQm91bmRhcnlSb3V0ZUlkID0gaWQ7XG4gICAgfVxuXG4gICAgY29udGV4dCA9IG1heWJlU2VydmVyUmVuZGVyRXJyb3IgPyB7XG4gICAgICBpZCxcblxuICAgICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgY2Fubm90IGB1c2VMb2FkZXJEYXRhYCBpbiBhbiBlcnJvciBib3VuZGFyeS5cIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IDoge1xuICAgICAgaWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICBlbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhFcnJvckJvdW5kYXJ5LCB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICBjb21wb25lbnQ6IEVycm9yQm91bmRhcnksXG4gICAgICBlcnJvcjogbWF5YmVTZXJ2ZXJSZW5kZXJFcnJvclxuICAgIH0sIGVsZW1lbnQpO1xuICB9IC8vIEl0J3MgaW1wb3J0YW50IGZvciB0aGUgcm91dGUgY29udGV4dCB0byBiZSBhYm92ZSB0aGUgZXJyb3IgYm91bmRhcnkgc28gdGhhdFxuICAvLyBhIGNhbGwgdG8gYHVzZUxvYWRlckRhdGFgIGRvZXNuJ3QgYWNjaWRlbnRhbGx5IGdldCB0aGUgcGFyZW50cyByb3V0ZSdzIGRhdGEuXG5cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVtaXhSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCBlbGVtZW50KTtcbn0gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFB1YmxpYyBBUElcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBwcmVmZXRjaGluZyBiZWhhdmlvciBvZiB0aGUgbGluazpcbiAqXG4gKiAtIFwiaW50ZW50XCI6IEZldGNoZWQgd2hlbiB0aGUgdXNlciBmb2N1c2VzIG9yIGhvdmVycyB0aGUgbGlua1xuICogLSBcInJlbmRlclwiOiBGZXRjaGVkIHdoZW4gdGhlIGxpbmsgaXMgcmVuZGVyZWRcbiAqIC0gXCJub25lXCI6IE5ldmVyIGZldGNoZWRcbiAqL1xuXG5mdW5jdGlvbiB1c2VQcmVmZXRjaEJlaGF2aW9yKHByZWZldGNoLCB0aGVpckVsZW1lbnRQcm9wcykge1xuICBsZXQgW21heWJlUHJlZmV0Y2gsIHNldE1heWJlUHJlZmV0Y2hdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBzZXRTaG91bGRQcmVmZXRjaF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGxldCB7XG4gICAgb25Gb2N1cyxcbiAgICBvbkJsdXIsXG4gICAgb25Nb3VzZUVudGVyLFxuICAgIG9uTW91c2VMZWF2ZSxcbiAgICBvblRvdWNoU3RhcnRcbiAgfSA9IHRoZWlyRWxlbWVudFByb3BzO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJyZW5kZXJcIikge1xuICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgfVxuICB9LCBbcHJlZmV0Y2hdKTtcblxuICBsZXQgc2V0SW50ZW50ID0gKCkgPT4ge1xuICAgIGlmIChwcmVmZXRjaCA9PT0gXCJpbnRlbnRcIikge1xuICAgICAgc2V0TWF5YmVQcmVmZXRjaCh0cnVlKTtcbiAgICB9XG4gIH07XG5cbiAgbGV0IGNhbmNlbEludGVudCA9ICgpID0+IHtcbiAgICBpZiAocHJlZmV0Y2ggPT09IFwiaW50ZW50XCIpIHtcbiAgICAgIHNldE1heWJlUHJlZmV0Y2goZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChtYXliZVByZWZldGNoKSB7XG4gICAgICBsZXQgaWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgc2V0U2hvdWxkUHJlZmV0Y2godHJ1ZSk7XG4gICAgICB9LCAxMDApO1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbbWF5YmVQcmVmZXRjaF0pO1xuICByZXR1cm4gW3Nob3VsZFByZWZldGNoLCB7XG4gICAgb25Gb2N1czogY29tcG9zZUV2ZW50SGFuZGxlcnMob25Gb2N1cywgc2V0SW50ZW50KSxcbiAgICBvbkJsdXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uQmx1ciwgY2FuY2VsSW50ZW50KSxcbiAgICBvbk1vdXNlRW50ZXI6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VFbnRlciwgc2V0SW50ZW50KSxcbiAgICBvbk1vdXNlTGVhdmU6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uTW91c2VMZWF2ZSwgY2FuY2VsSW50ZW50KSxcbiAgICBvblRvdWNoU3RhcnQ6IGNvbXBvc2VFdmVudEhhbmRsZXJzKG9uVG91Y2hTdGFydCwgc2V0SW50ZW50KVxuICB9XTtcbn1cbi8qKlxuICogQSBzcGVjaWFsIGtpbmQgb2YgYDxMaW5rPmAgdGhhdCBrbm93cyB3aGV0aGVyIG9yIG5vdCBpdCBpcyBcImFjdGl2ZVwiLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I25hdmxpbmtcbiAqL1xuXG5cbmxldCBOYXZMaW5rID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgdG8sXG4gIHByZWZldGNoID0gXCJub25lXCIsXG4gIC4uLnByb3BzXG59LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgbGV0IGhyZWYgPSB1c2VIcmVmKHRvKTtcbiAgbGV0IFtzaG91bGRQcmVmZXRjaCwgcHJlZmV0Y2hIYW5kbGVyc10gPSB1c2VQcmVmZXRjaEJlaGF2aW9yKHByZWZldGNoLCBwcm9wcyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTmF2TGluayQxLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBmb3J3YXJkZWRSZWYsXG4gICAgdG86IHRvXG4gIH0sIHByb3BzLCBwcmVmZXRjaEhhbmRsZXJzKSksIHNob3VsZFByZWZldGNoID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUHJlZmV0Y2hQYWdlTGlua3MsIHtcbiAgICBwYWdlOiBocmVmXG4gIH0pIDogbnVsbCk7XG59KTtcbk5hdkxpbmsuZGlzcGxheU5hbWUgPSBcIk5hdkxpbmtcIjtcbi8qKlxuICogVGhpcyBjb21wb25lbnQgcmVuZGVycyBhbiBhbmNob3IgdGFnIGFuZCBpcyB0aGUgcHJpbWFyeSB3YXkgdGhlIHVzZXIgd2lsbFxuICogbmF2aWdhdGUgYXJvdW5kIHlvdXIgd2Vic2l0ZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNsaW5rXG4gKi9cblxubGV0IExpbmsgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoe1xuICB0byxcbiAgcHJlZmV0Y2ggPSBcIm5vbmVcIixcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRlZFJlZikgPT4ge1xuICBsZXQgaHJlZiA9IHVzZUhyZWYodG8pO1xuICBsZXQgW3Nob3VsZFByZWZldGNoLCBwcmVmZXRjaEhhbmRsZXJzXSA9IHVzZVByZWZldGNoQmVoYXZpb3IocHJlZmV0Y2gsIHByb3BzKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMaW5rJDEsIF9leHRlbmRzKHtcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICB0bzogdG9cbiAgfSwgcHJvcHMsIHByZWZldGNoSGFuZGxlcnMpKSwgc2hvdWxkUHJlZmV0Y2ggPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rcywge1xuICAgIHBhZ2U6IGhyZWZcbiAgfSkgOiBudWxsKTtcbn0pO1xuTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xuZnVuY3Rpb24gY29tcG9zZUV2ZW50SGFuZGxlcnModGhlaXJIYW5kbGVyLCBvdXJIYW5kbGVyKSB7XG4gIHJldHVybiBldmVudCA9PiB7XG4gICAgdGhlaXJIYW5kbGVyICYmIHRoZWlySGFuZGxlcihldmVudCk7XG5cbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIG91ckhhbmRsZXIoZXZlbnQpO1xuICAgIH1cbiAgfTtcbn1cbi8qKlxuICogUmVuZGVycyB0aGUgYDxsaW5rPmAgdGFncyBmb3IgdGhlIGN1cnJlbnQgcm91dGVzLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I21ldGEtbGlua3Mtc2NyaXB0c1xuICovXG5cbmZ1bmN0aW9uIExpbmtzKCkge1xuICBsZXQge1xuICAgIG1hdGNoZXMsXG4gICAgcm91dGVNb2R1bGVzLFxuICAgIG1hbmlmZXN0XG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgbGlua3MgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldExpbmtzRm9yTWF0Y2hlcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMsIG1hbmlmZXN0KSwgW21hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3RdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBsaW5rcy5tYXAobGluayA9PiBpc1BhZ2VMaW5rRGVzY3JpcHRvcihsaW5rKSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFByZWZldGNoUGFnZUxpbmtzLCBfZXh0ZW5kcyh7XG4gICAga2V5OiBsaW5rLnBhZ2VcbiAgfSwgbGluaykpIDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIsIF9leHRlbmRzKHtcbiAgICBrZXk6IGxpbmsucmVsICsgbGluay5ocmVmXG4gIH0sIGxpbmspKSkpO1xufVxuLyoqXG4gKiBUaGlzIGNvbXBvbmVudCByZW5kZXJzIGFsbCBvZiB0aGUgYDxsaW5rIHJlbD1cInByZWZldGNoXCI+YCBhbmRcbiAqIGA8bGluayByZWw9XCJtb2R1bGVwcmVsb2FkXCIvPmAgdGFncyBmb3IgYWxsIHRoZSBhc3NldHMgKGRhdGEsIG1vZHVsZXMsIGNzcykgb2ZcbiAqIGEgZ2l2ZW4gcGFnZS5cbiAqXG4gKiBAcGFyYW0gcHJvcHNcbiAqIEBwYXJhbSBwcm9wcy5wYWdlXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNwcmVmZXRjaHBhZ2VsaW5rcy1cbiAqL1xuXG5mdW5jdGlvbiBQcmVmZXRjaFBhZ2VMaW5rcyh7XG4gIHBhZ2UsXG4gIC4uLmRhdGFMaW5rUHJvcHNcbn0pIHtcbiAgbGV0IHtcbiAgICBjbGllbnRSb3V0ZXNcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCBtYXRjaGVzID0gUmVhY3QudXNlTWVtbygoKSA9PiBtYXRjaENsaWVudFJvdXRlcyhjbGllbnRSb3V0ZXMsIHBhZ2UpLCBbY2xpZW50Um91dGVzLCBwYWdlXSk7XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgY29uc29sZS53YXJuKGBUcmllZCB0byBwcmVmZXRjaCAke3BhZ2V9IGJ1dCBubyByb3V0ZXMgbWF0Y2hlZC5gKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQcmVmZXRjaFBhZ2VMaW5rc0ltcGwsIF9leHRlbmRzKHtcbiAgICBwYWdlOiBwYWdlLFxuICAgIG1hdGNoZXM6IG1hdGNoZXNcbiAgfSwgZGF0YUxpbmtQcm9wcykpO1xufVxuXG5mdW5jdGlvbiB1c2VQcmVmZXRjaGVkU3R5bGVzaGVldHMobWF0Y2hlcykge1xuICBsZXQge1xuICAgIHJvdXRlTW9kdWxlc1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IFtzdHlsZUxpbmtzLCBzZXRTdHlsZUxpbmtzXSA9IFJlYWN0LnVzZVN0YXRlKFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgaW50ZXJydXB0ZWQgPSBmYWxzZTtcbiAgICBnZXRTdHlsZXNoZWV0UHJlZmV0Y2hMaW5rcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMpLnRoZW4obGlua3MgPT4ge1xuICAgICAgaWYgKCFpbnRlcnJ1cHRlZCkgc2V0U3R5bGVMaW5rcyhsaW5rcyk7XG4gICAgfSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGludGVycnVwdGVkID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbbWF0Y2hlcywgcm91dGVNb2R1bGVzXSk7XG4gIHJldHVybiBzdHlsZUxpbmtzO1xufVxuXG5mdW5jdGlvbiBQcmVmZXRjaFBhZ2VMaW5rc0ltcGwoe1xuICBwYWdlLFxuICBtYXRjaGVzOiBuZXh0TWF0Y2hlcyxcbiAgLi4ubGlua1Byb3BzXG59KSB7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCB7XG4gICAgbWF0Y2hlcyxcbiAgICBtYW5pZmVzdFxuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgbGV0IG5ld01hdGNoZXNGb3JEYXRhID0gUmVhY3QudXNlTWVtbygoKSA9PiBnZXROZXdNYXRjaGVzRm9yTGlua3MocGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIGxvY2F0aW9uLCBcImRhdGFcIiksIFtwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbG9jYXRpb25dKTtcbiAgbGV0IG5ld01hdGNoZXNGb3JBc3NldHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldE5ld01hdGNoZXNGb3JMaW5rcyhwYWdlLCBuZXh0TWF0Y2hlcywgbWF0Y2hlcywgbG9jYXRpb24sIFwiYXNzZXRzXCIpLCBbcGFnZSwgbmV4dE1hdGNoZXMsIG1hdGNoZXMsIGxvY2F0aW9uXSk7XG4gIGxldCBkYXRhSHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldERhdGFMaW5rSHJlZnMocGFnZSwgbmV3TWF0Y2hlc0ZvckRhdGEsIG1hbmlmZXN0KSwgW25ld01hdGNoZXNGb3JEYXRhLCBwYWdlLCBtYW5pZmVzdF0pO1xuICBsZXQgbW9kdWxlSHJlZnMgPSBSZWFjdC51c2VNZW1vKCgpID0+IGdldE1vZHVsZUxpbmtIcmVmcyhuZXdNYXRjaGVzRm9yQXNzZXRzLCBtYW5pZmVzdCksIFtuZXdNYXRjaGVzRm9yQXNzZXRzLCBtYW5pZmVzdF0pOyAvLyBuZWVkcyB0byBiZSBhIGhvb2sgd2l0aCBhc3luYyBiZWhhdmlvciBiZWNhdXNlIHdlIG5lZWQgdGhlIG1vZHVsZXMsIG5vdFxuICAvLyBqdXN0IHRoZSBtYW5pZmVzdCBsaWtlIHRoZSBvdGhlciBsaW5rcyBpbiBoZXJlLlxuXG4gIGxldCBzdHlsZUxpbmtzID0gdXNlUHJlZmV0Y2hlZFN0eWxlc2hlZXRzKG5ld01hdGNoZXNGb3JBc3NldHMpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGRhdGFIcmVmcy5tYXAoaHJlZiA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgX2V4dGVuZHMoe1xuICAgIGtleTogaHJlZixcbiAgICByZWw6IFwicHJlZmV0Y2hcIixcbiAgICBhczogXCJmZXRjaFwiLFxuICAgIGhyZWY6IGhyZWZcbiAgfSwgbGlua1Byb3BzKSkpLCBtb2R1bGVIcmVmcy5tYXAoaHJlZiA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgX2V4dGVuZHMoe1xuICAgIGtleTogaHJlZixcbiAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgIGhyZWY6IGhyZWZcbiAgfSwgbGlua1Byb3BzKSkpLCBzdHlsZUxpbmtzLm1hcChsaW5rID0+XG4gIC8qI19fUFVSRV9fKi9cbiAgLy8gdGhlc2UgZG9uJ3Qgc3ByZWFkIGBsaW5rUHJvcHNgIGJlY2F1c2UgdGhleSBhcmUgZnVsbCBsaW5rIGRlc2NyaXB0b3JzXG4gIC8vIGFscmVhZHkgd2l0aCB0aGVpciBvd24gcHJvcHNcbiAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwgX2V4dGVuZHMoe1xuICAgIGtleTogbGluay5ocmVmXG4gIH0sIGxpbmspKSkpO1xufVxuLyoqXG4gKiBSZW5kZXJzIHRoZSBgPHRpdGxlPmAgYW5kIGA8bWV0YT5gIHRhZ3MgZm9yIHRoZSBjdXJyZW50IHJvdXRlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNtZXRhLWxpbmtzLXNjcmlwdHNcbiAqL1xuXG5cbmZ1bmN0aW9uIE1ldGEoKSB7XG4gIGxldCB7XG4gICAgbWF0Y2hlcyxcbiAgICByb3V0ZURhdGEsXG4gICAgcm91dGVNb2R1bGVzXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgbG9jYXRpb24gPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbWV0YSA9IHt9O1xuICBsZXQgcGFyZW50c0RhdGEgPSB7fTtcblxuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IHJvdXRlSWQgPSBtYXRjaC5yb3V0ZS5pZDtcbiAgICBsZXQgZGF0YSA9IHJvdXRlRGF0YVtyb3V0ZUlkXTtcbiAgICBsZXQgcGFyYW1zID0gbWF0Y2gucGFyYW1zO1xuICAgIGxldCByb3V0ZU1vZHVsZSA9IHJvdXRlTW9kdWxlc1tyb3V0ZUlkXTtcblxuICAgIGlmIChyb3V0ZU1vZHVsZS5tZXRhKSB7XG4gICAgICBsZXQgcm91dGVNZXRhID0gdHlwZW9mIHJvdXRlTW9kdWxlLm1ldGEgPT09IFwiZnVuY3Rpb25cIiA/IHJvdXRlTW9kdWxlLm1ldGEoe1xuICAgICAgICBkYXRhLFxuICAgICAgICBwYXJlbnRzRGF0YSxcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICBsb2NhdGlvblxuICAgICAgfSkgOiByb3V0ZU1vZHVsZS5tZXRhO1xuICAgICAgT2JqZWN0LmFzc2lnbihtZXRhLCByb3V0ZU1ldGEpO1xuICAgIH1cblxuICAgIHBhcmVudHNEYXRhW3JvdXRlSWRdID0gZGF0YTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgT2JqZWN0LmVudHJpZXMobWV0YSkubWFwKChbbmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgLy8gT3BlbiBHcmFwaCB0YWdzIHVzZSB0aGUgYHByb3BlcnR5YCBhdHRyaWJ1dGUsIHdoaWxlIG90aGVyIG1ldGEgdGFnc1xuICAgIC8vIHVzZSBgbmFtZWAuIFNlZSBodHRwczovL29ncC5tZS9cbiAgICBsZXQgaXNPcGVuR3JhcGhUYWcgPSBuYW1lLnN0YXJ0c1dpdGgoXCJvZzpcIik7XG4gICAgcmV0dXJuIG5hbWUgPT09IFwidGl0bGVcIiA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwidGl0bGVcIiwge1xuICAgICAga2V5OiBcInRpdGxlXCJcbiAgICB9LCB2YWx1ZSkgOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcChjb250ZW50ID0+IGlzT3BlbkdyYXBoVGFnID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICAgIGtleTogbmFtZSArIGNvbnRlbnQsXG4gICAgICBwcm9wZXJ0eTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KSA6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICBrZXk6IG5hbWUgKyBjb250ZW50LFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KSkgOiBpc09wZW5HcmFwaFRhZyA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgICBrZXk6IG5hbWUsXG4gICAgICBwcm9wZXJ0eTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IHZhbHVlXG4gICAgfSkgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgICAga2V5OiBuYW1lLFxuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGNvbnRlbnQ6IHZhbHVlXG4gICAgfSk7XG4gIH0pKTtcbn1cbi8qKlxuICogVHJhY2tzIHdoZXRoZXIgUmVtaXggaGFzIGZpbmlzaGVkIGh5ZHJhdGluZyBvciBub3QsIHNvIHNjcmlwdHMgY2FuIGJlIHNraXBwZWRcbiAqIGR1cmluZyBjbGllbnQtc2lkZSB1cGRhdGVzLlxuICovXG5cbmxldCBpc0h5ZHJhdGVkID0gZmFsc2U7XG5cbi8qKlxuICogUmVuZGVycyB0aGUgYDxzY3JpcHQ+YCB0YWdzIG5lZWRlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLiBCdW5kbGVzIGZvclxuICogYWRkaXRpb25hbCByb3V0ZXMgYXJlIGxvYWRlZCBsYXRlciBhcyBuZWVkZWQuXG4gKlxuICogQHBhcmFtIHByb3BzIEFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBhZGQgdG8gZWFjaCBzY3JpcHQgdGFnIHRoYXQgaXMgcmVuZGVyZWQuXG4gKiBJbiBhZGRpdGlvbiB0byBzY3JpcHRzLCBcXDxsaW5rIHJlbD1cIm1vZHVsZXByZWxvYWRcIj4gdGFncyByZWNlaXZlIHRoZSBjcm9zc09yaWdpblxuICogcHJvcGVydHkgaWYgcHJvdmlkZWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjbWV0YS1saW5rcy1zY3JpcHRzXG4gKi9cbmZ1bmN0aW9uIFNjcmlwdHMocHJvcHMpIHtcbiAgbGV0IHtcbiAgICBtYW5pZmVzdCxcbiAgICBtYXRjaGVzLFxuICAgIHBlbmRpbmdMb2NhdGlvbixcbiAgICBjbGllbnRSb3V0ZXMsXG4gICAgc2VydmVySGFuZG9mZlN0cmluZ1xuICB9ID0gdXNlUmVtaXhFbnRyeUNvbnRleHQoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpc0h5ZHJhdGVkID0gdHJ1ZTtcbiAgfSwgW10pO1xuICBsZXQgaW5pdGlhbFNjcmlwdHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgY29udGV4dFNjcmlwdCA9IHNlcnZlckhhbmRvZmZTdHJpbmcgPyBgd2luZG93Ll9fcmVtaXhDb250ZXh0ID0gJHtzZXJ2ZXJIYW5kb2ZmU3RyaW5nfTtgIDogXCJcIjtcbiAgICBsZXQgcm91dGVNb2R1bGVzU2NyaXB0ID0gYCR7bWF0Y2hlcy5tYXAoKG1hdGNoLCBpbmRleCkgPT4gYGltcG9ydCAqIGFzIHJvdXRlJHtpbmRleH0gZnJvbSAke0pTT04uc3RyaW5naWZ5KG1hbmlmZXN0LnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF0ubW9kdWxlKX07YCkuam9pbihcIlxcblwiKX1cbndpbmRvdy5fX3JlbWl4Um91dGVNb2R1bGVzID0geyR7bWF0Y2hlcy5tYXAoKG1hdGNoLCBpbmRleCkgPT4gYCR7SlNPTi5zdHJpbmdpZnkobWF0Y2gucm91dGUuaWQpfTpyb3V0ZSR7aW5kZXh9YCkuam9pbihcIixcIil9fTtgO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogY3JlYXRlSHRtbChjb250ZXh0U2NyaXB0KVxuICAgIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBzcmM6IG1hbmlmZXN0LnVybFxuICAgIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDogY3JlYXRlSHRtbChyb3V0ZU1vZHVsZXNTY3JpcHQpLFxuICAgICAgdHlwZTogXCJtb2R1bGVcIlxuICAgIH0pKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgICBzcmM6IG1hbmlmZXN0LmVudHJ5Lm1vZHVsZSxcbiAgICAgIHR5cGU6IFwibW9kdWxlXCJcbiAgICB9KSkpOyAvLyBkaXNhYmxlZCBkZXBzIGFycmF5IGJlY2F1c2Ugd2UgYXJlIHB1cnBvc2VmdWxseSBvbmx5IHJlbmRlcmluZyB0aGlzIG9uY2VcbiAgICAvLyBmb3IgaHlkcmF0aW9uLCBhZnRlciB0aGF0IHdlIHdhbnQgdG8ganVzdCBjb250aW51ZSByZW5kZXJpbmcgdGhlIGluaXRpYWxcbiAgICAvLyBzY3JpcHRzIGFzIHRoZXkgd2VyZSB3aGVuIHRoZSBwYWdlIGZpcnN0IGxvYWRlZFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICB9LCBbXSk7IC8vIGF2b2lkIHdhdGVyZmFsbCB3aGVuIGltcG9ydGluZyB0aGUgbmV4dCByb3V0ZSBtb2R1bGVcblxuICBsZXQgbmV4dE1hdGNoZXMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocGVuZGluZ0xvY2F0aW9uKSB7XG4gICAgICAvLyBGSVhNRTogY2FuIHByb2JhYmx5IHVzZSB0cmFuc2l0aW9uTWFuYWdlciBgbmV4dE1hdGNoZXNgXG4gICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoQ2xpZW50Um91dGVzKGNsaWVudFJvdXRlcywgcGVuZGluZ0xvY2F0aW9uKTtcbiAgICAgIGludmFyaWFudChtYXRjaGVzLCBgTm8gcm91dGVzIG1hdGNoIHBhdGggXCIke3BlbmRpbmdMb2NhdGlvbi5wYXRobmFtZX1cImApO1xuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIFtdO1xuICB9LCBbcGVuZGluZ0xvY2F0aW9uLCBjbGllbnRSb3V0ZXNdKTtcbiAgbGV0IHJvdXRlUHJlbG9hZHMgPSBtYXRjaGVzLmNvbmNhdChuZXh0TWF0Y2hlcykubWFwKG1hdGNoID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIHJldHVybiAocm91dGUuaW1wb3J0cyB8fCBbXSkuY29uY2F0KFtyb3V0ZS5tb2R1bGVdKTtcbiAgfSkuZmxhdCgxKTtcbiAgbGV0IHByZWxvYWRzID0gbWFuaWZlc3QuZW50cnkuaW1wb3J0cy5jb25jYXQocm91dGVQcmVsb2Fkcyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgZGVkdXBlKHByZWxvYWRzKS5tYXAocGF0aCA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmtcIiwge1xuICAgIGtleTogcGF0aCxcbiAgICByZWw6IFwibW9kdWxlcHJlbG9hZFwiLFxuICAgIGhyZWY6IHBhdGgsXG4gICAgY3Jvc3NPcmlnaW46IHByb3BzLmNyb3NzT3JpZ2luXG4gIH0pKSwgaXNIeWRyYXRlZCA/IG51bGwgOiBpbml0aWFsU2NyaXB0cyk7XG59XG5cbmZ1bmN0aW9uIGRlZHVwZShhcnJheSkge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoYXJyYXkpXTtcbn1cblxuLyoqXG4gKiBBIFJlbWl4LWF3YXJlIGA8Zm9ybT5gLiBJdCBiZWhhdmVzIGxpa2UgYSBub3JtYWwgZm9ybSBleGNlcHQgdGhhdCB0aGVcbiAqIGludGVyYWN0aW9uIHdpdGggdGhlIHNlcnZlciBpcyB3aXRoIGBmZXRjaGAgaW5zdGVhZCBvZiBuZXcgZG9jdW1lbnRcbiAqIHJlcXVlc3RzLCBhbGxvd2luZyBjb21wb25lbnRzIHRvIGFkZCBuaWNlciBVWCB0byB0aGUgcGFnZSBhcyB0aGUgZm9ybSBpc1xuICogc3VibWl0dGVkIGFuZCByZXR1cm5zIHdpdGggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNmb3JtXG4gKi9cbmxldCBGb3JtID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm1JbXBsLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICByZWY6IHJlZlxuICB9KSk7XG59KTtcbkZvcm0uZGlzcGxheU5hbWUgPSBcIkZvcm1cIjtcbmxldCBGb3JtSW1wbCA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIHJlbG9hZERvY3VtZW50ID0gZmFsc2UsXG4gIHJlcGxhY2UgPSBmYWxzZSxcbiAgbWV0aG9kID0gXCJnZXRcIixcbiAgYWN0aW9uID0gXCIuXCIsXG4gIGVuY1R5cGUgPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICBmZXRjaEtleSxcbiAgb25TdWJtaXQsXG4gIC4uLnByb3BzXG59LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdEltcGwoZmV0Y2hLZXkpO1xuICBsZXQgZm9ybU1ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBcImdldFwiID8gXCJnZXRcIiA6IFwicG9zdFwiO1xuICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCBmb3JtTWV0aG9kKTtcbiAgbGV0IGZvcm1SZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgbGV0IHJlZiA9IHVzZUNvbXBvc2VkUmVmcyhmb3J3YXJkZWRSZWYsIGZvcm1SZWYpOyAvLyBXaGVuIGNhbGxpbmcgYHN1Ym1pdGAgb24gdGhlIGZvcm0gZWxlbWVudCBpdHNlbGYsIHdlIGRvbid0IGdldCBkYXRhIGZyb21cbiAgLy8gdGhlIGJ1dHRvbiB0aGF0IHN1Ym1pdHRlZCB0aGUgZXZlbnQuIEZvciBleGFtcGxlOlxuICAvL1xuICAvLyAgIDxGb3JtPlxuICAvLyAgICAgPGJ1dHRvbiBuYW1lPVwic29tZXRoaW5nXCIgdmFsdWU9XCJ3aGF0ZXZlclwiPlN1Ym1pdDwvYnV0dG9uPlxuICAvLyAgIDwvRm9ybT5cbiAgLy9cbiAgLy8gZm9ybURhdGEuZ2V0KFwic29tZXRoaW5nXCIpIHNob3VsZCBiZSBcIndoYXRldmVyXCIsIGJ1dCB3ZSBkb24ndCBnZXQgdGhhdFxuICAvLyB1bmxlc3Mgd2UgY2FsbCBzdWJtaXQgb24gdGhlIGNsaWNrZWQgYnV0dG9uIGl0c2VsZi5cbiAgLy9cbiAgLy8gVG8gZmlndXJlIG91dCB3aGljaCBidXR0b24gdHJpZ2dlcmVkIHRoZSBzdWJtaXQsIHdlJ2xsIGF0dGFjaCBhIGNsaWNrXG4gIC8vIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBmb3JtLiBUaGUgY2xpY2sgZXZlbnQgaXMgYWx3YXlzIHRyaWdnZXJlZCBiZWZvcmVcbiAgLy8gdGhlIHN1Ym1pdCBldmVudCAoZXZlbiB3aGVuIHN1Ym1pdHRpbmcgdmlhIGtleWJvYXJkIHdoZW4gZm9jdXNlZCBvblxuICAvLyBhbm90aGVyIGZvcm0gZmllbGQsIHllZWVlZXQpIHNvIHdlIHNob3VsZCBoYXZlIGFjY2VzcyB0byB0aGF0IGJ1dHRvbidzXG4gIC8vIGRhdGEgZm9yIHVzZSBpbiB0aGUgc3VibWl0IGhhbmRsZXIuXG5cbiAgbGV0IGNsaWNrZWRCdXR0b25SZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBsZXQgZm9ybSA9IGZvcm1SZWYuY3VycmVudDtcbiAgICBpZiAoIWZvcm0pIHJldHVybjtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgICBpZiAoIShldmVudC50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkgcmV0dXJuO1xuICAgICAgbGV0IHN1Ym1pdEJ1dHRvbiA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KFwiYnV0dG9uLGlucHV0W3R5cGU9c3VibWl0XVwiKTtcblxuICAgICAgaWYgKHN1Ym1pdEJ1dHRvbiAmJiBzdWJtaXRCdXR0b24uZm9ybSA9PT0gZm9ybSAmJiBzdWJtaXRCdXR0b24udHlwZSA9PT0gXCJzdWJtaXRcIikge1xuICAgICAgICBjbGlja2VkQnV0dG9uUmVmLmN1cnJlbnQgPSBzdWJtaXRCdXR0b247XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBoYW5kbGVDbGljayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaGFuZGxlQ2xpY2spO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiByZWYsXG4gICAgbWV0aG9kOiBmb3JtTWV0aG9kLFxuICAgIGFjdGlvbjogZm9ybUFjdGlvbixcbiAgICBlbmNUeXBlOiBlbmNUeXBlLFxuICAgIG9uU3VibWl0OiByZWxvYWREb2N1bWVudCA/IHVuZGVmaW5lZCA6IGV2ZW50ID0+IHtcbiAgICAgIG9uU3VibWl0ICYmIG9uU3VibWl0KGV2ZW50KTtcbiAgICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc3VibWl0KGNsaWNrZWRCdXR0b25SZWYuY3VycmVudCB8fCBldmVudC5jdXJyZW50VGFyZ2V0LCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcmVwbGFjZVxuICAgICAgfSk7XG4gICAgICBjbGlja2VkQnV0dG9uUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgcHJvcHMpKTtcbn0pO1xuRm9ybUltcGwuZGlzcGxheU5hbWUgPSBcIkZvcm1JbXBsXCI7XG5cbmZ1bmN0aW9uIGlzQWN0aW9uUmVxdWVzdE1ldGhvZChtZXRob2QpIHtcbiAgbWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBtZXRob2QgPT09IFwicG9zdFwiIHx8IG1ldGhvZCA9PT0gXCJwdXRcIiB8fCBtZXRob2QgPT09IFwicGF0Y2hcIiB8fCBtZXRob2QgPT09IFwiZGVsZXRlXCI7XG59XG4vKipcbiAqIFJlc29sdmVzIGEgYDxmb3JtIGFjdGlvbj5gIHBhdGggcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcm91dGUuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjdXNlZm9ybWFjdGlvblxuICovXG5cblxuZnVuY3Rpb24gdXNlRm9ybUFjdGlvbihhY3Rpb24gPSBcIi5cIiwgbWV0aG9kID0gXCJnZXRcIikge1xuICBsZXQge1xuICAgIGlkXG4gIH0gPSB1c2VSZW1peFJvdXRlQ29udGV4dCgpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aChhY3Rpb24pO1xuICBsZXQgc2VhcmNoID0gcGF0aC5zZWFyY2g7XG4gIGxldCBpc0luZGV4Um91dGUgPSBpZC5lbmRzV2l0aChcIi9pbmRleFwiKTtcblxuICBpZiAoYWN0aW9uID09PSBcIi5cIiAmJiBpc0luZGV4Um91dGUgJiYgaXNBY3Rpb25SZXF1ZXN0TWV0aG9kKG1ldGhvZCkpIHtcbiAgICBzZWFyY2ggPSBzZWFyY2ggPyBzZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKSA6IFwiP2luZGV4XCI7XG4gIH1cblxuICByZXR1cm4gcGF0aC5wYXRobmFtZSArIHNlYXJjaDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBwcm9ncmFtbWF0aWNhbGx5IHN1Ym1pdCBhIGZvcm0gKG9yXG4gKiBzb21lIGFyYml0cmFyeSBkYXRhKSB0byB0aGUgc2VydmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZXN1Ym1pdFxuICovXG5mdW5jdGlvbiB1c2VTdWJtaXQoKSB7XG4gIHJldHVybiB1c2VTdWJtaXRJbXBsKCk7XG59XG5sZXQgZGVmYXVsdE1ldGhvZCA9IFwiZ2V0XCI7XG5sZXQgZGVmYXVsdEVuY1R5cGUgPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiO1xuZnVuY3Rpb24gdXNlU3VibWl0SW1wbChrZXkpIHtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IGRlZmF1bHRBY3Rpb24gPSB1c2VGb3JtQWN0aW9uKCk7XG4gIGxldCB7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXJcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjaygodGFyZ2V0LCBvcHRpb25zID0ge30pID0+IHtcbiAgICBsZXQgbWV0aG9kO1xuICAgIGxldCBhY3Rpb247XG4gICAgbGV0IGVuY1R5cGU7XG4gICAgbGV0IGZvcm1EYXRhO1xuXG4gICAgaWYgKGlzRm9ybUVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgbGV0IHN1Ym1pc3Npb25UcmlnZ2VyID0gb3B0aW9ucy5zdWJtaXNzaW9uVHJpZ2dlcjtcbiAgICAgIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJtZXRob2RcIikgfHwgZGVmYXVsdE1ldGhvZDtcbiAgICAgIGFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uIHx8IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIikgfHwgZGVmYXVsdEFjdGlvbjtcbiAgICAgIGVuY1R5cGUgPSBvcHRpb25zLmVuY1R5cGUgfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImVuY3R5cGVcIikgfHwgZGVmYXVsdEVuY1R5cGU7XG4gICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSh0YXJnZXQpO1xuXG4gICAgICBpZiAoc3VibWlzc2lvblRyaWdnZXIgJiYgc3VibWlzc2lvblRyaWdnZXIubmFtZSkge1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQoc3VibWlzc2lvblRyaWdnZXIubmFtZSwgc3VibWlzc2lvblRyaWdnZXIudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNCdXR0b25FbGVtZW50KHRhcmdldCkgfHwgaXNJbnB1dEVsZW1lbnQodGFyZ2V0KSAmJiAodGFyZ2V0LnR5cGUgPT09IFwic3VibWl0XCIgfHwgdGFyZ2V0LnR5cGUgPT09IFwiaW1hZ2VcIikpIHtcbiAgICAgIGxldCBmb3JtID0gdGFyZ2V0LmZvcm07XG5cbiAgICAgIGlmIChmb3JtID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc3VibWl0IGEgPGJ1dHRvbj4gd2l0aG91dCBhIDxmb3JtPmApO1xuICAgICAgfSAvLyA8YnV0dG9uPi88aW5wdXQgdHlwZT1cInN1Ym1pdFwiPiBtYXkgb3ZlcnJpZGUgYXR0cmlidXRlcyBvZiA8Zm9ybT5cblxuXG4gICAgICBtZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybW1ldGhvZFwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xuICAgICAgYWN0aW9uID0gb3B0aW9ucy5hY3Rpb24gfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1hY3Rpb25cIikgfHwgZm9ybS5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIikgfHwgZGVmYXVsdEFjdGlvbjtcbiAgICAgIGVuY1R5cGUgPSBvcHRpb25zLmVuY1R5cGUgfHwgdGFyZ2V0LmdldEF0dHJpYnV0ZShcImZvcm1lbmN0eXBlXCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSB8fCBkZWZhdWx0RW5jVHlwZTtcbiAgICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0pOyAvLyBJbmNsdWRlIG5hbWUgKyB2YWx1ZSBmcm9tIGEgPGJ1dHRvbj5cblxuICAgICAgaWYgKHRhcmdldC5uYW1lKSB7XG4gICAgICAgIGZvcm1EYXRhLnNldCh0YXJnZXQubmFtZSwgdGFyZ2V0LnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzSHRtbEVsZW1lbnQodGFyZ2V0KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzdWJtaXQgZWxlbWVudCB0aGF0IGlzIG5vdCA8Zm9ybT4sIDxidXR0b24+LCBvciBgICsgYDxpbnB1dCB0eXBlPVwic3VibWl0fGltYWdlXCI+YCk7XG4gICAgICB9XG5cbiAgICAgIG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IFwiZ2V0XCI7XG4gICAgICBhY3Rpb24gPSBvcHRpb25zLmFjdGlvbiB8fCBkZWZhdWx0QWN0aW9uO1xuICAgICAgZW5jVHlwZSA9IG9wdGlvbnMuZW5jVHlwZSB8fCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiO1xuXG4gICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgRm9ybURhdGEpIHtcbiAgICAgICAgZm9ybURhdGEgPSB0YXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMpIHtcbiAgICAgICAgICBmb3IgKGxldCBbbmFtZSwgdmFsdWVdIG9mIHRhcmdldCkge1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIE9iamVjdC5rZXlzKHRhcmdldCkpIHtcbiAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBhcmUgY2FsbGluZyBzdWJtaXQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLiBcIiArIFwiVHJ5IGNhbGxpbmcgc3VibWl0IHdpdGhpbiBhIGB1c2VFZmZlY3RgIG9yIGNhbGxiYWNrIGluc3RlYWQuXCIpO1xuICAgIH1cblxuICAgIGxldCB7XG4gICAgICBwcm90b2NvbCxcbiAgICAgIGhvc3RcbiAgICB9ID0gd2luZG93LmxvY2F0aW9uO1xuICAgIGxldCB1cmwgPSBuZXcgVVJMKGFjdGlvbiwgYCR7cHJvdG9jb2x9Ly8ke2hvc3R9YCk7XG5cbiAgICBpZiAobWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiZ2V0XCIpIHtcbiAgICAgIGZvciAobGV0IFtuYW1lLCB2YWx1ZV0gb2YgZm9ybURhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBzdWJtaXQgYmluYXJ5IGZvcm0gZGF0YSB1c2luZyBHRVRgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzdWJtaXNzaW9uID0ge1xuICAgICAgZm9ybURhdGEsXG4gICAgICBhY3Rpb246IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2gsXG4gICAgICBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpLFxuICAgICAgZW5jVHlwZSxcbiAgICAgIGtleTogTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDgpXG4gICAgfTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIHRyYW5zaXRpb25NYW5hZ2VyLnNlbmQoe1xuICAgICAgICB0eXBlOiBcImZldGNoZXJcIixcbiAgICAgICAgaHJlZjogc3VibWlzc2lvbi5hY3Rpb24sXG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIGtleVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldE5leHROYXZpZ2F0aW9uU3VibWlzc2lvbihzdWJtaXNzaW9uKTtcbiAgICAgIG5hdmlnYXRlKHVybC5wYXRobmFtZSArIHVybC5zZWFyY2gsIHtcbiAgICAgICAgcmVwbGFjZTogb3B0aW9ucy5yZXBsYWNlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtkZWZhdWx0QWN0aW9uLCBrZXksIG5hdmlnYXRlLCB0cmFuc2l0aW9uTWFuYWdlcl0pO1xufVxubGV0IG5leHROYXZpZ2F0aW9uU3VibWlzc2lvbjtcblxuZnVuY3Rpb24gc2V0TmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uKHN1Ym1pc3Npb24pIHtcbiAgbmV4dE5hdmlnYXRpb25TdWJtaXNzaW9uID0gc3VibWlzc2lvbjtcbn1cblxuZnVuY3Rpb24gY29uc3VtZU5leHROYXZpZ2F0aW9uU3VibWlzc2lvbigpIHtcbiAgbGV0IHN1Ym1pc3Npb24gPSBuZXh0TmF2aWdhdGlvblN1Ym1pc3Npb247XG4gIG5leHROYXZpZ2F0aW9uU3VibWlzc2lvbiA9IHVuZGVmaW5lZDtcbiAgcmV0dXJuIHN1Ym1pc3Npb247XG59XG5cbmZ1bmN0aW9uIGlzSHRtbEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnRhZ05hbWUgPT09IFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIGlzQnV0dG9uRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJ1dHRvblwiO1xufVxuXG5mdW5jdGlvbiBpc0Zvcm1FbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZm9ybVwiO1xufVxuXG5mdW5jdGlvbiBpc0lucHV0RWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCI7XG59XG4vKipcbiAqIFNldHVwIGEgY2FsbGJhY2sgdG8gYmUgZmlyZWQgb24gdGhlIHdpbmRvdydzIGBiZWZvcmV1bmxvYWRgIGV2ZW50LiBUaGlzIGlzXG4gKiB1c2VmdWwgZm9yIHNhdmluZyBzb21lIGRhdGEgdG8gYHdpbmRvdy5sb2NhbFN0b3JhZ2VgIGp1c3QgYmVmb3JlIHRoZSBwYWdlXG4gKiByZWZyZXNoZXMsIHdoaWNoIGF1dG9tYXRpY2FsbHkgaGFwcGVucyBvbiB0aGUgbmV4dCBgPExpbms+YCBjbGljayB3aGVuIFJlbWl4XG4gKiBkZXRlY3RzIGEgbmV3IHZlcnNpb24gb2YgdGhlIGFwcCBpcyBhdmFpbGFibGUgb24gdGhlIHNlcnZlci5cbiAqXG4gKiBOb3RlOiBUaGUgYGNhbGxiYWNrYCBhcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbiBjcmVhdGVkIHdpdGhcbiAqIGBSZWFjdC51c2VDYWxsYmFjaygpYC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCN1c2ViZWZvcmV1bmxvYWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZUJlZm9yZVVubG9hZChjYWxsYmFjaykge1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIiwgY2FsbGJhY2spO1xuICAgIH07XG4gIH0sIFtjYWxsYmFja10pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHJvdXRlIG1hdGNoZXMgb24gdGhlIHBhZ2UuIFRoaXMgaXMgdXNlZnVsIGZvciBjcmVhdGluZ1xuICogbGF5b3V0IGFic3RyYWN0aW9ucyB3aXRoIHlvdXIgY3VycmVudCByb3V0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjdXNlbWF0Y2hlc1xuICovXG5cbmZ1bmN0aW9uIHVzZU1hdGNoZXMoKSB7XG4gIGxldCB7XG4gICAgbWF0Y2hlcyxcbiAgICByb3V0ZURhdGEsXG4gICAgcm91dGVNb2R1bGVzXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiBtYXRjaGVzLm1hcChtYXRjaCA9PiB7XG4gICAgdmFyIF9yb3V0ZU1vZHVsZXMkbWF0Y2gkcjtcblxuICAgIGxldCB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHBhcmFtc1xuICAgIH0gPSBtYXRjaDtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IG1hdGNoLnJvdXRlLmlkLFxuICAgICAgcGF0aG5hbWUsXG4gICAgICBwYXJhbXMsXG4gICAgICBkYXRhOiByb3V0ZURhdGFbbWF0Y2gucm91dGUuaWRdLFxuICAgICAgLy8gaWYgdGhlIG1vZHVsZSBmYWlscyB0byBsb2FkIG9yIGFuIGVycm9yL3Jlc3BvbnNlIGlzIHRocm93biwgdGhlIG1vZHVsZVxuICAgICAgLy8gd29uJ3QgYmUgZGVmaW5lZC5cbiAgICAgIGhhbmRsZTogKF9yb3V0ZU1vZHVsZXMkbWF0Y2gkciA9IHJvdXRlTW9kdWxlc1ttYXRjaC5yb3V0ZS5pZF0pID09PSBudWxsIHx8IF9yb3V0ZU1vZHVsZXMkbWF0Y2gkciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JvdXRlTW9kdWxlcyRtYXRjaCRyLmhhbmRsZVxuICAgIH07XG4gIH0pLCBbbWF0Y2hlcywgcm91dGVEYXRhLCByb3V0ZU1vZHVsZXNdKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgSlNPTiBwYXJzZWQgZGF0YSBmcm9tIHRoZSBjdXJyZW50IHJvdXRlJ3MgYGxvYWRlcmAuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjdXNlbG9hZGVyZGF0YVxuICovXG5cbmZ1bmN0aW9uIHVzZUxvYWRlckRhdGEoKSB7XG4gIHJldHVybiB1c2VSZW1peFJvdXRlQ29udGV4dCgpLmRhdGE7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIEpTT04gcGFyc2VkIGRhdGEgZnJvbSB0aGUgY3VycmVudCByb3V0ZSdzIGBhY3Rpb25gLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZWFjdGlvbmRhdGFcbiAqL1xuXG5mdW5jdGlvbiB1c2VBY3Rpb25EYXRhKCkge1xuICBsZXQge1xuICAgIGlkOiByb3V0ZUlkXG4gIH0gPSB1c2VSZW1peFJvdXRlQ29udGV4dCgpO1xuICBsZXQge1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQge1xuICAgIGFjdGlvbkRhdGFcbiAgfSA9IHRyYW5zaXRpb25NYW5hZ2VyLmdldFN0YXRlKCk7XG4gIHJldHVybiBhY3Rpb25EYXRhID8gYWN0aW9uRGF0YVtyb3V0ZUlkXSA6IHVuZGVmaW5lZDtcbn1cbi8qKlxuICogUmV0dXJucyBldmVyeXRoaW5nIHlvdSBuZWVkIHRvIGtub3cgYWJvdXQgYSBwYWdlIHRyYW5zaXRpb24gdG8gYnVpbGQgcGVuZGluZ1xuICogbmF2aWdhdGlvbiBpbmRpY2F0b3JzIGFuZCBvcHRpbWlzdGljIFVJIG9uIGRhdGEgbXV0YXRpb25zLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZXRyYW5zaXRpb25cbiAqL1xuXG5mdW5jdGlvbiB1c2VUcmFuc2l0aW9uKCkge1xuICBsZXQge1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICByZXR1cm4gdHJhbnNpdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKS50cmFuc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGZXRjaGVyRm9ybShmZXRjaEtleSkge1xuICBsZXQgRmV0Y2hlckZvcm0gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgIC8vIFRPRE86IG1ha2UgQU5PVEhFUiBmb3JtIHcvbyBhIGZldGNoS2V5IHByb3BcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRm9ybUltcGwsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgcmVmOiByZWYsXG4gICAgICBmZXRjaEtleTogZmV0Y2hLZXlcbiAgICB9KSk7XG4gIH0pO1xuICBGZXRjaGVyRm9ybS5kaXNwbGF5TmFtZSA9IFwiZmV0Y2hlci5Gb3JtXCI7XG4gIHJldHVybiBGZXRjaGVyRm9ybTtcbn1cblxubGV0IGZldGNoZXJJZCA9IDA7XG5cbi8qKlxuICogSW50ZXJhY3RzIHdpdGggcm91dGUgbG9hZGVycyBhbmQgYWN0aW9ucyB3aXRob3V0IGNhdXNpbmcgYSBuYXZpZ2F0aW9uLiBHcmVhdFxuICogZm9yIGFueSBpbnRlcmFjdGlvbiB0aGF0IHN0YXlzIG9uIHRoZSBzYW1lIHBhZ2UuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjdXNlZmV0Y2hlclxuICovXG5mdW5jdGlvbiB1c2VGZXRjaGVyKCkge1xuICBsZXQge1xuICAgIHRyYW5zaXRpb25NYW5hZ2VyXG4gIH0gPSB1c2VSZW1peEVudHJ5Q29udGV4dCgpO1xuICBsZXQgW2tleV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBTdHJpbmcoKytmZXRjaGVySWQpKTtcbiAgbGV0IFtGb3JtXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IGNyZWF0ZUZldGNoZXJGb3JtKGtleSkpO1xuICBsZXQgW2xvYWRdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gaHJlZiA9PiB7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXIuc2VuZCh7XG4gICAgICB0eXBlOiBcImZldGNoZXJcIixcbiAgICAgIGhyZWYsXG4gICAgICBrZXlcbiAgICB9KTtcbiAgfSk7XG4gIGxldCBzdWJtaXQgPSB1c2VTdWJtaXRJbXBsKGtleSk7XG4gIGxldCBmZXRjaGVyID0gdHJhbnNpdGlvbk1hbmFnZXIuZ2V0RmV0Y2hlcihrZXkpO1xuICBsZXQgZmV0Y2hlcldpdGhDb21wb25lbnRzID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIEZvcm0sXG4gICAgc3VibWl0LFxuICAgIGxvYWQsXG4gICAgLi4uZmV0Y2hlclxuICB9KSwgW2ZldGNoZXIsIEZvcm0sIHN1Ym1pdCwgbG9hZF0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIC8vIElzIHRoaXMgYnVzdGVkIHdoZW4gdGhlIFJlYWN0IHRlYW0gZ2V0cyByZWFsIHdlaXJkIGFuZCBjYWxscyBlZmZlY3RzXG4gICAgLy8gdHdpY2Ugb24gbW91bnQ/ICBXZSByZWFsbHkganVzdCBuZWVkIHRvIGdhcmJhZ2UgY29sbGVjdCBoZXJlIHdoZW4gdGhpc1xuICAgIC8vIGZldGNoZXIgaXMgbm8gbG9uZ2VyIGFyb3VuZC5cbiAgICByZXR1cm4gKCkgPT4gdHJhbnNpdGlvbk1hbmFnZXIuZGVsZXRlRmV0Y2hlcihrZXkpO1xuICB9LCBbdHJhbnNpdGlvbk1hbmFnZXIsIGtleV0pO1xuICByZXR1cm4gZmV0Y2hlcldpdGhDb21wb25lbnRzO1xufVxuLyoqXG4gKiBQcm92aWRlcyBhbGwgZmV0Y2hlcnMgY3VycmVudGx5IG9uIHRoZSBwYWdlLiBVc2VmdWwgZm9yIGxheW91dHMgYW5kIHBhcmVudFxuICogcm91dGVzIHRoYXQgbmVlZCB0byBwcm92aWRlIHBlbmRpbmcvb3B0aW1pc3RpYyBVSSByZWdhcmRpbmcgdGhlIGZldGNoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I3VzZWZldGNoZXJzXG4gKi9cblxuZnVuY3Rpb24gdXNlRmV0Y2hlcnMoKSB7XG4gIGxldCB7XG4gICAgdHJhbnNpdGlvbk1hbmFnZXJcbiAgfSA9IHVzZVJlbWl4RW50cnlDb250ZXh0KCk7XG4gIGxldCB7XG4gICAgZmV0Y2hlcnNcbiAgfSA9IHRyYW5zaXRpb25NYW5hZ2VyLmdldFN0YXRlKCk7XG4gIHJldHVybiBbLi4uZmV0Y2hlcnMudmFsdWVzKCldO1xufSAvLyBEZWFkIENvZGUgRWxpbWluYXRpb24gbWFnaWMgZm9yIHByb2R1Y3Rpb24gYnVpbGRzLlxuLy8gVGhpcyB3YXkgZGV2cyBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IGRvaW5nIHRoZSBOT0RFX0VOViBjaGVjayB0aGVtc2VsdmVzLlxuXG5jb25zdCBMaXZlUmVsb2FkID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwiZGV2ZWxvcG1lbnRcIiA/ICgpID0+IG51bGwgOiBmdW5jdGlvbiBMaXZlUmVsb2FkKHtcbiAgcG9ydCA9IE51bWJlcihwcm9jZXNzLmVudi5SRU1JWF9ERVZfU0VSVkVSX1dTX1BPUlQgfHwgODAwMilcbn0pIHtcbiAgbGV0IHNldHVwTGl2ZVJlbG9hZCA9IChwb3J0ID0+IHtcbiAgICBsZXQgcHJvdG9jb2wgPSBsb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwid3NzOlwiIDogXCJ3czpcIjtcbiAgICBsZXQgaG9zdCA9IGxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIGxldCBzb2NrZXRQYXRoID0gYCR7cHJvdG9jb2x9Ly8ke2hvc3R9OiR7cG9ydH0vc29ja2V0YDtcbiAgICBsZXQgd3MgPSBuZXcgV2ViU29ja2V0KHNvY2tldFBhdGgpO1xuXG4gICAgd3Mub25tZXNzYWdlID0gbWVzc2FnZSA9PiB7XG4gICAgICBsZXQgZXZlbnQgPSBKU09OLnBhcnNlKG1lc3NhZ2UuZGF0YSk7XG5cbiAgICAgIGlmIChldmVudC50eXBlID09PSBcIkxPR1wiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50Lm1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJSRUxPQURcIikge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlx1RDgzRFx1RENCRiBSZWxvYWRpbmcgd2luZG93IC4uLlwiKTtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3cy5vbmVycm9yID0gZXJyb3IgPT4ge1xuICAgICAgY29uc29sZS5sb2coXCJSZW1peCBkZXYgYXNzZXQgc2VydmVyIHdlYiBzb2NrZXQgZXJyb3I6XCIpO1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfTtcbiAgfSkudG9TdHJpbmcoKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgX19odG1sOiBgKCR7c2V0dXBMaXZlUmVsb2FkfSkoJHtKU09OLnN0cmluZ2lmeShwb3J0KX0pYFxuICAgIH1cbiAgfSk7XG59O1xuXG5mdW5jdGlvbiB1c2VDb21wb3NlZFJlZnMoLi4ucmVmcykge1xuICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2sobm9kZSA9PiB7XG4gICAgZm9yIChsZXQgcmVmIG9mIHJlZnMpIHtcbiAgICAgIGlmIChyZWYgPT0gbnVsbCkgY29udGludWU7XG5cbiAgICAgIGlmICh0eXBlb2YgcmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmVmKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZWYuY3VycmVudCA9IG5vZGU7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG5cbiAgfSwgcmVmcyk7XG59XG5cbmV4cG9ydCB7IEZvcm0sIEZvcm1JbXBsLCBMaW5rLCBMaW5rcywgTGl2ZVJlbG9hZCwgTWV0YSwgTmF2TGluaywgUHJlZmV0Y2hQYWdlTGlua3MsIFJlbWl4RW50cnksIFJlbWl4RW50cnlDb250ZXh0LCBSZW1peFJvdXRlLCBTY3JpcHRzLCBjb21wb3NlRXZlbnRIYW5kbGVycywgdXNlQWN0aW9uRGF0YSwgdXNlQmVmb3JlVW5sb2FkLCB1c2VGZXRjaGVyLCB1c2VGZXRjaGVycywgdXNlRm9ybUFjdGlvbiwgdXNlTG9hZGVyRGF0YSwgdXNlTWF0Y2hlcywgdXNlU3VibWl0LCB1c2VTdWJtaXRJbXBsLCB1c2VUcmFuc2l0aW9uIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5leHBvcnQgeyBfZXh0ZW5kcyBhcyBleHRlbmRzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxuLy8gVE9ETzogV2UgZXZlbnR1YWxseSBtaWdodCBub3Qgd2FudCB0byBpbXBvcnQgYW55dGhpbmcgZGlyZWN0bHkgZnJvbSBgaGlzdG9yeWBcbmNsYXNzIFJlbWl4RXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0X19kZWZhdWx0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3IgfHwgbnVsbCxcbiAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvblxuICAgIH07XG4gIH1cblxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yXG4gICAgfTtcbiAgfVxuXG4gIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgLy8gV2hlbiB3ZSBnZXQgaW50byBhbiBlcnJvciBzdGF0ZSwgdGhlIHVzZXIgd2lsbCBsaWtlbHkgY2xpY2sgXCJiYWNrXCIgdG8gdGhlXG4gICAgLy8gcHJldmlvdXMgcGFnZSB0aGF0IGRpZG4ndCBoYXZlIGFuIGVycm9yLiBCZWNhdXNlIHRoaXMgd3JhcHMgdGhlIGVudGlyZVxuICAgIC8vIGFwcGxpY2F0aW9uIChldmVuIHRoZSBIVE1MISkgdGhhdCB3aWxsIGhhdmUgbm8gZWZmZWN0LS10aGUgZXJyb3IgcGFnZVxuICAgIC8vIGNvbnRpbnVlcyB0byBkaXNwbGF5LiBUaGlzIGdpdmVzIHVzIGEgbWVjaGFuaXNtIHRvIHJlY292ZXIgZnJvbSB0aGUgZXJyb3JcbiAgICAvLyB3aGVuIHRoZSBsb2NhdGlvbiBjaGFuZ2VzLlxuICAgIC8vXG4gICAgLy8gV2hldGhlciB3ZSdyZSBpbiBhbiBlcnJvciBzdGF0ZSBvciBub3QsIHdlIHVwZGF0ZSB0aGUgbG9jYXRpb24gaW4gc3RhdGVcbiAgICAvLyBzbyB0aGF0IHdoZW4gd2UgYXJlIGluIGFuIGVycm9yIHN0YXRlLCBpdCBnZXRzIHJlc2V0IHdoZW4gYSBuZXcgbG9jYXRpb25cbiAgICAvLyBjb21lcyBpbiBhbmQgdGhlIHVzZXIgcmVjb3ZlcnMgZnJvbSB0aGUgZXJyb3IuXG4gICAgaWYgKHN0YXRlLmxvY2F0aW9uICE9PSBwcm9wcy5sb2NhdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHByb3BzLmVycm9yIHx8IG51bGwsXG4gICAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvblxuICAgICAgfTtcbiAgICB9IC8vIElmIHdlJ3JlIG5vdCBjaGFuZ2luZyBsb2NhdGlvbnMsIHByZXNlcnZlIHRoZSBsb2NhdGlvbiBidXQgc3RpbGwgc3VyZmFjZVxuICAgIC8vIGFueSBuZXcgZXJyb3JzIHRoYXQgbWF5IGNvbWUgdGhyb3VnaC4gV2UgcmV0YWluIHRoZSBleGlzdGluZyBlcnJvciwgd2UgZG9cbiAgICAvLyB0aGlzIGJlY2F1c2UgdGhlIGVycm9yIHByb3ZpZGVkIGZyb20gdGhlIGFwcCBzdGF0ZSBtYXkgYmUgY2xlYXJlZCB3aXRob3V0XG4gICAgLy8gdGhlIGxvY2F0aW9uIGNoYW5naW5nLlxuXG5cbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHByb3BzLmVycm9yIHx8IHN0YXRlLmVycm9yLFxuICAgICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uXG4gICAgfTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KHRoaXMucHJvcHMuY29tcG9uZW50LCB7XG4gICAgICAgIGVycm9yOiB0aGlzLnN0YXRlLmVycm9yXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9XG5cbn1cbi8qKlxuICogV2hlbiBhcHAncyBkb24ndCBwcm92aWRlIGEgcm9vdCBsZXZlbCBFcnJvckJvdW5kYXJ5LCB3ZSBkZWZhdWx0IHRvIHRoaXMuXG4gKi9cblxuZnVuY3Rpb24gUmVtaXhSb290RGVmYXVsdEVycm9yQm91bmRhcnkoe1xuICBlcnJvclxufSkge1xuICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaHRtbFwiLCB7XG4gICAgbGFuZzogXCJlblwiXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaGVhZFwiLCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcIm1ldGFcIiwge1xuICAgIGNoYXJTZXQ6IFwidXRmLThcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICBuYW1lOiBcInZpZXdwb3J0XCIsXG4gICAgY29udGVudDogXCJ3aWR0aD1kZXZpY2Utd2lkdGgsaW5pdGlhbC1zY2FsZT0xLHZpZXdwb3J0LWZpdD1jb3ZlclwiXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInRpdGxlXCIsIG51bGwsIFwiQXBwbGljYXRpb24gRXJyb3IhXCIpKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWFpblwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRGYW1pbHk6IFwic3lzdGVtLXVpLCBzYW5zLXNlcmlmXCIsXG4gICAgICBwYWRkaW5nOiBcIjJyZW1cIlxuICAgIH1cbiAgfSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJoMVwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRTaXplOiBcIjI0cHhcIlxuICAgIH1cbiAgfSwgXCJBcHBsaWNhdGlvbiBFcnJvclwiKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJwcmVcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBwYWRkaW5nOiBcIjJyZW1cIixcbiAgICAgIGJhY2tncm91bmQ6IFwiaHNsYSgxMCwgNTAlLCA1MCUsIDAuMSlcIixcbiAgICAgIGNvbG9yOiBcInJlZFwiLFxuICAgICAgb3ZlcmZsb3c6IFwiYXV0b1wiXG4gICAgfVxuICB9LCBlcnJvci5zdGFjaykpLCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiLCB7XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHtcbiAgICAgIF9faHRtbDogYFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAgICAgICBcIlx1RDgzRFx1RENCRiBIZXkgZGV2ZWxvcGVyXHVEODNEXHVEQzRCLiBZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnMuIENoZWNrIG91dCBodHRwczovL3JlbWl4LnJ1bi9ndWlkZXMvZXJyb3JzIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBgXG4gICAgfVxuICB9KSkpO1xufVxubGV0IFJlbWl4Q2F0Y2hDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcbi8qKlxuICogUmV0dXJucyB0aGUgc3RhdHVzIGNvZGUgYW5kIHRocm93biByZXNwb25zZSBkYXRhLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL2NvbnZlbnRpb25zI2NhdGNoYm91bmRhcnlcbiAqL1xuXG5mdW5jdGlvbiB1c2VDYXRjaCgpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoUmVtaXhDYXRjaENvbnRleHQpO1xufVxuZnVuY3Rpb24gUmVtaXhDYXRjaEJvdW5kYXJ5KHtcbiAgY2F0Y2g6IGNhdGNoVmFsLFxuICBjb21wb25lbnQ6IENvbXBvbmVudCxcbiAgY2hpbGRyZW5cbn0pIHtcbiAgaWYgKGNhdGNoVmFsKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlbWl4Q2F0Y2hDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogY2F0Y2hWYWxcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIG51bGwpKTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChSZWFjdF9fZGVmYXVsdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4pO1xufVxuLyoqXG4gKiBXaGVuIGFwcCdzIGRvbid0IHByb3ZpZGUgYSByb290IGxldmVsIENhdGNoQm91bmRhcnksIHdlIGRlZmF1bHQgdG8gdGhpcy5cbiAqL1xuXG5mdW5jdGlvbiBSZW1peFJvb3REZWZhdWx0Q2F0Y2hCb3VuZGFyeSgpIHtcbiAgbGV0IGNhdWdodCA9IHVzZUNhdGNoKCk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImh0bWxcIiwge1xuICAgIGxhbmc6IFwiZW5cIlxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImhlYWRcIiwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJtZXRhXCIsIHtcbiAgICBjaGFyU2V0OiBcInV0Zi04XCJcbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwibWV0YVwiLCB7XG4gICAgbmFtZTogXCJ2aWV3cG9ydFwiLFxuICAgIGNvbnRlbnQ6IFwid2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MSx2aWV3cG9ydC1maXQ9Y292ZXJcIlxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCBcIlVuaGFuZGxlZCBUaHJvd24gUmVzcG9uc2UhXCIpKSwgLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJib2R5XCIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBmb250RmFtaWx5OiBcInN5c3RlbS11aSwgc2Fucy1zZXJpZlwiLFxuICAgICAgcGFkZGluZzogXCIycmVtXCJcbiAgICB9XG4gIH0sIGNhdWdodC5zdGF0dXMsIFwiIFwiLCBjYXVnaHQuc3RhdHVzVGV4dCksIC8qI19fUFVSRV9fKi9SZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIsIHtcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgX19odG1sOiBgXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgICAgICAgIFwiXHVEODNEXHVEQ0JGIEhleSBkZXZlbG9wZXJcdUQ4M0RcdURDNEIuIFlvdSBjYW4gcHJvdmlkZSBhIHdheSBiZXR0ZXIgVVggdGhhbiB0aGlzIHdoZW4geW91ciBhcHAgdGhyb3dzIDQwNHMgKGFuZCBvdGhlciByZXNwb25zZXMpLiBDaGVjayBvdXQgaHR0cHM6Ly9yZW1peC5ydW4vZ3VpZGVzL25vdC1mb3VuZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgYFxuICAgIH1cbiAgfSkpKTtcbn1cblxuZXhwb3J0IHsgUmVtaXhDYXRjaEJvdW5kYXJ5LCBSZW1peEVycm9yQm91bmRhcnksIFJlbWl4Um9vdERlZmF1bHRDYXRjaEJvdW5kYXJ5LCBSZW1peFJvb3REZWZhdWx0RXJyb3JCb3VuZGFyeSwgdXNlQ2F0Y2ggfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4zXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIGludmFyaWFudCh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgeyBpbnZhcmlhbnQgYXMgZGVmYXVsdCB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0IHsgcGFyc2VQYXRoIH0gZnJvbSAnaGlzdG9yeSc7XG5pbXBvcnQgeyBsb2FkUm91dGVNb2R1bGUgfSBmcm9tICcuL3JvdXRlTW9kdWxlcy5qcyc7XG5cbi8vIFRPRE86IFdlIGV2ZW50dWFsbHkgbWlnaHQgbm90IHdhbnQgdG8gaW1wb3J0IGFueXRoaW5nIGRpcmVjdGx5IGZyb20gYGhpc3RvcnlgXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4vKipcbiAqIEdldHMgYWxsIHRoZSBsaW5rcyBmb3IgYSBzZXQgb2YgbWF0Y2hlcy4gVGhlIG1vZHVsZXMgYXJlIGFzc3VtZWQgdG8gaGF2ZSBiZWVuXG4gKiBsb2FkZWQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gZ2V0TGlua3NGb3JNYXRjaGVzKG1hdGNoZXMsIHJvdXRlTW9kdWxlcywgbWFuaWZlc3QpIHtcbiAgbGV0IGRlc2NyaXB0b3JzID0gbWF0Y2hlcy5tYXAobWF0Y2ggPT4ge1xuICAgIHZhciBfbW9kdWxlJGxpbmtzO1xuXG4gICAgbGV0IG1vZHVsZSA9IHJvdXRlTW9kdWxlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgcmV0dXJuICgoX21vZHVsZSRsaW5rcyA9IG1vZHVsZS5saW5rcykgPT09IG51bGwgfHwgX21vZHVsZSRsaW5rcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX21vZHVsZSRsaW5rcy5jYWxsKG1vZHVsZSkpIHx8IFtdO1xuICB9KS5mbGF0KDEpO1xuICBsZXQgcHJlbG9hZHMgPSBnZXRDdXJyZW50UGFnZU1vZHVsZVByZWxvYWRIcmVmcyhtYXRjaGVzLCBtYW5pZmVzdCk7XG4gIHJldHVybiBkZWR1cGUoZGVzY3JpcHRvcnMsIHByZWxvYWRzKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWZldGNoU3R5bGVMaW5rcyhyb3V0ZU1vZHVsZSkge1xuICBpZiAoIXJvdXRlTW9kdWxlLmxpbmtzKSByZXR1cm47XG4gIGxldCBkZXNjcmlwdG9ycyA9IHJvdXRlTW9kdWxlLmxpbmtzKCk7XG4gIGlmICghZGVzY3JpcHRvcnMpIHJldHVybjtcbiAgbGV0IHN0eWxlTGlua3MgPSBbXTtcblxuICBmb3IgKGxldCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKSB7XG4gICAgaWYgKCFpc1BhZ2VMaW5rRGVzY3JpcHRvcihkZXNjcmlwdG9yKSAmJiBkZXNjcmlwdG9yLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIpIHtcbiAgICAgIHN0eWxlTGlua3MucHVzaCh7IC4uLmRlc2NyaXB0b3IsXG4gICAgICAgIHJlbDogXCJwcmVsb2FkXCIsXG4gICAgICAgIGFzOiBcInN0eWxlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBkb24ndCBibG9jayBmb3Igbm9uLW1hdGNoaW5nIG1lZGlhIHF1ZXJpZXNcblxuXG4gIGxldCBtYXRjaGluZ0xpbmtzID0gc3R5bGVMaW5rcy5maWx0ZXIobGluayA9PiAhbGluay5tZWRpYSB8fCB3aW5kb3cubWF0Y2hNZWRpYShsaW5rLm1lZGlhKS5tYXRjaGVzKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwobWF0Y2hpbmdMaW5rcy5tYXAocHJlZmV0Y2hTdHlsZUxpbmspKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJlZmV0Y2hTdHlsZUxpbmsoZGVzY3JpcHRvcikge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgbGV0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbiAgICBPYmplY3QuYXNzaWduKGxpbmssIGRlc2NyaXB0b3IpO1xuXG4gICAgZnVuY3Rpb24gcmVtb3ZlTGluaygpIHtcbiAgICAgIC8vIGlmIGEgbmF2aWdhdGlvbiBpbnRlcnJ1cHRzIHRoaXMgcHJlZmV0Y2ggUmVhY3Qgd2lsbCB1cGRhdGUgdGhlIDxoZWFkPlxuICAgICAgLy8gYW5kIHJlbW92ZSB0aGUgbGluayB3ZSBwdXQgaW4gdGhlcmUgbWFudWFsbHksIHNvIHdlIGNoZWNrIGlmIGl0J3Mgc3RpbGxcbiAgICAgIC8vIHRoZXJlIGJlZm9yZSB0cnlpbmcgdG8gcmVtb3ZlIGl0XG4gICAgICBpZiAoZG9jdW1lbnQuaGVhZC5jb250YWlucyhsaW5rKSkge1xuICAgICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxpbmsub25sb2FkID0gKCkgPT4ge1xuICAgICAgcmVtb3ZlTGluaygpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH07XG5cbiAgICBsaW5rLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICByZW1vdmVMaW5rKCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfTtcblxuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobGluayk7XG4gIH0pO1xufSAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5cbmZ1bmN0aW9uIGlzUGFnZUxpbmtEZXNjcmlwdG9yKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgdHlwZW9mIG9iamVjdC5wYWdlID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNIdG1sTGlua0Rlc2NyaXB0b3Iob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiB0eXBlb2Ygb2JqZWN0LnJlbCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb2JqZWN0LmhyZWYgPT09IFwic3RyaW5nXCI7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTdHlsZXNoZWV0UHJlZmV0Y2hMaW5rcyhtYXRjaGVzLCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IGxpbmtzID0gYXdhaXQgUHJvbWlzZS5hbGwobWF0Y2hlcy5tYXAoYXN5bmMgbWF0Y2ggPT4ge1xuICAgIGxldCBtb2QgPSBhd2FpdCBsb2FkUm91dGVNb2R1bGUobWF0Y2gucm91dGUsIHJvdXRlTW9kdWxlcyk7XG4gICAgcmV0dXJuIG1vZC5saW5rcyA/IG1vZC5saW5rcygpIDogW107XG4gIH0pKTtcbiAgcmV0dXJuIGxpbmtzLmZsYXQoMSkuZmlsdGVyKGlzSHRtbExpbmtEZXNjcmlwdG9yKS5maWx0ZXIobGluayA9PiBsaW5rLnJlbCA9PT0gXCJzdHlsZXNoZWV0XCIgfHwgbGluay5yZWwgPT09IFwicHJlbG9hZFwiKS5tYXAoKHtcbiAgICByZWwsXG4gICAgLi4uYXR0cnNcbiAgfSkgPT4gcmVsID09PSBcInByZWxvYWRcIiA/IHtcbiAgICByZWw6IFwicHJlZmV0Y2hcIixcbiAgICAuLi5hdHRyc1xuICB9IDoge1xuICAgIHJlbDogXCJwcmVmZXRjaFwiLFxuICAgIGFzOiBcInN0eWxlXCIsXG4gICAgLi4uYXR0cnNcbiAgfSk7XG59IC8vIFRoaXMgaXMgcmlkaWN1bG91c2x5IGlkZW50aWNhbCB0byB0cmFuc2l0aW9uLnRzIGBmaWx0ZXJNYXRjaGVzVG9Mb2FkYFxuXG5mdW5jdGlvbiBnZXROZXdNYXRjaGVzRm9yTGlua3MocGFnZSwgbmV4dE1hdGNoZXMsIGN1cnJlbnRNYXRjaGVzLCBsb2NhdGlvbiwgbW9kZSkge1xuICBsZXQgcGF0aCA9IHBhcnNlUGF0aFBhdGNoKHBhZ2UpO1xuXG4gIGxldCBpc05ldyA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBpZiAoIWN1cnJlbnRNYXRjaGVzW2luZGV4XSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIG1hdGNoLnJvdXRlLmlkICE9PSBjdXJyZW50TWF0Y2hlc1tpbmRleF0ucm91dGUuaWQ7XG4gIH07XG5cbiAgbGV0IG1hdGNoUGF0aENoYW5nZWQgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgdmFyIF9jdXJyZW50TWF0Y2hlcyRpbmRleDtcblxuICAgIHJldHVybiAoLy8gcGFyYW0gY2hhbmdlLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICAgIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5wYXRobmFtZSAhPT0gbWF0Y2gucGF0aG5hbWUgfHwgLy8gc3BsYXQgcGFyYW0gY2hhbmdlZCwgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gbWF0Y2gucGF0aFxuICAgICAgLy8gZS5nLiAvZmlsZXMvaW1hZ2VzL2F2YXRhci5qcGcgLT4gZmlsZXMvZmluYW5jZXMueGxzXG4gICAgICAoKF9jdXJyZW50TWF0Y2hlcyRpbmRleCA9IGN1cnJlbnRNYXRjaGVzW2luZGV4XS5yb3V0ZS5wYXRoKSA9PT0gbnVsbCB8fCBfY3VycmVudE1hdGNoZXMkaW5kZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jdXJyZW50TWF0Y2hlcyRpbmRleC5lbmRzV2l0aChcIipcIikpICYmIGN1cnJlbnRNYXRjaGVzW2luZGV4XS5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdXG4gICAgKTtcbiAgfTsgLy8gTk9URToga2VlcCB0aGlzIG1vc3RseSB1cC10by1kYXRlIHcvIHRoZSB0cmFuc2l0aW9uIGRhdGEgZGlmZiwgYnV0IHRoaXNcbiAgLy8gdmVyc2lvbiBkb2Vzbid0IGNhcmUgYWJvdXQgc3VibWlzc2lvbnNcblxuXG4gIGxldCBuZXdNYXRjaGVzID0gbW9kZSA9PT0gXCJkYXRhXCIgJiYgbG9jYXRpb24uc2VhcmNoICE9PSBwYXRoLnNlYXJjaCA/IC8vIHRoaXMgaXMgcmVhbGx5IHNpbWlsYXIgdG8gc3R1ZmYgaW4gdHJhbnNpdGlvbi50cywgbWF5YmUgc29tZWJvZHkgc21hcnRlclxuICAvLyB0aGFuIG1lIChvciBpbiBsZXNzIG9mIGEgaHVycnkpIGNhbiBzaGFyZSBzb21lIG9mIGl0LiBZb3UncmUgdGhlIGJlc3QuXG4gIG5leHRNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFtYXRjaC5yb3V0ZS5oYXNMb2FkZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5yb3V0ZS5zaG91bGRSZWxvYWQpIHtcbiAgICAgIHJldHVybiBtYXRjaC5yb3V0ZS5zaG91bGRSZWxvYWQoe1xuICAgICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgICAgcHJldlVybDogbmV3IFVSTChsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2gsIHdpbmRvdy5vcmlnaW4pLFxuICAgICAgICB1cmw6IG5ldyBVUkwocGFnZSwgd2luZG93Lm9yaWdpbilcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9KSA6IG5leHRNYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgcmV0dXJuIChtb2RlID09PSBcImFzc2V0c1wiIHx8IG1hdGNoLnJvdXRlLmhhc0xvYWRlcikgJiYgKGlzTmV3KG1hdGNoLCBpbmRleCkgfHwgbWF0Y2hQYXRoQ2hhbmdlZChtYXRjaCwgaW5kZXgpKTtcbiAgfSk7XG4gIHJldHVybiBuZXdNYXRjaGVzO1xufVxuZnVuY3Rpb24gZ2V0RGF0YUxpbmtIcmVmcyhwYWdlLCBtYXRjaGVzLCBtYW5pZmVzdCkge1xuICBsZXQgcGF0aCA9IHBhcnNlUGF0aFBhdGNoKHBhZ2UpO1xuICByZXR1cm4gZGVkdXBlSHJlZnMobWF0Y2hlcy5maWx0ZXIobWF0Y2ggPT4gbWFuaWZlc3Qucm91dGVzW21hdGNoLnJvdXRlLmlkXS5oYXNMb2FkZXIpLm1hcChtYXRjaCA9PiB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoXG4gICAgfSA9IHBhdGg7XG4gICAgbGV0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoc2VhcmNoKTtcbiAgICBzZWFyY2hQYXJhbXMuc2V0KFwiX2RhdGFcIiwgbWF0Y2gucm91dGUuaWQpO1xuICAgIHJldHVybiBgJHtwYXRobmFtZX0/JHtzZWFyY2hQYXJhbXN9YDtcbiAgfSkpO1xufVxuZnVuY3Rpb24gZ2V0TW9kdWxlTGlua0hyZWZzKG1hdGNoZXMsIG1hbmlmZXN0UGF0Y2gpIHtcbiAgcmV0dXJuIGRlZHVwZUhyZWZzKG1hdGNoZXMubWFwKG1hdGNoID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdFBhdGNoLnJvdXRlc1ttYXRjaC5yb3V0ZS5pZF07XG4gICAgbGV0IGhyZWZzID0gW3JvdXRlLm1vZHVsZV07XG5cbiAgICBpZiAocm91dGUuaW1wb3J0cykge1xuICAgICAgaHJlZnMgPSBocmVmcy5jb25jYXQocm91dGUuaW1wb3J0cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhyZWZzO1xuICB9KS5mbGF0KDEpKTtcbn0gLy8gVGhlIGA8U2NyaXB0PmAgd2lsbCByZW5kZXIgcmVsPW1vZHVsZXByZWxvYWQgZm9yIHRoZSBjdXJyZW50IHBhZ2UsIHdlIGRvbid0XG4vLyBuZWVkIHRvIGluY2x1ZGUgdGhlbSBpbiBhIHBhZ2UgcHJlZmV0Y2gsIHRoaXMgZ2l2ZXMgdXMgdGhlIGxpc3QgdG8gcmVtb3ZlXG4vLyB3aGlsZSBkZWR1cGluZy5cblxuZnVuY3Rpb24gZ2V0Q3VycmVudFBhZ2VNb2R1bGVQcmVsb2FkSHJlZnMobWF0Y2hlcywgbWFuaWZlc3QpIHtcbiAgcmV0dXJuIGRlZHVwZUhyZWZzKG1hdGNoZXMubWFwKG1hdGNoID0+IHtcbiAgICBsZXQgcm91dGUgPSBtYW5pZmVzdC5yb3V0ZXNbbWF0Y2gucm91dGUuaWRdO1xuICAgIGxldCBocmVmcyA9IFtyb3V0ZS5tb2R1bGVdO1xuXG4gICAgaWYgKHJvdXRlLmltcG9ydHMpIHtcbiAgICAgIGhyZWZzID0gaHJlZnMuY29uY2F0KHJvdXRlLmltcG9ydHMpO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmcztcbiAgfSkuZmxhdCgxKSk7XG59XG5cbmZ1bmN0aW9uIGRlZHVwZUhyZWZzKGhyZWZzKSB7XG4gIHJldHVybiBbLi4ubmV3IFNldChocmVmcyldO1xufVxuXG5mdW5jdGlvbiBkZWR1cGUoZGVzY3JpcHRvcnMsIHByZWxvYWRzKSB7XG4gIGxldCBzZXQgPSBuZXcgU2V0KCk7XG4gIGxldCBwcmVsb2Fkc1NldCA9IG5ldyBTZXQocHJlbG9hZHMpO1xuICByZXR1cm4gZGVzY3JpcHRvcnMucmVkdWNlKChkZWR1cGVkLCBkZXNjcmlwdG9yKSA9PiB7XG4gICAgbGV0IGFscmVhZHlNb2R1bGVQcmVsb2FkID0gIWlzUGFnZUxpbmtEZXNjcmlwdG9yKGRlc2NyaXB0b3IpICYmIGRlc2NyaXB0b3IuYXMgPT09IFwic2NyaXB0XCIgJiYgZGVzY3JpcHRvci5ocmVmICYmIHByZWxvYWRzU2V0LmhhcyhkZXNjcmlwdG9yLmhyZWYpO1xuXG4gICAgaWYgKGFscmVhZHlNb2R1bGVQcmVsb2FkKSB7XG4gICAgICByZXR1cm4gZGVkdXBlZDtcbiAgICB9XG5cbiAgICBsZXQgc3RyID0gSlNPTi5zdHJpbmdpZnkoZGVzY3JpcHRvcik7XG5cbiAgICBpZiAoIXNldC5oYXMoc3RyKSkge1xuICAgICAgc2V0LmFkZChzdHIpO1xuICAgICAgZGVkdXBlZC5wdXNoKGRlc2NyaXB0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBkZWR1cGVkO1xuICB9LCBbXSk7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS9pc3N1ZXMvODk3XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aFBhdGNoKGhyZWYpIHtcbiAgbGV0IHBhdGggPSBwYXJzZVBhdGgoaHJlZik7XG4gIGlmIChwYXRoLnNlYXJjaCA9PT0gdW5kZWZpbmVkKSBwYXRoLnNlYXJjaCA9IFwiXCI7XG4gIHJldHVybiBwYXRoO1xufVxuXG5leHBvcnQgeyBkZWR1cGUsIGdldERhdGFMaW5rSHJlZnMsIGdldExpbmtzRm9yTWF0Y2hlcywgZ2V0TW9kdWxlTGlua0hyZWZzLCBnZXROZXdNYXRjaGVzRm9yTGlua3MsIGdldFN0eWxlc2hlZXRQcmVmZXRjaExpbmtzLCBpc0h0bWxMaW5rRGVzY3JpcHRvciwgaXNQYWdlTGlua0Rlc2NyaXB0b3IsIHByZWZldGNoU3R5bGVMaW5rcyB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuLy8gVE9ETzogV2UgZXZlbnR1YWxseSBtaWdodCBub3Qgd2FudCB0byBpbXBvcnQgYW55dGhpbmcgZGlyZWN0bHkgZnJvbSBgaGlzdG9yeWBcbi8vIGFuZCBsZXZlcmFnZSBgcmVhY3Qtcm91dGVyYCBoZXJlIGluc3RlYWRcbi8vIFRPRE86IGltcG9ydC9leHBvcnQgZnJvbSByZWFjdC1yb3V0ZXItZG9tXG5cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyByZW5kZXJlZCB3aGVuIHRoZSBzZXJ2ZXIgdGhyb3dzIGEgUmVzcG9uc2UuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvY29udmVudGlvbnMjY2F0Y2hib3VuZGFyeVxuICovXG5cbi8qKlxuICogQSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyByZW5kZXJlZCB3aGVuIHRoZXJlIGlzIGFuIGVycm9yIG9uIGEgcm91dGUuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvY29udmVudGlvbnMjZXJyb3Jib3VuZGFyeVxuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IGRlZmluZXMgYDxsaW5rPmAgdGFncyB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBgPGhlYWQ+YCBvZlxuICogdGhlIGRvY3VtZW50IG9uIHJvdXRlIHRyYW5zaXRpb25zLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZW1peC5ydW4vYXBpL3JlbWl4I21ldGEtbGlua3Mtc2NyaXB0c1xuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IG9mIG5hbWUgKyBjb250ZW50IHBhaXJzIHRvIHVzZSBmb3JcbiAqIGA8bWV0YT5gIHRhZ3MgZm9yIGEgcm91dGUuIFRoZXNlIHRhZ3Mgd2lsbCBiZSBtZXJnZWQgd2l0aCAoYW5kIHRha2VcbiAqIHByZWNlZGVuY2Ugb3ZlcikgdGFncyBmcm9tIHBhcmVudCByb3V0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvcmVtaXgjbWV0YS1saW5rcy1zY3JpcHRzXG4gKi9cblxuLyoqXG4gKiBBIG5hbWUvY29udGVudCBwYWlyIHVzZWQgdG8gcmVuZGVyIGA8bWV0YT5gIHRhZ3MgaW4gYSBtZXRhIGZ1bmN0aW9uIGZvciBhXG4gKiByb3V0ZS4gVGhlIHZhbHVlIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcsIHdoaWNoIHdpbGwgcmVuZGVyIGEgc2luZ2xlIGA8bWV0YT5gXG4gKiB0YWcsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgdGhhdCB3aWxsIHJlbmRlciBtdWx0aXBsZSB0YWdzIHdpdGggdGhlIHNhbWVcbiAqIGBuYW1lYCBhdHRyaWJ1dGUuXG4gKi9cblxuLyoqXG4gKiBEdXJpbmcgY2xpZW50IHNpZGUgdHJhbnNpdGlvbnMgUmVtaXggd2lsbCBvcHRpbWl6ZSByZWxvYWRpbmcgb2Ygcm91dGVzIHRoYXRcbiAqIGFyZSBjdXJyZW50bHkgb24gdGhlIHBhZ2UgYnkgYXZvaWRpbmcgbG9hZGluZyByb3V0ZXMgdGhhdCBhcmVuJ3QgY2hhbmdpbmcuXG4gKiBIb3dldmVyLCBpbiBzb21lIGNhc2VzLCBsaWtlIGZvcm0gc3VibWlzc2lvbnMgb3Igc2VhcmNoIHBhcmFtcyBSZW1peCBkb2Vzbid0XG4gKiBrbm93IHdoaWNoIHJvdXRlcyBuZWVkIHRvIGJlIHJlbG9hZGVkIHNvIGl0IHJlbG9hZHMgdGhlbSBhbGwgdG8gYmUgc2FmZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGxldHMgYXBwcyBmdXJ0aGVyIG9wdGltaXplIGJ5IHJldHVybmluZyBgZmFsc2VgIHdoZW4gUmVtaXggaXNcbiAqIGFib3V0IHRvIHJlbG9hZCB0aGUgcm91dGUuIEEgY29tbW9uIGNhc2UgaXMgYSByb290IGxvYWRlciB3aXRoIG5vdGhpbmcgYnV0XG4gKiBlbnZpcm9ubWVudCB2YXJpYWJsZXM6IGFmdGVyIGZvcm0gc3VibWlzc2lvbnMgdGhlIHJvb3QgcHJvYmFibHkgZG9lc24ndCBuZWVkXG4gKiB0byBiZSByZWxvYWRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9jb252ZW50aW9ucyN1bnN0YWJsZV9zaG91bGRyZWxvYWRcbiAqL1xuXG4vKipcbiAqIEEgUmVhY3QgY29tcG9uZW50IHRoYXQgaXMgcmVuZGVyZWQgZm9yIGEgcm91dGUuXG4gKi9cblxuLyoqXG4gKiBBbiBhcmJpdHJhcnkgb2JqZWN0IHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIGEgcm91dGUuXG4gKlxuICogQHNlZSBodHRwczovL3JlbWl4LnJ1bi9hcGkvY29udmVudGlvbnMjaGFuZGxlXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRSb3V0ZU1vZHVsZShyb3V0ZSwgcm91dGVNb2R1bGVzQ2FjaGUpIHtcbiAgaWYgKHJvdXRlLmlkIGluIHJvdXRlTW9kdWxlc0NhY2hlKSB7XG4gICAgcmV0dXJuIHJvdXRlTW9kdWxlc0NhY2hlW3JvdXRlLmlkXTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbGV0IHJvdXRlTW9kdWxlID0gYXdhaXQgaW1wb3J0KHJvdXRlLm1vZHVsZSk7XG4gICAgcm91dGVNb2R1bGVzQ2FjaGVbcm91dGUuaWRdID0gcm91dGVNb2R1bGU7XG4gICAgcmV0dXJuIHJvdXRlTW9kdWxlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFVzZXIgZ290IGNhdWdodCBpbiB0aGUgbWlkZGxlIG9mIGEgZGVwbG95IGFuZCB0aGUgQ0ROIG5vIGxvbmdlciBoYXMgdGhlXG4gICAgLy8gYXNzZXQgd2UncmUgdHJ5aW5nIHRvIGltcG9ydCEgUmVsb2FkIGZyb20gdGhlIHNlcnZlciBhbmQgdGhlIHVzZXJcbiAgICAvLyAoc2hvdWxkKSBnZXQgdGhlIG5ldyBtYW5pZmVzdC0tdW5sZXNzIHRoZSBkZXZlbG9wZXIgcHVyZ2VkIHRoZSBzdGF0aWNcbiAgICAvLyBhc3NldHMsIHRoZSBtYW5pZmVzdCBwYXRoLCBidXQgbm90IHRoZSBkb2N1bWVudHMgXHVEODNEXHVERTJDXG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKSA9PiB7Ly8gY2hlY2sgb3V0IG9mIHRoaXMgaG9vayBjYXVzZSB0aGUgREpzIG5ldmVyIGdvbm5hIHJlW3Ndb2x2ZSB0aGlzXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHsgbG9hZFJvdXRlTW9kdWxlIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBjcmVhdGVIdG1sKGh0bWwpIHtcbiAgcmV0dXJuIHtcbiAgICBfX2h0bWw6IGh0bWxcbiAgfTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlSHRtbCB9O1xuIiwgIi8qKlxuICogQHJlbWl4LXJ1bi9yZWFjdCB2MS4yLjNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIFJlbWl4IFNvZnR3YXJlIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UubWQgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbG9hZFJvdXRlTW9kdWxlIH0gZnJvbSAnLi9yb3V0ZU1vZHVsZXMuanMnO1xuaW1wb3J0IHsgZmV0Y2hEYXRhLCBpc0NhdGNoUmVzcG9uc2UsIGV4dHJhY3REYXRhLCBpc1JlZGlyZWN0UmVzcG9uc2UgfSBmcm9tICcuL2RhdGEuanMnO1xuaW1wb3J0IHsgQ2F0Y2hWYWx1ZSwgVHJhbnNpdGlvblJlZGlyZWN0IH0gZnJvbSAnLi90cmFuc2l0aW9uLmpzJztcbmltcG9ydCB7IHByZWZldGNoU3R5bGVMaW5rcyB9IGZyb20gJy4vbGlua3MuanMnO1xuaW1wb3J0IGludmFyaWFudCBmcm9tICcuL2ludmFyaWFudC5qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFJvdXRlKGVudHJ5Um91dGUsIHJvdXRlTW9kdWxlc0NhY2hlLCBDb21wb25lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBjYXNlU2Vuc2l0aXZlOiAhIWVudHJ5Um91dGUuY2FzZVNlbnNpdGl2ZSxcbiAgICBlbGVtZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHtcbiAgICAgIGlkOiBlbnRyeVJvdXRlLmlkXG4gICAgfSksXG4gICAgaWQ6IGVudHJ5Um91dGUuaWQsXG4gICAgcGF0aDogZW50cnlSb3V0ZS5wYXRoLFxuICAgIGluZGV4OiBlbnRyeVJvdXRlLmluZGV4LFxuICAgIG1vZHVsZTogZW50cnlSb3V0ZS5tb2R1bGUsXG4gICAgbG9hZGVyOiBjcmVhdGVMb2FkZXIoZW50cnlSb3V0ZSwgcm91dGVNb2R1bGVzQ2FjaGUpLFxuICAgIGFjdGlvbjogY3JlYXRlQWN0aW9uKGVudHJ5Um91dGUpLFxuICAgIHNob3VsZFJlbG9hZDogY3JlYXRlU2hvdWxkUmVsb2FkKGVudHJ5Um91dGUsIHJvdXRlTW9kdWxlc0NhY2hlKSxcbiAgICBFcnJvckJvdW5kYXJ5OiBlbnRyeVJvdXRlLmhhc0Vycm9yQm91bmRhcnksXG4gICAgQ2F0Y2hCb3VuZGFyeTogZW50cnlSb3V0ZS5oYXNDYXRjaEJvdW5kYXJ5LFxuICAgIGhhc0xvYWRlcjogZW50cnlSb3V0ZS5oYXNMb2FkZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudFJvdXRlcyhyb3V0ZU1hbmlmZXN0LCByb3V0ZU1vZHVsZXNDYWNoZSwgQ29tcG9uZW50LCBwYXJlbnRJZCkge1xuICByZXR1cm4gT2JqZWN0LmtleXMocm91dGVNYW5pZmVzdCkuZmlsdGVyKGtleSA9PiByb3V0ZU1hbmlmZXN0W2tleV0ucGFyZW50SWQgPT09IHBhcmVudElkKS5tYXAoa2V5ID0+IHtcbiAgICBsZXQgcm91dGUgPSBjcmVhdGVDbGllbnRSb3V0ZShyb3V0ZU1hbmlmZXN0W2tleV0sIHJvdXRlTW9kdWxlc0NhY2hlLCBDb21wb25lbnQpO1xuICAgIGxldCBjaGlsZHJlbiA9IGNyZWF0ZUNsaWVudFJvdXRlcyhyb3V0ZU1hbmlmZXN0LCByb3V0ZU1vZHVsZXNDYWNoZSwgQ29tcG9uZW50LCByb3V0ZS5pZCk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHJvdXRlLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIHJvdXRlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU2hvdWxkUmVsb2FkKHJvdXRlLCByb3V0ZU1vZHVsZXMpIHtcbiAgbGV0IHNob3VsZFJlbG9hZCA9IGFyZyA9PiB7XG4gICAgbGV0IG1vZHVsZSA9IHJvdXRlTW9kdWxlc1tyb3V0ZS5pZF07XG4gICAgaW52YXJpYW50KG1vZHVsZSwgYEV4cGVjdGVkIHJvdXRlIG1vZHVsZSB0byBiZSBsb2FkZWQgZm9yICR7cm91dGUuaWR9YCk7XG5cbiAgICBpZiAobW9kdWxlLnVuc3RhYmxlX3Nob3VsZFJlbG9hZCkge1xuICAgICAgcmV0dXJuIG1vZHVsZS51bnN0YWJsZV9zaG91bGRSZWxvYWQoYXJnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICByZXR1cm4gc2hvdWxkUmVsb2FkO1xufVxuXG5hc3luYyBmdW5jdGlvbiBsb2FkUm91dGVNb2R1bGVXaXRoQmxvY2tpbmdMaW5rcyhyb3V0ZSwgcm91dGVNb2R1bGVzKSB7XG4gIGxldCByb3V0ZU1vZHVsZSA9IGF3YWl0IGxvYWRSb3V0ZU1vZHVsZShyb3V0ZSwgcm91dGVNb2R1bGVzKTtcbiAgYXdhaXQgcHJlZmV0Y2hTdHlsZUxpbmtzKHJvdXRlTW9kdWxlKTtcbiAgcmV0dXJuIHJvdXRlTW9kdWxlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2FkZXIocm91dGUsIHJvdXRlTW9kdWxlcykge1xuICBsZXQgbG9hZGVyID0gYXN5bmMgKHtcbiAgICB1cmwsXG4gICAgc2lnbmFsLFxuICAgIHN1Ym1pc3Npb25cbiAgfSkgPT4ge1xuICAgIGlmIChyb3V0ZS5oYXNMb2FkZXIpIHtcbiAgICAgIGxldCBbcmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtmZXRjaERhdGEodXJsLCByb3V0ZS5pZCwgc2lnbmFsLCBzdWJtaXNzaW9uKSwgbG9hZFJvdXRlTW9kdWxlV2l0aEJsb2NraW5nTGlua3Mocm91dGUsIHJvdXRlTW9kdWxlcyldKTtcbiAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikgdGhyb3cgcmVzdWx0O1xuICAgICAgbGV0IHJlZGlyZWN0ID0gYXdhaXQgY2hlY2tSZWRpcmVjdChyZXN1bHQpO1xuICAgICAgaWYgKHJlZGlyZWN0KSByZXR1cm4gcmVkaXJlY3Q7XG5cbiAgICAgIGlmIChpc0NhdGNoUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyBuZXcgQ2F0Y2hWYWx1ZShyZXN1bHQuc3RhdHVzLCByZXN1bHQuc3RhdHVzVGV4dCwgYXdhaXQgZXh0cmFjdERhdGEocmVzdWx0LmNsb25lKCkpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4dHJhY3REYXRhKHJlc3VsdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IGxvYWRSb3V0ZU1vZHVsZVdpdGhCbG9ja2luZ0xpbmtzKHJvdXRlLCByb3V0ZU1vZHVsZXMpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gbG9hZGVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBY3Rpb24ocm91dGUpIHtcbiAgaWYgKCFyb3V0ZS5oYXNBY3Rpb24pIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgbGV0IGFjdGlvbiA9IGFzeW5jICh7XG4gICAgdXJsLFxuICAgIHNpZ25hbCxcbiAgICBzdWJtaXNzaW9uXG4gIH0pID0+IHtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgZmV0Y2hEYXRhKHVybCwgcm91dGUuaWQsIHNpZ25hbCwgc3VibWlzc2lvbik7XG5cbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IHJlc3VsdDtcbiAgICB9XG5cbiAgICBsZXQgcmVkaXJlY3QgPSBhd2FpdCBjaGVja1JlZGlyZWN0KHJlc3VsdCk7XG4gICAgaWYgKHJlZGlyZWN0KSByZXR1cm4gcmVkaXJlY3Q7XG5cbiAgICBpZiAoaXNDYXRjaFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHRocm93IG5ldyBDYXRjaFZhbHVlKHJlc3VsdC5zdGF0dXMsIHJlc3VsdC5zdGF0dXNUZXh0LCBhd2FpdCBleHRyYWN0RGF0YShyZXN1bHQuY2xvbmUoKSkpO1xuICAgIH1cblxuICAgIHJldHVybiBleHRyYWN0RGF0YShyZXN1bHQpO1xuICB9O1xuXG4gIHJldHVybiBhY3Rpb247XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNoZWNrUmVkaXJlY3QocmVzcG9uc2UpIHtcbiAgaWYgKGlzUmVkaXJlY3RSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXNwb25zZS5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVkaXJlY3RcIiksIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pO1xuXG4gICAgaWYgKHVybC5vcmlnaW4gIT09IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKCgpID0+IHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UodXJsLmhyZWYpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNpdGlvblJlZGlyZWN0KHVybC5wYXRobmFtZSArIHVybC5zZWFyY2gpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgeyBjcmVhdGVDbGllbnRSb3V0ZSwgY3JlYXRlQ2xpZW50Um91dGVzIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgaW52YXJpYW50IGZyb20gJy4vaW52YXJpYW50LmpzJztcblxuZnVuY3Rpb24gaXNDYXRjaFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlICYmIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1DYXRjaFwiKSAhPSBudWxsO1xufVxuZnVuY3Rpb24gaXNFcnJvclJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlICYmIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1FcnJvclwiKSAhPSBudWxsO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiByZXNwb25zZSBpbnN0YW5jZW9mIFJlc3BvbnNlICYmIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiWC1SZW1peC1SZWRpcmVjdFwiKSAhPSBudWxsO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKHVybCwgcm91dGVJZCwgc2lnbmFsLCBzdWJtaXNzaW9uKSB7XG4gIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiX2RhdGFcIiwgcm91dGVJZCk7XG4gIGxldCBpbml0ID0gc3VibWlzc2lvbiA/IGdldEFjdGlvbkluaXQoc3VibWlzc2lvbiwgc2lnbmFsKSA6IHtcbiAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuICAgIHNpZ25hbFxuICB9O1xuICBsZXQgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwuaHJlZiwgaW5pdCk7XG5cbiAgaWYgKGlzRXJyb3JSZXNwb25zZShyZXNwb25zZSkpIHtcbiAgICBsZXQgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IoZGF0YS5tZXNzYWdlKTtcbiAgICBlcnJvci5zdGFjayA9IGRhdGEuc3RhY2s7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlO1xufVxuYXN5bmMgZnVuY3Rpb24gZXh0cmFjdERhdGEocmVzcG9uc2UpIHtcbiAgLy8gVGhpcyBzYW1lIGFsZ29yaXRobSBpcyB1c2VkIG9uIHRoZSBzZXJ2ZXIgdG8gaW50ZXJwcmV0IGxvYWRcbiAgLy8gcmVzdWx0cyB3aGVuIHdlIHJlbmRlciB0aGUgSFRNTCBwYWdlLlxuICBsZXQgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcblxuICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcbn1cblxuZnVuY3Rpb24gZ2V0QWN0aW9uSW5pdChzdWJtaXNzaW9uLCBzaWduYWwpIHtcbiAgbGV0IHtcbiAgICBlbmNUeXBlLFxuICAgIG1ldGhvZCxcbiAgICBmb3JtRGF0YVxuICB9ID0gc3VibWlzc2lvbjtcbiAgbGV0IGhlYWRlcnMgPSB1bmRlZmluZWQ7XG4gIGxldCBib2R5ID0gZm9ybURhdGE7XG5cbiAgaWYgKGVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpIHtcbiAgICBib2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuXG4gICAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIGZvcm1EYXRhKSB7XG4gICAgICBpbnZhcmlhbnQodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiLCBgRmlsZSBpbnB1dHMgYXJlIG5vdCBzdXBwb3J0ZWQgd2l0aCBlbmNUeXBlIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsIHBsZWFzZSB1c2UgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIgaW5zdGVhZC5gKTtcbiAgICAgIGJvZHkuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGhlYWRlcnMgPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBlbmNUeXBlXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWV0aG9kLFxuICAgIGJvZHksXG4gICAgc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgaGVhZGVyc1xuICB9O1xufVxuXG5leHBvcnQgeyBleHRyYWN0RGF0YSwgZmV0Y2hEYXRhLCBpc0NhdGNoUmVzcG9uc2UsIGlzRXJyb3JSZXNwb25zZSwgaXNSZWRpcmVjdFJlc3BvbnNlIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBBY3Rpb24gfSBmcm9tICdoaXN0b3J5JztcbmltcG9ydCB7IG1hdGNoQ2xpZW50Um91dGVzIH0gZnJvbSAnLi9yb3V0ZU1hdGNoaW5nLmpzJztcbmltcG9ydCBpbnZhcmlhbnQgZnJvbSAnLi9pbnZhcmlhbnQuanMnO1xuXG4vLyBUT0RPOiBXZSBldmVudHVhbGx5IG1pZ2h0IG5vdCB3YW50IHRvIGltcG9ydCBhbnl0aGluZyBkaXJlY3RseSBmcm9tIGBoaXN0b3J5YFxuY2xhc3MgQ2F0Y2hWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKHN0YXR1cywgc3RhdHVzVGV4dCwgZGF0YSkge1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgfVxuXG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBpc0FjdGlvblN1Ym1pc3Npb24oc3VibWlzc2lvbikge1xuICByZXR1cm4gW1wiUE9TVFwiLCBcIlBVVFwiLCBcIlBBVENIXCIsIFwiREVMRVRFXCJdLmluY2x1ZGVzKHN1Ym1pc3Npb24ubWV0aG9kKTtcbn1cblxuZnVuY3Rpb24gaXNMb2FkZXJTdWJtaXNzaW9uKHN1Ym1pc3Npb24pIHtcbiAgcmV0dXJuIHN1Ym1pc3Npb24ubWV0aG9kID09PSBcIkdFVFwiO1xufVxuXG5mdW5jdGlvbiBpc1JlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIEJvb2xlYW4obG9jYXRpb24uc3RhdGUpICYmIGxvY2F0aW9uLnN0YXRlLmlzUmVkaXJlY3Q7XG59XG5cbmZ1bmN0aW9uIGlzTG9hZGVyUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gaXNSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSAmJiBsb2NhdGlvbi5zdGF0ZS50eXBlID09PSBcImxvYWRlclwiO1xufVxuXG5mdW5jdGlvbiBpc0FjdGlvblJlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pIHtcbiAgcmV0dXJuIGlzUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikgJiYgbG9jYXRpb24uc3RhdGUudHlwZSA9PT0gXCJhY3Rpb25cIjtcbn1cblxuZnVuY3Rpb24gaXNGZXRjaEFjdGlvblJlZGlyZWN0KGxvY2F0aW9uKSB7XG4gIHJldHVybiBpc1JlZGlyZWN0TG9jYXRpb24obG9jYXRpb24pICYmIGxvY2F0aW9uLnN0YXRlLnR5cGUgPT09IFwiZmV0Y2hBY3Rpb25cIjtcbn1cblxuZnVuY3Rpb24gaXNMb2FkZXJTdWJtaXNzaW9uUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikge1xuICByZXR1cm4gaXNSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSAmJiBsb2NhdGlvbi5zdGF0ZS50eXBlID09PSBcImxvYWRlclN1Ym1pc3Npb25cIjtcbn1cblxuY2xhc3MgVHJhbnNpdGlvblJlZGlyZWN0IHtcbiAgY29uc3RydWN0b3IobG9jYXRpb24pIHtcbiAgICB0aGlzLmxvY2F0aW9uID0gdHlwZW9mIGxvY2F0aW9uID09PSBcInN0cmluZ1wiID8gbG9jYXRpb24gOiBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaDtcbiAgfVxuXG59XG5jb25zdCBJRExFX1RSQU5TSVRJT04gPSB7XG4gIHN0YXRlOiBcImlkbGVcIixcbiAgc3VibWlzc2lvbjogdW5kZWZpbmVkLFxuICBsb2NhdGlvbjogdW5kZWZpbmVkLFxuICB0eXBlOiBcImlkbGVcIlxufTtcbmNvbnN0IElETEVfRkVUQ0hFUiA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICB0eXBlOiBcImluaXRcIixcbiAgZGF0YTogdW5kZWZpbmVkLFxuICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbn07XG5mdW5jdGlvbiBjcmVhdGVUcmFuc2l0aW9uTWFuYWdlcihpbml0KSB7XG4gIGxldCB7XG4gICAgcm91dGVzXG4gIH0gPSBpbml0O1xuICBsZXQgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyO1xuICBsZXQgZmV0Y2hDb250cm9sbGVycyA9IG5ldyBNYXAoKTtcbiAgbGV0IGluY3JlbWVudGluZ0xvYWRJZCA9IDA7XG4gIGxldCBuYXZpZ2F0aW9uTG9hZElkID0gLTE7XG4gIGxldCBmZXRjaFJlbG9hZElkcyA9IG5ldyBNYXAoKTtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaENsaWVudFJvdXRlcyhyb3V0ZXMsIGluaXQubG9jYXRpb24pO1xuXG4gIGlmICghbWF0Y2hlcykge1xuICAgIC8vIElmIHdlIGRvIG5vdCBtYXRjaCBhIHVzZXItcHJvdmlkZWQtcm91dGUsIGZhbGwgYmFjayB0byB0aGUgcm9vdFxuICAgIC8vIHRvIGFsbG93IHRoZSBDYXRjaEJvdW5kYXJ5IHRvIHRha2Ugb3ZlclxuICAgIG1hdGNoZXMgPSBbe1xuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgcm91dGU6IHJvdXRlc1swXVxuICAgIH1dO1xuICB9XG5cbiAgbGV0IHN0YXRlID0ge1xuICAgIGxvY2F0aW9uOiBpbml0LmxvY2F0aW9uLFxuICAgIGxvYWRlckRhdGE6IGluaXQubG9hZGVyRGF0YSB8fCB7fSxcbiAgICBhY3Rpb25EYXRhOiBpbml0LmFjdGlvbkRhdGEsXG4gICAgY2F0Y2g6IGluaXQuY2F0Y2gsXG4gICAgZXJyb3I6IGluaXQuZXJyb3IsXG4gICAgY2F0Y2hCb3VuZGFyeUlkOiBpbml0LmNhdGNoQm91bmRhcnlJZCB8fCBudWxsLFxuICAgIGVycm9yQm91bmRhcnlJZDogaW5pdC5lcnJvckJvdW5kYXJ5SWQgfHwgbnVsbCxcbiAgICBtYXRjaGVzLFxuICAgIG5leHRNYXRjaGVzOiB1bmRlZmluZWQsXG4gICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OLFxuICAgIGZldGNoZXJzOiBuZXcgTWFwKClcbiAgfTtcblxuICBmdW5jdGlvbiB1cGRhdGUodXBkYXRlcykge1xuICAgIHN0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHVwZGF0ZXMpO1xuICAgIGluaXQub25DaGFuZ2Uoc3RhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmV0Y2hlcihrZXkpIHtcbiAgICByZXR1cm4gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSkgfHwgSURMRV9GRVRDSEVSO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlRmV0Y2hlcihrZXkpIHtcbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgZmV0Y2hSZWxvYWRJZHMuZGVsZXRlKGtleSk7XG4gICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzZW5kKGV2ZW50KSB7XG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwibmF2aWdhdGlvblwiOlxuICAgICAgICB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgICAgc3VibWlzc2lvblxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoQ2xpZW50Um91dGVzKHJvdXRlcywgbG9jYXRpb24pO1xuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgICAgICBtYXRjaGVzID0gW3tcbiAgICAgICAgICAgICAgcGFyYW1zOiB7fSxcbiAgICAgICAgICAgICAgcGF0aG5hbWU6IFwiXCIsXG4gICAgICAgICAgICAgIHJvdXRlOiByb3V0ZXNbMF1cbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTm90Rm91bmROYXZpZ2F0aW9uKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFzdWJtaXNzaW9uICYmIGlzSGFzaENoYW5nZU9ubHkobG9jYXRpb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVIYXNoQ2hhbmdlKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9IC8vIGJhY2svZm9yd2FyZCBidXR0b24sIHRyZWF0IGFsbCBhcyBub3JtYWwgbmF2aWdhdGlvblxuICAgICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PT0gQWN0aW9uLlBvcCkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZChsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyA8Rm9ybSBtZXRob2Q9XCJwb3N0IHwgcHV0IHwgZGVsZXRlIHwgcGF0Y2hcIj5cbiAgICAgICAgICBlbHNlIGlmIChzdWJtaXNzaW9uICYmIGlzQWN0aW9uU3VibWlzc2lvbihzdWJtaXNzaW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlQWN0aW9uU3VibWlzc2lvbk5hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gPEZvcm0gbWV0aG9kPVwiZ2V0XCIvPlxuICAgICAgICAgIGVsc2UgaWYgKHN1Ym1pc3Npb24gJiYgaXNMb2FkZXJTdWJtaXNzaW9uKHN1Ym1pc3Npb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkZXJTdWJtaXNzaW9uTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyBhY3Rpb249PnJlZGlyZWN0XG4gICAgICAgICAgZWxzZSBpZiAoaXNBY3Rpb25SZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlQWN0aW9uUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gPEZvcm0gbWV0aG9kPVwiZ2V0XCI+IC0tPiBsb2FkZXI9PnJlZGlyZWN0XG4gICAgICAgICAgZWxzZSBpZiAoaXNMb2FkZXJTdWJtaXNzaW9uUmVkaXJlY3RMb2NhdGlvbihsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvYWRlclN1Ym1pc3Npb25SZWRpcmVjdChsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICAgICAgfSAvLyBsb2FkZXI9PnJlZGlyZWN0XG4gICAgICAgICAgZWxzZSBpZiAoaXNMb2FkZXJSZWRpcmVjdExvY2F0aW9uKGxvY2F0aW9uKSkge1xuICAgICAgICAgICAgYXdhaXQgaGFuZGxlTG9hZGVyUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gdXNlU3VibWlzc2lvbigpPT5yZWRpcmVjdFxuICAgICAgICAgIGVsc2UgaWYgKGlzRmV0Y2hBY3Rpb25SZWRpcmVjdChsb2NhdGlvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUZldGNoQWN0aW9uUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpO1xuICAgICAgICAgIH0gLy8gPExpbms+LCBuYXZpZ2F0ZSgpXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuYXZpZ2F0aW9uTG9hZElkID0gLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBcImZldGNoZXJcIjpcbiAgICAgICAge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBzdWJtaXNzaW9uLFxuICAgICAgICAgICAgaHJlZlxuICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoQ2xpZW50Um91dGVzKHJvdXRlcywgaHJlZik7XG4gICAgICAgICAgaW52YXJpYW50KG1hdGNoZXMsIFwiTm8gbWF0Y2hlcyBmb3VuZFwiKTtcbiAgICAgICAgICBsZXQgbWF0Y2ggPSBtYXRjaGVzLnNsaWNlKC0xKVswXTtcbiAgICAgICAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG5cbiAgICAgICAgICBpZiAoc3VibWlzc2lvbiAmJiBpc0FjdGlvblN1Ym1pc3Npb24oc3VibWlzc2lvbikpIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUFjdGlvbkZldGNoU3VibWlzc2lvbihrZXksIHN1Ym1pc3Npb24sIG1hdGNoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN1Ym1pc3Npb24gJiYgaXNMb2FkZXJTdWJtaXNzaW9uKHN1Ym1pc3Npb24pKSB7XG4gICAgICAgICAgICBhd2FpdCBoYW5kbGVMb2FkZXJGZXRjaFN1Ym1pc3Npb24oaHJlZiwga2V5LCBzdWJtaXNzaW9uLCBtYXRjaCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGhhbmRsZUxvYWRlckZldGNoKGhyZWYsIGtleSwgbWF0Y2gpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgZXZlbnQgdHlwZTogJHtldmVudC50eXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcblxuICAgIGZvciAobGV0IFssIGNvbnRyb2xsZXJdIG9mIGZldGNoQ29udHJvbGxlcnMpIHtcbiAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb25GZXRjaFN1Ym1pc3Npb24oa2V5LCBzdWJtaXNzaW9uLCBtYXRjaCkge1xuICAgIGxldCBjdXJyZW50RmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25TdWJtaXNzaW9uXCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZGF0YTogKGN1cnJlbnRGZXRjaGVyID09PSBudWxsIHx8IGN1cnJlbnRGZXRjaGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RmV0Y2hlci5kYXRhKSB8fCB1bmRlZmluZWRcbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLnNldChrZXksIGNvbnRyb2xsZXIpO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWxsQWN0aW9uKHN1Ym1pc3Npb24sIG1hdGNoLCBjb250cm9sbGVyLnNpZ25hbCk7XG5cbiAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICBpc1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICB0eXBlOiBcImZldGNoQWN0aW9uXCJcbiAgICAgIH07XG4gICAgICBpbml0Lm9uUmVkaXJlY3QocmVzdWx0LnZhbHVlLmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgICB0eXBlOiBcImRvbmVcIixcbiAgICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLFxuICAgICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXliZUJhaWxPbkVycm9yKG1hdGNoLCBrZXksIHJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYXdhaXQgbWF5YmVCYWlsT25DYXRjaChtYXRjaCwga2V5LCByZXN1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGxvYWRGZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25SZWxvYWRcIixcbiAgICAgIGRhdGE6IHJlc3VsdC52YWx1ZSxcbiAgICAgIHN1Ym1pc3Npb25cbiAgICB9O1xuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGxvYWRGZXRjaGVyKTtcbiAgICB1cGRhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gICAgbGV0IG1heWJlQWN0aW9uRXJyb3JSZXN1bHQgPSBpc0Vycm9yUmVzdWx0KHJlc3VsdCkgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgbGV0IG1heWJlQWN0aW9uQ2F0Y2hSZXN1bHQgPSBpc0NhdGNoUmVzdWx0KHJlc3VsdCkgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGxvYWRJZCA9ICsraW5jcmVtZW50aW5nTG9hZElkO1xuICAgIGZldGNoUmVsb2FkSWRzLnNldChrZXksIGxvYWRJZCk7XG4gICAgbGV0IG1hdGNoZXNUb0xvYWQgPSBzdGF0ZS5uZXh0TWF0Y2hlcyB8fCBzdGF0ZS5tYXRjaGVzO1xuICAgIGxldCBocmVmVG9Mb2FkID0gY3JlYXRlSHJlZihzdGF0ZS50cmFuc2l0aW9uLmxvY2F0aW9uIHx8IHN0YXRlLmxvY2F0aW9uKTtcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxMb2FkZXJzKHN0YXRlLCBjcmVhdGVVcmwoaHJlZlRvTG9hZCksIG1hdGNoZXNUb0xvYWQsIGNvbnRyb2xsZXIuc2lnbmFsLCBtYXliZUFjdGlvbkVycm9yUmVzdWx0LCBtYXliZUFjdGlvbkNhdGNoUmVzdWx0LCBzdWJtaXNzaW9uLCBtYXRjaC5yb3V0ZS5pZCwgbG9hZEZldGNoZXIpO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChyZXN1bHRzKTtcblxuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IFwibG9hZGVyXCJcbiAgICAgIH07XG4gICAgICBpbml0Lm9uUmVkaXJlY3QocmVkaXJlY3QubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBbZXJyb3IsIGVycm9yQm91bmRhcnlJZF0gPSBmaW5kRXJyb3JBbmRCb3VuZGFyeUlkKHJlc3VsdHMsIHN0YXRlLm1hdGNoZXMsIG1heWJlQWN0aW9uRXJyb3JSZXN1bHQpO1xuICAgIGxldCBbY2F0Y2hWYWwsIGNhdGNoQm91bmRhcnlJZF0gPSBhd2FpdCBmaW5kQ2F0Y2hBbmRCb3VuZGFyeUlkKHJlc3VsdHMsIHN0YXRlLm1hdGNoZXMsIG1heWJlQWN0aW9uQ2F0Y2hSZXN1bHQpO1xuICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgIHR5cGU6IFwiZG9uZVwiLFxuICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgbGV0IGFib3J0ZWRLZXlzID0gYWJvcnRTdGFsZUZldGNoTG9hZHMobG9hZElkKTtcblxuICAgIGlmIChhYm9ydGVkS2V5cykge1xuICAgICAgbWFya0ZldGNoZXJzRG9uZShhYm9ydGVkS2V5cyk7XG4gICAgfVxuXG4gICAgbGV0IHllZXRlZE5hdmlnYXRpb24gPSB5ZWV0U3RhbGVOYXZpZ2F0aW9uTG9hZChsb2FkSWQpOyAvLyBuZWVkIHRvIGRvIHdoYXQgd2Ugd291bGQgaGF2ZSBkb25lIHdoZW4gdGhlIG5hdmlnYXRpb24gbG9hZCBjb21wbGV0ZWRcblxuICAgIGlmICh5ZWV0ZWROYXZpZ2F0aW9uKSB7XG4gICAgICBsZXQge1xuICAgICAgICB0cmFuc2l0aW9uXG4gICAgICB9ID0gc3RhdGU7XG4gICAgICBpbnZhcmlhbnQodHJhbnNpdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIsIFwiRXhwZWN0ZWQgbG9hZGluZyB0cmFuc2l0aW9uXCIpO1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgbG9jYXRpb246IHRyYW5zaXRpb24ubG9jYXRpb24sXG4gICAgICAgIG1hdGNoZXM6IHN0YXRlLm5leHRNYXRjaGVzLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgZXJyb3JCb3VuZGFyeUlkLFxuICAgICAgICBjYXRjaDogY2F0Y2hWYWwsXG4gICAgICAgIGNhdGNoQm91bmRhcnlJZCxcbiAgICAgICAgbG9hZGVyRGF0YTogbWFrZUxvYWRlckRhdGEoc3RhdGUsIHJlc3VsdHMsIG1hdGNoZXNUb0xvYWQpLFxuICAgICAgICBhY3Rpb25EYXRhOiB0cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVsb2FkXCIgPyBzdGF0ZS5hY3Rpb25EYXRhIDogdW5kZWZpbmVkLFxuICAgICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT04sXG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSk7XG4gICAgfSAvLyBvdGhlcndpc2UganVzdCB1cGRhdGUgdGhlIGluZm8gZm9yIHRoZSBkYXRhXG4gICAgZWxzZSB7XG4gICAgICB1cGRhdGUoe1xuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycyksXG4gICAgICAgIGVycm9yLFxuICAgICAgICBlcnJvckJvdW5kYXJ5SWQsXG4gICAgICAgIGxvYWRlckRhdGE6IG1ha2VMb2FkZXJEYXRhKHN0YXRlLCByZXN1bHRzLCBtYXRjaGVzVG9Mb2FkKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24geWVldFN0YWxlTmF2aWdhdGlvbkxvYWQobGFuZGVkSWQpIHtcbiAgICBsZXQgaXNMb2FkaW5nTmF2aWdhdGlvbiA9IHN0YXRlLnRyYW5zaXRpb24uc3RhdGUgPT09IFwibG9hZGluZ1wiO1xuXG4gICAgaWYgKGlzTG9hZGluZ05hdmlnYXRpb24gJiYgbmF2aWdhdGlvbkxvYWRJZCA8IGxhbmRlZElkKSB7XG4gICAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtGZXRjaGVyc0RvbmUoa2V5cykge1xuICAgIGZvciAobGV0IGtleSBvZiBrZXlzKSB7XG4gICAgICBsZXQgZmV0Y2hlciA9IGdldEZldGNoZXIoa2V5KTtcbiAgICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgICAgICB0eXBlOiBcImRvbmVcIixcbiAgICAgICAgZGF0YTogZmV0Y2hlci5kYXRhLFxuICAgICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWRcbiAgICAgIH07XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWJvcnRTdGFsZUZldGNoTG9hZHMobGFuZGVkSWQpIHtcbiAgICBsZXQgeWVldGVkS2V5cyA9IFtdO1xuXG4gICAgZm9yIChsZXQgW2tleSwgaWRdIG9mIGZldGNoUmVsb2FkSWRzKSB7XG4gICAgICBpZiAoaWQgPCBsYW5kZWRJZCkge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgICAgICBpbnZhcmlhbnQoZmV0Y2hlciwgYEV4cGVjdGVkIGZldGNoZXI6ICR7a2V5fWApO1xuXG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHllZXRlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHllZXRlZEtleXMubGVuZ3RoID8geWVldGVkS2V5cyA6IGZhbHNlO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVyRmV0Y2hTdWJtaXNzaW9uKGhyZWYsIGtleSwgc3VibWlzc2lvbiwgbWF0Y2gpIHtcbiAgICBsZXQgY3VycmVudEZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICBsZXQgZmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICAgIHR5cGU6IFwibG9hZGVyU3VibWlzc2lvblwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGRhdGE6IChjdXJyZW50RmV0Y2hlciA9PT0gbnVsbCB8fCBjdXJyZW50RmV0Y2hlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEZldGNoZXIuZGF0YSkgfHwgdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBmZXRjaGVyKTtcbiAgICB1cGRhdGUoe1xuICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpXG4gICAgfSk7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBjb250cm9sbGVyKTtcbiAgICBsZXQgcmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlcihtYXRjaCwgY3JlYXRlVXJsKGhyZWYpLCBjb250cm9sbGVyLnNpZ25hbCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcblxuICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGxvY2F0aW9uU3RhdGUgPSB7XG4gICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgIHR5cGU6IFwibG9hZGVyXCJcbiAgICAgIH07XG4gICAgICBpbml0Lm9uUmVkaXJlY3QocmVzdWx0LnZhbHVlLmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWF5YmVCYWlsT25FcnJvcihtYXRjaCwga2V5LCByZXN1bHQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGF3YWl0IG1heWJlQmFpbE9uQ2F0Y2gobWF0Y2gsIGtleSwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBkb25lRmV0Y2hlciA9IHtcbiAgICAgIHN0YXRlOiBcImlkbGVcIixcbiAgICAgIHR5cGU6IFwiZG9uZVwiLFxuICAgICAgZGF0YTogcmVzdWx0LnZhbHVlLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgdXBkYXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVyRmV0Y2goaHJlZiwga2V5LCBtYXRjaCkge1xuICAgIGlmICh0eXBlb2YgQWJvcnRDb250cm9sbGVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYW5kbGVMb2FkZXJGZXRjaCB3YXMgY2FsbGVkIGR1cmluZyB0aGUgc2VydmVyIHJlbmRlciwgYnV0IGl0IHNob3VsZG4ndCBiZS4gXCIgKyBcIllvdSBhcmUgbGlrZWx5IGNhbGxpbmcgdXNlRmV0Y2hlci5sb2FkKCkgaW4gdGhlIGJvZHkgb2YgeW91ciBjb21wb25lbnQuIFwiICsgXCJUcnkgbW92aW5nIGl0IHRvIGEgdXNlRWZmZWN0IG9yIGEgY2FsbGJhY2suXCIpO1xuICAgIH1cblxuICAgIGxldCBjdXJyZW50RmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIGxldCBmZXRjaGVyID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJub3JtYWxMb2FkXCIsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICBkYXRhOiAoY3VycmVudEZldGNoZXIgPT09IG51bGwgfHwgY3VycmVudEZldGNoZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRGZXRjaGVyLmRhdGEpIHx8IHVuZGVmaW5lZFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZmV0Y2hlcik7XG4gICAgdXBkYXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICAgIGxldCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgY29udHJvbGxlcik7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXIobWF0Y2gsIGNyZWF0ZVVybChocmVmKSwgY29udHJvbGxlci5zaWduYWwpO1xuICAgIGlmIChjb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSByZXR1cm47XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcblxuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICBpc1JlZGlyZWN0OiB0cnVlLFxuICAgICAgICB0eXBlOiBcImxvYWRlclwiXG4gICAgICB9O1xuICAgICAgaW5pdC5vblJlZGlyZWN0KHJlc3VsdC52YWx1ZS5sb2NhdGlvbiwgbG9jYXRpb25TdGF0ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1heWJlQmFpbE9uRXJyb3IobWF0Y2gsIGtleSwgcmVzdWx0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChhd2FpdCBtYXliZUJhaWxPbkNhdGNoKG1hdGNoLCBrZXksIHJlc3VsdCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZG9uZUZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJpZGxlXCIsXG4gICAgICB0eXBlOiBcImRvbmVcIixcbiAgICAgIGRhdGE6IHJlc3VsdC52YWx1ZSxcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZFxuICAgIH07XG4gICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIG1heWJlQmFpbE9uQ2F0Y2gobWF0Y2gsIGtleSwgcmVzdWx0KSB7XG4gICAgaWYgKGlzQ2F0Y2hSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IGNhdGNoQm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Q2F0Y2hCb3VuZGFyeShtYXRjaCwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIHVwZGF0ZSh7XG4gICAgICAgIHRyYW5zaXRpb246IElETEVfVFJBTlNJVElPTixcbiAgICAgICAgZmV0Y2hlcnM6IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpLFxuICAgICAgICBjYXRjaDoge1xuICAgICAgICAgIGRhdGE6IHJlc3VsdC52YWx1ZS5kYXRhLFxuICAgICAgICAgIHN0YXR1czogcmVzdWx0LnZhbHVlLnN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiByZXN1bHQudmFsdWUuc3RhdHVzVGV4dFxuICAgICAgICB9LFxuICAgICAgICBjYXRjaEJvdW5kYXJ5SWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVCYWlsT25FcnJvcihtYXRjaCwga2V5LCByZXN1bHQpIHtcbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgZXJyb3JCb3VuZGFyeUlkID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaCwgc3RhdGUubWF0Y2hlcyk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIHVwZGF0ZSh7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKSxcbiAgICAgICAgZXJyb3I6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUlkXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZU5vdEZvdW5kTmF2aWdhdGlvbihsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJub3JtYWxMb2FkXCIsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pOyAvLyBGb3JjZSBhc3luYyBzbyBVSSBjb2RlIGRvZXNuJ3QgaGF2ZSB0byBzcGVjaWFsIG5vdCBmb3VuZCByb3V0ZSBjaGFuZ2VzIG5vdFxuICAgIC8vIHNraXBwaW5nIHRoZSBwZW5kaW5nIHN0YXRlIChsaWtlIHNjcm9sbCByZXN0b3JhdGlvbiBnZXRzIHJlYWxseVxuICAgIC8vIGNvbXBsaWNhdGVkIHdpdGhvdXQgdGhlIHBlbmRpbmcgc3RhdGUsIG1heWJlIHdlIGNhbiBmaWd1cmUgc29tZXRoaW5nIGVsc2VcbiAgICAvLyBvdXQgbGF0ZXIsIGJ1dCB0aGlzIHdvcmtzIGdyZWF0LilcblxuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGxldCBjYXRjaEJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdENhdGNoQm91bmRhcnkobWF0Y2hlc1swXSwgbWF0Y2hlcyk7XG4gICAgdXBkYXRlKHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgbWF0Y2hlcyxcbiAgICAgIGNhdGNoOiB7XG4gICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgICB9LFxuICAgICAgY2F0Y2hCb3VuZGFyeUlkLFxuICAgICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb25TdWJtaXNzaW9uTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25TdWJtaXNzaW9uXCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXG4gICAgaWYgKCFpc0luZGV4UmVxdWVzdEFjdGlvbihzdWJtaXNzaW9uLmFjdGlvbikgJiYgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmlkLmVuZHNXaXRoKFwiL2luZGV4XCIpKSB7XG4gICAgICBtYXRjaGVzID0gbWF0Y2hlcy5zbGljZSgwLCAtMSk7XG4gICAgfVxuXG4gICAgbGV0IGxlYWZNYXRjaCA9IG1hdGNoZXMuc2xpY2UoLTEpWzBdO1xuICAgIGxldCByZXN1bHQgPSBhd2FpdCBjYWxsQWN0aW9uKHN1Ym1pc3Npb24sIGxlYWZNYXRjaCwgY29udHJvbGxlci5zaWduYWwpO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsZXQgbG9jYXRpb25TdGF0ZSA9IHtcbiAgICAgICAgaXNSZWRpcmVjdDogdHJ1ZSxcbiAgICAgICAgdHlwZTogXCJhY3Rpb25cIlxuICAgICAgfTtcbiAgICAgIGluaXQub25SZWRpcmVjdChyZXN1bHQudmFsdWUubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0NhdGNoUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBbY2F0Y2hWYWwsIGNhdGNoQm91bmRhcnlJZF0gPSBhd2FpdCBmaW5kQ2F0Y2hBbmRCb3VuZGFyeUlkKFtyZXN1bHRdLCBtYXRjaGVzLCByZXN1bHQpO1xuICAgICAgdXBkYXRlKHtcbiAgICAgICAgdHJhbnNpdGlvbjogSURMRV9UUkFOU0lUSU9OLFxuICAgICAgICBjYXRjaDogY2F0Y2hWYWwsXG4gICAgICAgIGNhdGNoQm91bmRhcnlJZFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGxvYWRUcmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJhY3Rpb25SZWxvYWRcIixcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb246IGxvYWRUcmFuc2l0aW9uLFxuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBbbGVhZk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LnZhbHVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBsZWFmTWF0Y2gucm91dGUuaWQsIHJlc3VsdCk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVMb2FkZXJTdWJtaXNzaW9uTmF2aWdhdGlvbihsb2NhdGlvbiwgc3VibWlzc2lvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgICAgdHlwZTogXCJsb2FkZXJTdWJtaXNzaW9uXCIsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMsIHN1Ym1pc3Npb24pO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlSGFzaENoYW5nZShsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGxldCB0cmFuc2l0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgdHlwZTogXCJub3JtYWxMb2FkXCIsXG4gICAgICBzdWJtaXNzaW9uOiB1bmRlZmluZWQsXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pOyAvLyBGb3JjZSBhc3luYyBzbyBVSSBjb2RlIGRvZXNuJ3QgaGF2ZSB0byBzcGVjaWFsIGNhc2UgaGFzaCBjaGFuZ2VzIG5vdFxuICAgIC8vIHNraXBwaW5nIHRoZSBwZW5kaW5nIHN0YXRlIChsaWtlIHNjcm9sbCByZXN0b3JhdGlvbiBnZXRzIHJlYWxseVxuICAgIC8vIGNvbXBsaWNhdGVkIHdpdGhvdXQgdGhlIHBlbmRpbmcgc3RhdGUsIG1heWJlIHdlIGNhbiBmaWd1cmUgc29tZXRoaW5nIGVsc2VcbiAgICAvLyBvdXQgbGF0ZXIsIGJ1dCB0aGlzIHdvcmtzIGdyZWF0LilcblxuICAgIGF3YWl0IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHVwZGF0ZSh7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT05cbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWQobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwibm9ybWFsTG9hZFwiLFxuICAgICAgc3VibWlzc2lvbjogdW5kZWZpbmVkLFxuICAgICAgbG9jYXRpb25cbiAgICB9O1xuICAgIHVwZGF0ZSh7XG4gICAgICB0cmFuc2l0aW9uLFxuICAgICAgbmV4dE1hdGNoZXM6IG1hdGNoZXNcbiAgICB9KTtcbiAgICBhd2FpdCBsb2FkUGFnZURhdGEobG9jYXRpb24sIG1hdGNoZXMpO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVyUmVkaXJlY3QobG9jYXRpb24sIG1hdGNoZXMpIHtcbiAgICBhYm9ydE5vcm1hbE5hdmlnYXRpb24oKTtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwibm9ybWFsUmVkaXJlY3RcIixcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUxvYWRlclN1Ym1pc3Npb25SZWRpcmVjdChsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpO1xuICAgIGludmFyaWFudChzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwibG9hZGVyU3VibWlzc2lvblwiLCBgVW5leHBlY3RlZCB0cmFuc2l0aW9uOiAke0pTT04uc3RyaW5naWZ5KHN0YXRlLnRyYW5zaXRpb24pfWApO1xuICAgIGxldCB7XG4gICAgICBzdWJtaXNzaW9uXG4gICAgfSA9IHN0YXRlLnRyYW5zaXRpb247XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcImxvYWRlclN1Ym1pc3Npb25SZWRpcmVjdFwiLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGF3YWl0IGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcywgc3VibWlzc2lvbik7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaEFjdGlvblJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgbGV0IHRyYW5zaXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICB0eXBlOiBcImZldGNoQWN0aW9uUmVkaXJlY3RcIixcbiAgICAgIHN1Ym1pc3Npb246IHVuZGVmaW5lZCxcbiAgICAgIGxvY2F0aW9uXG4gICAgfTtcbiAgICB1cGRhdGUoe1xuICAgICAgdHJhbnNpdGlvbixcbiAgICAgIG5leHRNYXRjaGVzOiBtYXRjaGVzXG4gICAgfSk7XG4gICAgYXdhaXQgbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUFjdGlvblJlZGlyZWN0KGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgYWJvcnROb3JtYWxOYXZpZ2F0aW9uKCk7XG4gICAgaW52YXJpYW50KHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25TdWJtaXNzaW9uXCIgfHwgLy8gbG9hZGVyIHJlZGlyZWN0ZWQgZHVyaW5nIGFjdGlvbiByZWxvYWRcbiAgICBzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVsb2FkXCIsIGBVbmV4cGVjdGVkIHRyYW5zaXRpb246ICR7SlNPTi5zdHJpbmdpZnkoc3RhdGUudHJhbnNpdGlvbil9YCk7XG4gICAgbGV0IHtcbiAgICAgIHN1Ym1pc3Npb25cbiAgICB9ID0gc3RhdGUudHJhbnNpdGlvbjtcbiAgICBsZXQgdHJhbnNpdGlvbiA9IHtcbiAgICAgIHN0YXRlOiBcImxvYWRpbmdcIixcbiAgICAgIHR5cGU6IFwiYWN0aW9uUmVkaXJlY3RcIixcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBsb2NhdGlvblxuICAgIH07XG4gICAgdXBkYXRlKHtcbiAgICAgIHRyYW5zaXRpb24sXG4gICAgICBuZXh0TWF0Y2hlczogbWF0Y2hlc1xuICAgIH0pO1xuICAgIGF3YWl0IGxvYWRQYWdlRGF0YShsb2NhdGlvbiwgbWF0Y2hlcywgc3VibWlzc2lvbik7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hhc2hDaGFuZ2VPbmx5KGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhyZWYoc3RhdGUubG9jYXRpb24pID09PSBjcmVhdGVIcmVmKGxvY2F0aW9uKSAmJiBzdGF0ZS5sb2NhdGlvbi5oYXNoICE9PSBsb2NhdGlvbi5oYXNoO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gbG9hZFBhZ2VEYXRhKGxvY2F0aW9uLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBzdWJtaXNzaW9uUm91dGVJZCwgYWN0aW9uUmVzdWx0KSB7XG4gICAgbGV0IG1heWJlQWN0aW9uRXJyb3JSZXN1bHQgPSBhY3Rpb25SZXN1bHQgJiYgaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpID8gYWN0aW9uUmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIGxldCBtYXliZUFjdGlvbkNhdGNoUmVzdWx0ID0gYWN0aW9uUmVzdWx0ICYmIGlzQ2F0Y2hSZXN1bHQoYWN0aW9uUmVzdWx0KSA/IGFjdGlvblJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICBsZXQgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgIG5hdmlnYXRpb25Mb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICBsZXQgcmVzdWx0cyA9IGF3YWl0IGNhbGxMb2FkZXJzKHN0YXRlLCBjcmVhdGVVcmwoY3JlYXRlSHJlZihsb2NhdGlvbikpLCBtYXRjaGVzLCBjb250cm9sbGVyLnNpZ25hbCwgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCwgbWF5YmVBY3Rpb25DYXRjaFJlc3VsdCwgc3VibWlzc2lvbiwgc3VibWlzc2lvblJvdXRlSWQpO1xuXG4gICAgaWYgKGNvbnRyb2xsZXIuc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgcmVkaXJlY3QgPSBmaW5kUmVkaXJlY3QocmVzdWx0cyk7XG5cbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIC8vIGxvYWRlciByZWRpcmVjdGVkIGR1cmluZyBhbiBhY3Rpb24gcmVsb2FkLCB0cmVhdCBpdCBsaWtlIGFuXG4gICAgICAvLyBhY3Rpb25SZWRpcmVjdCBpbnN0ZWFkIHNvIHRoYXQgYWxsIHRoZSBsb2FkZXJzIGdldCBjYWxsZWQgYWdhaW4gYW5kIHRoZVxuICAgICAgLy8gc3VibWlzc2lvbiBzdGlja3MgYXJvdW5kIGZvciBvcHRpbWlzdGljL3BlbmRpbmcgVUkuXG4gICAgICBpZiAoc3RhdGUudHJhbnNpdGlvbi50eXBlID09PSBcImFjdGlvblJlbG9hZFwiKSB7XG4gICAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgdHlwZTogXCJhY3Rpb25cIlxuICAgICAgICB9O1xuICAgICAgICBpbml0Lm9uUmVkaXJlY3QocmVkaXJlY3QubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwibG9hZGVyU3VibWlzc2lvblwiKSB7XG4gICAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgdHlwZTogXCJsb2FkZXJTdWJtaXNzaW9uXCJcbiAgICAgICAgfTtcbiAgICAgICAgaW5pdC5vblJlZGlyZWN0KHJlZGlyZWN0LmxvY2F0aW9uLCBsb2NhdGlvblN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBsb2NhdGlvblN0YXRlID0ge1xuICAgICAgICAgIGlzUmVkaXJlY3Q6IHRydWUsXG4gICAgICAgICAgdHlwZTogXCJsb2FkZXJcIlxuICAgICAgICB9O1xuICAgICAgICBpbml0Lm9uUmVkaXJlY3QocmVkaXJlY3QubG9jYXRpb24sIGxvY2F0aW9uU3RhdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IFtlcnJvciwgZXJyb3JCb3VuZGFyeUlkXSA9IGZpbmRFcnJvckFuZEJvdW5kYXJ5SWQocmVzdWx0cywgbWF0Y2hlcywgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCk7XG4gICAgbGV0IFtjYXRjaFZhbCwgY2F0Y2hCb3VuZGFyeUlkXSA9IGF3YWl0IGZpbmRDYXRjaEFuZEJvdW5kYXJ5SWQocmVzdWx0cywgbWF0Y2hlcywgbWF5YmVBY3Rpb25FcnJvclJlc3VsdCk7XG4gICAgbGV0IGFib3J0ZWRJZHMgPSBhYm9ydFN0YWxlRmV0Y2hMb2FkcyhuYXZpZ2F0aW9uTG9hZElkKTtcblxuICAgIGlmIChhYm9ydGVkSWRzKSB7XG4gICAgICBtYXJrRmV0Y2hlcnNEb25lKGFib3J0ZWRJZHMpO1xuICAgIH1cblxuICAgIHVwZGF0ZSh7XG4gICAgICBsb2NhdGlvbixcbiAgICAgIG1hdGNoZXMsXG4gICAgICBlcnJvcixcbiAgICAgIGVycm9yQm91bmRhcnlJZCxcbiAgICAgIGNhdGNoOiBjYXRjaFZhbCxcbiAgICAgIGNhdGNoQm91bmRhcnlJZCxcbiAgICAgIGxvYWRlckRhdGE6IG1ha2VMb2FkZXJEYXRhKHN0YXRlLCByZXN1bHRzLCBtYXRjaGVzKSxcbiAgICAgIGFjdGlvbkRhdGE6IHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25SZWxvYWRcIiA/IHN0YXRlLmFjdGlvbkRhdGEgOiB1bmRlZmluZWQsXG4gICAgICB0cmFuc2l0aW9uOiBJRExFX1RSQU5TSVRJT04sXG4gICAgICBmZXRjaGVyczogYWJvcnRlZElkcyA/IG5ldyBNYXAoc3RhdGUuZmV0Y2hlcnMpIDogc3RhdGUuZmV0Y2hlcnNcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0Tm9ybWFsTmF2aWdhdGlvbigpIHtcbiAgICB2YXIgX3BlbmRpbmdOYXZpZ2F0aW9uQ29uO1xuXG4gICAgKF9wZW5kaW5nTmF2aWdhdGlvbkNvbiA9IHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlcikgPT09IG51bGwgfHwgX3BlbmRpbmdOYXZpZ2F0aW9uQ29uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcGVuZGluZ05hdmlnYXRpb25Db24uYWJvcnQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFib3J0RmV0Y2hlcihrZXkpIHtcbiAgICBsZXQgY29udHJvbGxlciA9IGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSk7XG4gICAgaW52YXJpYW50KGNvbnRyb2xsZXIsIGBFeHBlY3RlZCBmZXRjaCBjb250cm9sbGVyOiAke2tleX1gKTtcbiAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc2VuZCxcbiAgICBnZXRTdGF0ZSxcbiAgICBnZXRGZXRjaGVyLFxuICAgIGRlbGV0ZUZldGNoZXIsXG4gICAgZGlzcG9zZSxcblxuICAgIGdldCBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzKCkge1xuICAgICAgcmV0dXJuIGZldGNoQ29udHJvbGxlcnM7XG4gICAgfVxuXG4gIH07XG59IC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIGlzSW5kZXhSZXF1ZXN0QWN0aW9uKGFjdGlvbikge1xuICBsZXQgaW5kZXhSZXF1ZXN0ID0gZmFsc2U7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGFjdGlvbi5zcGxpdChcIj9cIiwgMilbMV0gfHwgXCJcIik7XG5cbiAgZm9yIChsZXQgcGFyYW0gb2Ygc2VhcmNoUGFyYW1zLmdldEFsbChcImluZGV4XCIpKSB7XG4gICAgaWYgKCFwYXJhbSkge1xuICAgICAgaW5kZXhSZXF1ZXN0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5kZXhSZXF1ZXN0O1xufVxuXG5hc3luYyBmdW5jdGlvbiBjYWxsTG9hZGVycyhzdGF0ZSwgdXJsLCBtYXRjaGVzLCBzaWduYWwsIGFjdGlvbkVycm9yUmVzdWx0LCBhY3Rpb25DYXRjaFJlc3VsdCwgc3VibWlzc2lvbiwgc3VibWlzc2lvblJvdXRlSWQsIGZldGNoZXIpIHtcbiAgbGV0IG1hdGNoZXNUb0xvYWQgPSBmaWx0ZXJNYXRjaGVzVG9Mb2FkKHN0YXRlLCB1cmwsIG1hdGNoZXMsIGFjdGlvbkVycm9yUmVzdWx0LCBhY3Rpb25DYXRjaFJlc3VsdCwgc3VibWlzc2lvbiwgc3VibWlzc2lvblJvdXRlSWQsIGZldGNoZXIpO1xuICByZXR1cm4gUHJvbWlzZS5hbGwobWF0Y2hlc1RvTG9hZC5tYXAobWF0Y2ggPT4gY2FsbExvYWRlcihtYXRjaCwgdXJsLCBzaWduYWwpKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGNhbGxMb2FkZXIobWF0Y2gsIHVybCwgc2lnbmFsKSB7XG4gIGludmFyaWFudChtYXRjaC5yb3V0ZS5sb2FkZXIsIGBFeHBlY3RlZCBsb2FkZXIgZm9yICR7bWF0Y2gucm91dGUuaWR9YCk7XG5cbiAgdHJ5IHtcbiAgICBsZXQge1xuICAgICAgcGFyYW1zXG4gICAgfSA9IG1hdGNoO1xuICAgIGxldCB2YWx1ZSA9IGF3YWl0IG1hdGNoLnJvdXRlLmxvYWRlcih7XG4gICAgICBwYXJhbXMsXG4gICAgICB1cmwsXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2gsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoLFxuICAgICAgdmFsdWU6IGVycm9yXG4gICAgfTtcbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjYWxsQWN0aW9uKHN1Ym1pc3Npb24sIG1hdGNoLCBzaWduYWwpIHtcbiAgaWYgKCFtYXRjaC5yb3V0ZS5hY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJvdXRlIFwiJHttYXRjaC5yb3V0ZS5pZH1cIiBkb2VzIG5vdCBoYXZlIGFuIGFjdGlvbiwgYnV0IHlvdSBhcmUgdHJ5aW5nIGAgKyBgdG8gc3VibWl0IHRvIGl0LiBUbyBmaXggdGhpcywgcGxlYXNlIGFkZCBhbiBcXGBhY3Rpb25cXGAgZnVuY3Rpb24gdG8gdGhlIHJvdXRlYCk7XG4gIH1cblxuICB0cnkge1xuICAgIGxldCB2YWx1ZSA9IGF3YWl0IG1hdGNoLnJvdXRlLmFjdGlvbih7XG4gICAgICB1cmw6IGNyZWF0ZVVybChzdWJtaXNzaW9uLmFjdGlvbiksXG4gICAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBzaWduYWxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgbWF0Y2gsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGNoLFxuICAgICAgdmFsdWU6IGVycm9yXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaWx0ZXJNYXRjaGVzVG9Mb2FkKHN0YXRlLCB1cmwsIG1hdGNoZXMsIGFjdGlvbkVycm9yUmVzdWx0LCBhY3Rpb25DYXRjaFJlc3VsdCwgc3VibWlzc2lvbiwgc3VibWlzc2lvblJvdXRlSWQsIGZldGNoZXIpIHtcbiAgLy8gRmlsdGVyIG91dCBhbGwgcm91dGVzIGJlbG93IHRoZSBwcm9ibGVtYXRpYyByb3V0ZSBhcyB0aGV5IGFyZW4ndCBnb2luZ1xuICAvLyB0byByZW5kZXIgc28gd2UgZG9uJ3QgbmVlZCB0byBsb2FkIHRoZW0uXG4gIGlmIChzdWJtaXNzaW9uUm91dGVJZCAmJiAoYWN0aW9uQ2F0Y2hSZXN1bHQgfHwgYWN0aW9uRXJyb3JSZXN1bHQpKSB7XG4gICAgbGV0IGZvdW5kUHJvYmxlbWF0aWNSb3V0ZSA9IGZhbHNlO1xuICAgIG1hdGNoZXMgPSBtYXRjaGVzLmZpbHRlcihtYXRjaCA9PiB7XG4gICAgICBpZiAoZm91bmRQcm9ibGVtYXRpY1JvdXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoLnJvdXRlLmlkID09PSBzdWJtaXNzaW9uUm91dGVJZCkge1xuICAgICAgICBmb3VuZFByb2JsZW1hdGljUm91dGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgbGV0IGlzTmV3ID0gKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIC8vIFthXSAtPiBbYSwgYl1cbiAgICBpZiAoIXN0YXRlLm1hdGNoZXNbaW5kZXhdKSByZXR1cm4gdHJ1ZTsgLy8gW2EsIGJdIC0+IFthLCBjXVxuXG4gICAgcmV0dXJuIG1hdGNoLnJvdXRlLmlkICE9PSBzdGF0ZS5tYXRjaGVzW2luZGV4XS5yb3V0ZS5pZDtcbiAgfTtcblxuICBsZXQgbWF0Y2hQYXRoQ2hhbmdlZCA9IChtYXRjaCwgaW5kZXgpID0+IHtcbiAgICB2YXIgX3N0YXRlJG1hdGNoZXMkaW5kZXgkO1xuXG4gICAgcmV0dXJuICgvLyBwYXJhbSBjaGFuZ2UsIC91c2Vycy8xMjMgLT4gL3VzZXJzLzQ1NlxuICAgICAgc3RhdGUubWF0Y2hlc1tpbmRleF0ucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8IC8vIHNwbGF0IHBhcmFtIGNoYW5nZWQsIHdoaWNoIGlzIG5vdCBwcmVzZW50IGluIG1hdGNoLnBhdGhcbiAgICAgIC8vIGUuZy4gL2ZpbGVzL2ltYWdlcy9hdmF0YXIuanBnIC0+IGZpbGVzL2ZpbmFuY2VzLnhsc1xuICAgICAgKChfc3RhdGUkbWF0Y2hlcyRpbmRleCQgPSBzdGF0ZS5tYXRjaGVzW2luZGV4XS5yb3V0ZS5wYXRoKSA9PT0gbnVsbCB8fCBfc3RhdGUkbWF0Y2hlcyRpbmRleCQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9zdGF0ZSRtYXRjaGVzJGluZGV4JC5lbmRzV2l0aChcIipcIikpICYmIHN0YXRlLm1hdGNoZXNbaW5kZXhdLnBhcmFtc1tcIipcIl0gIT09IG1hdGNoLnBhcmFtc1tcIipcIl1cbiAgICApO1xuICB9O1xuXG4gIGxldCBmaWx0ZXJCeVJvdXRlUHJvcHMgPSAobWF0Y2gsIGluZGV4KSA9PiB7XG4gICAgaWYgKCFtYXRjaC5yb3V0ZS5sb2FkZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChtYXRjaC5yb3V0ZS5zaG91bGRSZWxvYWQpIHtcbiAgICAgIGxldCBwcmV2VXJsID0gY3JlYXRlVXJsKGNyZWF0ZUhyZWYoc3RhdGUubG9jYXRpb24pKTtcbiAgICAgIHJldHVybiBtYXRjaC5yb3V0ZS5zaG91bGRSZWxvYWQoe1xuICAgICAgICBwcmV2VXJsLFxuICAgICAgICB1cmwsXG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICBsZXQgaXNJblJvb3RDYXRjaEJvdW5kYXJ5ID0gc3RhdGUubWF0Y2hlcy5sZW5ndGggPT09IDE7XG5cbiAgaWYgKGlzSW5Sb290Q2F0Y2hCb3VuZGFyeSkge1xuICAgIHJldHVybiBtYXRjaGVzLmZpbHRlcihtYXRjaCA9PiAhIW1hdGNoLnJvdXRlLmxvYWRlcik7XG4gIH1cblxuICBpZiAoKGZldGNoZXIgPT09IG51bGwgfHwgZmV0Y2hlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmV0Y2hlci50eXBlKSA9PT0gXCJhY3Rpb25SZWxvYWRcIikge1xuICAgIHJldHVybiBtYXRjaGVzLmZpbHRlcihmaWx0ZXJCeVJvdXRlUHJvcHMpO1xuICB9IGVsc2UgaWYgKCAvLyBtdXRhdGlvbiwgcmVsb2FkIGZvciBmcmVzaCBkYXRhXG4gIHN0YXRlLnRyYW5zaXRpb24udHlwZSA9PT0gXCJhY3Rpb25SZWxvYWRcIiB8fCBzdGF0ZS50cmFuc2l0aW9uLnR5cGUgPT09IFwiYWN0aW9uUmVkaXJlY3RcIiB8fCAvLyBjbGlja2VkIHRoZSBzYW1lIGxpbmssIHJlc3VibWl0dGVkIGEgR0VUIGZvcm1cbiAgY3JlYXRlSHJlZih1cmwpID09PSBjcmVhdGVIcmVmKHN0YXRlLmxvY2F0aW9uKSB8fCAvLyBzZWFyY2ggYWZmZWN0cyBhbGwgbG9hZGVyc1xuICB1cmwuc2VhcmNoUGFyYW1zLnRvU3RyaW5nKCkgIT09IHN0YXRlLmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlcy5maWx0ZXIoZmlsdGVyQnlSb3V0ZVByb3BzKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaGVzLmZpbHRlcigobWF0Y2gsIGluZGV4LCBhcnIpID0+IHtcbiAgICAvLyBkb24ndCBsb2FkIGVycm9yZWQgYWN0aW9uIHJvdXRlXG4gICAgaWYgKChhY3Rpb25FcnJvclJlc3VsdCB8fCBhY3Rpb25DYXRjaFJlc3VsdCkgJiYgYXJyLmxlbmd0aCAtIDEgPT09IGluZGV4KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoLnJvdXRlLmxvYWRlciAmJiAoaXNOZXcobWF0Y2gsIGluZGV4KSB8fCBtYXRjaFBhdGhDaGFuZ2VkKG1hdGNoLCBpbmRleCkpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC52YWx1ZSBpbnN0YW5jZW9mIFRyYW5zaXRpb25SZWRpcmVjdDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICByZXR1cm4gbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2g7XG59XG5cbmZ1bmN0aW9uIGZpbmRSZWRpcmVjdChyZXN1bHRzKSB7XG4gIGZvciAobGV0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZmluZENhdGNoQW5kQm91bmRhcnlJZChyZXN1bHRzLCBtYXRjaGVzLCBhY3Rpb25DYXRjaFJlc3VsdCkge1xuICBsZXQgbG9hZGVyQ2F0Y2hSZXN1bHQ7XG5cbiAgZm9yIChsZXQgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICBpZiAoaXNDYXRjaFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBsb2FkZXJDYXRjaFJlc3VsdCA9IHJlc3VsdDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGxldCBleHRyYWN0Q2F0Y2hEYXRhID0gYXN5bmMgcmVzID0+ICh7XG4gICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgIHN0YXR1c1RleHQ6IHJlcy5zdGF0dXNUZXh0LFxuICAgIGRhdGE6IHJlcy5kYXRhXG4gIH0pOyAvLyBXZWlyZCBjYXNlIHdoZXJlIGFjdGlvbiB0aHJldywgYW5kIHRoZW4gYSBwYXJlbnQgbG9hZGVyIEFMU08gdGhyZXcsIHdlXG4gIC8vIHVzZSB0aGUgYWN0aW9uIGNhdGNoIGJ1dCB0aGUgbG9hZGVyJ3MgbmVhcmVzdCBib3VuZGFyeSAoY2F1c2Ugd2UgY2FuJ3RcbiAgLy8gcmVuZGVyIGRvd24gdG8gdGhlIGJvdW5kYXJ5IHRoZSBhY3Rpb24gd291bGQgcHJlZmVyKVxuXG5cbiAgaWYgKGFjdGlvbkNhdGNoUmVzdWx0ICYmIGxvYWRlckNhdGNoUmVzdWx0KSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdENhdGNoQm91bmRhcnkobG9hZGVyQ2F0Y2hSZXN1bHQubWF0Y2gsIG1hdGNoZXMpO1xuICAgIHJldHVybiBbYXdhaXQgZXh0cmFjdENhdGNoRGF0YShhY3Rpb25DYXRjaFJlc3VsdC52YWx1ZSksIGJvdW5kYXJ5SWRdO1xuICB9XG5cbiAgaWYgKGxvYWRlckNhdGNoUmVzdWx0KSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdENhdGNoQm91bmRhcnkobG9hZGVyQ2F0Y2hSZXN1bHQubWF0Y2gsIG1hdGNoZXMpO1xuICAgIHJldHVybiBbYXdhaXQgZXh0cmFjdENhdGNoRGF0YShsb2FkZXJDYXRjaFJlc3VsdC52YWx1ZSksIGJvdW5kYXJ5SWRdO1xuICB9XG5cbiAgcmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG59XG5cbmZ1bmN0aW9uIGZpbmRFcnJvckFuZEJvdW5kYXJ5SWQocmVzdWx0cywgbWF0Y2hlcywgYWN0aW9uRXJyb3JSZXN1bHQpIHtcbiAgbGV0IGxvYWRlckVycm9yUmVzdWx0O1xuXG4gIGZvciAobGV0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbG9hZGVyRXJyb3JSZXN1bHQgPSByZXN1bHQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH0gLy8gV2VpcmQgY2FzZSB3aGVyZSBhY3Rpb24gZXJyb3JlZCwgYW5kIHRoZW4gYSBwYXJlbnQgbG9hZGVyIEFMU08gZXJyb3JlZCwgd2VcbiAgLy8gdXNlIHRoZSBhY3Rpb24gZXJyb3IgYnV0IHRoZSBsb2FkZXIncyBuZWFyZXN0IGJvdW5kYXJ5IChjYXVzZSB3ZSBjYW4ndFxuICAvLyByZW5kZXIgZG93biB0byB0aGUgYm91bmRhcnkgdGhlIGFjdGlvbiB3b3VsZCBwcmVmZXIpXG5cblxuICBpZiAoYWN0aW9uRXJyb3JSZXN1bHQgJiYgbG9hZGVyRXJyb3JSZXN1bHQpIHtcbiAgICBsZXQgYm91bmRhcnlJZCA9IGZpbmROZWFyZXN0Qm91bmRhcnkobG9hZGVyRXJyb3JSZXN1bHQubWF0Y2gsIG1hdGNoZXMpO1xuICAgIHJldHVybiBbYWN0aW9uRXJyb3JSZXN1bHQudmFsdWUsIGJvdW5kYXJ5SWRdO1xuICB9XG5cbiAgaWYgKGFjdGlvbkVycm9yUmVzdWx0KSB7XG4gICAgbGV0IGJvdW5kYXJ5SWQgPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KGFjdGlvbkVycm9yUmVzdWx0Lm1hdGNoLCBtYXRjaGVzKTtcbiAgICByZXR1cm4gW2FjdGlvbkVycm9yUmVzdWx0LnZhbHVlLCBib3VuZGFyeUlkXTtcbiAgfVxuXG4gIGlmIChsb2FkZXJFcnJvclJlc3VsdCkge1xuICAgIGxldCBib3VuZGFyeUlkID0gZmluZE5lYXJlc3RCb3VuZGFyeShsb2FkZXJFcnJvclJlc3VsdC5tYXRjaCwgbWF0Y2hlcyk7XG4gICAgcmV0dXJuIFtsb2FkZXJFcnJvclJlc3VsdC52YWx1ZSwgYm91bmRhcnlJZF07XG4gIH1cblxuICByZXR1cm4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXTtcbn1cblxuZnVuY3Rpb24gZmluZE5lYXJlc3RDYXRjaEJvdW5kYXJ5KG1hdGNoV2l0aEVycm9yLCBtYXRjaGVzKSB7XG4gIGxldCBuZWFyZXN0Qm91bmRhcnlJZCA9IG51bGw7XG5cbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5DYXRjaEJvdW5kYXJ5KSB7XG4gICAgICBuZWFyZXN0Qm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIH0gLy8gb25seSBzZWFyY2ggcGFyZW50cyAoc3RvcCBhdCB0aHJvd2luZyBtYXRjaClcblxuXG4gICAgaWYgKG1hdGNoID09PSBtYXRjaFdpdGhFcnJvcikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lYXJlc3RCb3VuZGFyeUlkO1xufVxuXG5mdW5jdGlvbiBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoV2l0aEVycm9yLCBtYXRjaGVzKSB7XG4gIGxldCBuZWFyZXN0Qm91bmRhcnlJZCA9IG51bGw7XG5cbiAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5FcnJvckJvdW5kYXJ5KSB7XG4gICAgICBuZWFyZXN0Qm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICAgIH0gLy8gb25seSBzZWFyY2ggcGFyZW50cyAoc3RvcCBhdCB0aHJvd2luZyBtYXRjaClcblxuXG4gICAgaWYgKG1hdGNoID09PSBtYXRjaFdpdGhFcnJvcikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lYXJlc3RCb3VuZGFyeUlkO1xufVxuXG5mdW5jdGlvbiBtYWtlTG9hZGVyRGF0YShzdGF0ZSwgcmVzdWx0cywgbWF0Y2hlcykge1xuICBsZXQgbmV3RGF0YSA9IHt9O1xuXG4gIGZvciAobGV0IHtcbiAgICBtYXRjaCxcbiAgICB2YWx1ZVxuICB9IG9mIHJlc3VsdHMpIHtcbiAgICBuZXdEYXRhW21hdGNoLnJvdXRlLmlkXSA9IHZhbHVlO1xuICB9XG5cbiAgbGV0IGxvYWRlckRhdGEgPSB7fTtcblxuICBmb3IgKGxldCB7XG4gICAgcm91dGVcbiAgfSBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IHZhbHVlID0gbmV3RGF0YVtyb3V0ZS5pZF0gIT09IHVuZGVmaW5lZCA/IG5ld0RhdGFbcm91dGUuaWRdIDogc3RhdGUubG9hZGVyRGF0YVtyb3V0ZS5pZF07XG5cbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbG9hZGVyRGF0YVtyb3V0ZS5pZF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbG9hZGVyRGF0YTtcbn1cblxuZnVuY3Rpb24gaXNDYXRjaFJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC52YWx1ZSBpbnN0YW5jZW9mIENhdGNoVmFsdWU7XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JSZXN1bHQocmVzdWx0KSB7XG4gIHJldHVybiByZXN1bHQudmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVXJsKGhyZWYpIHtcbiAgcmV0dXJuIG5ldyBVUkwoaHJlZiwgd2luZG93LmxvY2F0aW9uLm9yaWdpbik7XG59XG5cbmV4cG9ydCB7IENhdGNoVmFsdWUsIElETEVfRkVUQ0hFUiwgSURMRV9UUkFOU0lUSU9OLCBUcmFuc2l0aW9uUmVkaXJlY3QsIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBtYXRjaFJvdXRlcyB9IGZyb20gJ3JlYWN0LXJvdXRlci1kb20nO1xuXG4vLyBUT0RPOiBXZSBldmVudHVhbGx5IG1pZ2h0IG5vdCB3YW50IHRvIGltcG9ydCBhbnl0aGluZyBkaXJlY3RseSBmcm9tIGBoaXN0b3J5YFxuZnVuY3Rpb24gbWF0Y2hDbGllbnRSb3V0ZXMocm91dGVzLCBsb2NhdGlvbikge1xuICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb24pO1xuICBpZiAoIW1hdGNoZXMpIHJldHVybiBudWxsO1xuICByZXR1cm4gbWF0Y2hlcy5tYXAobWF0Y2ggPT4gKHtcbiAgICBwYXJhbXM6IG1hdGNoLnBhcmFtcyxcbiAgICBwYXRobmFtZTogbWF0Y2gucGF0aG5hbWUsXG4gICAgcm91dGU6IG1hdGNoLnJvdXRlXG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgbWF0Y2hDbGllbnRSb3V0ZXMgfTtcbiIsICIvKipcbiAqIEByZW1peC1ydW4vcmVhY3QgdjEuMi4zXG4gKlxuICogQ29weXJpZ2h0IChjKSBSZW1peCBTb2Z0d2FyZSBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFLm1kIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxvY2F0aW9uIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSc7XG5pbXBvcnQgeyB1c2VCZWZvcmVVbmxvYWQsIHVzZVRyYW5zaXRpb24gfSBmcm9tICcuL2NvbXBvbmVudHMuanMnO1xuXG5sZXQgU1RPUkFHRV9LRVkgPSBcInBvc2l0aW9uc1wiO1xubGV0IHBvc2l0aW9ucyA9IHt9O1xuXG5pZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIGxldCBzZXNzaW9uUG9zaXRpb25zID0gc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWSk7XG5cbiAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcbiAgICBwb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25Qb3NpdGlvbnMpO1xuICB9XG59XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHdpbGwgZW11bGF0ZSB0aGUgYnJvd3NlcidzIHNjcm9sbCByZXN0b3JhdGlvbiBvbiBsb2NhdGlvblxuICogY2hhbmdlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVtaXgucnVuL2FwaS9yZW1peCNzY3JvbGxyZXN0b3JhdGlvblxuICovXG5cblxuZnVuY3Rpb24gU2Nyb2xsUmVzdG9yYXRpb24oKSB7XG4gIHVzZVNjcm9sbFJlc3RvcmF0aW9uKCk7IC8vIHdhaXQgZm9yIHRoZSBicm93c2VyIHRvIHJlc3RvcmUgaXQgb24gaXRzIG93blxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcIm1hbnVhbFwiO1xuICB9LCBbXSk7IC8vIGxldCB0aGUgYnJvd3NlciByZXN0b3JlIG9uIGl0J3Mgb3duIGZvciByZWZyZXNoXG5cbiAgdXNlQmVmb3JlVW5sb2FkKFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICB3aW5kb3cuaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwiYXV0b1wiO1xuICB9LCBbXSkpO1xuXG4gIGxldCByZXN0b3JlU2Nyb2xsID0gKFNUT1JBR0VfS0VZID0+IHtcbiAgICBpZiAoIXdpbmRvdy5oaXN0b3J5LnN0YXRlIHx8ICF3aW5kb3cuaGlzdG9yeS5zdGF0ZS5rZXkpIHtcbiAgICAgIGxldCBrZXkgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDMyKS5zbGljZSgyKTtcbiAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSh7XG4gICAgICAgIGtleVxuICAgICAgfSwgXCJcIik7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGxldCBwb3NpdGlvbnMgPSBKU09OLnBhcnNlKHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9LRVkpIHx8IFwie31cIik7XG4gICAgICBsZXQgc3RvcmVkWSA9IHBvc2l0aW9uc1t3aW5kb3cuaGlzdG9yeS5zdGF0ZS5rZXldO1xuXG4gICAgICBpZiAodHlwZW9mIHN0b3JlZFkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHN0b3JlZFkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oU1RPUkFHRV9LRVkpO1xuICAgIH1cbiAgfSkudG9TdHJpbmcoKTtcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIiwge1xuICAgIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgX19odG1sOiBgKCR7cmVzdG9yZVNjcm9sbH0pKCR7SlNPTi5zdHJpbmdpZnkoU1RPUkFHRV9LRVkpfSlgXG4gICAgfVxuICB9KTtcbn1cbmxldCBoeWRyYXRlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiB1c2VTY3JvbGxSZXN0b3JhdGlvbigpIHtcbiAgbGV0IGxvY2F0aW9uID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IHRyYW5zaXRpb24gPSB1c2VUcmFuc2l0aW9uKCk7XG4gIGxldCB3YXNTdWJtaXNzaW9uUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHJhbnNpdGlvbi5zdWJtaXNzaW9uKSB7XG4gICAgICB3YXNTdWJtaXNzaW9uUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cbiAgfSwgW3RyYW5zaXRpb25dKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHJhbnNpdGlvbi5sb2NhdGlvbikge1xuICAgICAgcG9zaXRpb25zW2xvY2F0aW9uLmtleV0gPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICB9XG4gIH0sIFt0cmFuc2l0aW9uLCBsb2NhdGlvbl0pO1xuICB1c2VCZWZvcmVVbmxvYWQoUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHBvc2l0aW9ucykpO1xuICB9LCBbXSkpO1xuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgLy8gZG9uJ3QgZG8gYW55dGhpbmcgb24gaHlkcmF0aW9uLCB0aGUgY29tcG9uZW50IGFscmVhZHkgZGlkIHRoaXMgd2l0aCBhblxuICAgICAgLy8gaW5saW5lIHNjcmlwdC5cbiAgICAgIGlmICghaHlkcmF0ZWQpIHtcbiAgICAgICAgaHlkcmF0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCB5ID0gcG9zaXRpb25zW2xvY2F0aW9uLmtleV07IC8vIGJlZW4gaGVyZSBiZWZvcmUsIHNjcm9sbCB0byBpdFxuXG4gICAgICBpZiAoeSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHRyeSB0byBzY3JvbGwgdG8gdGhlIGhhc2hcblxuXG4gICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChsb2NhdGlvbi5oYXNoLnNsaWNlKDEpKTtcblxuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBkb24ndCBkbyBhbnl0aGluZyBvbiBzdWJtaXNzaW9uc1xuXG5cbiAgICAgIGlmICh3YXNTdWJtaXNzaW9uUmVmLmN1cnJlbnQgPT09IHRydWUpIHtcbiAgICAgICAgd2FzU3VibWlzc2lvblJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gb3RoZXJ3aXNlIGdvIHRvIHRoZSB0b3Agb24gbmV3IGxvY2F0aW9uc1xuXG5cbiAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbiAgICB9LCBbbG9jYXRpb25dKTtcbiAgfVxuXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRyYW5zaXRpb24uc3VibWlzc2lvbikge1xuICAgICAgd2FzU3VibWlzc2lvblJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICB9XG4gIH0sIFt0cmFuc2l0aW9uXSk7XG59XG5cbmV4cG9ydCB7IFNjcm9sbFJlc3RvcmF0aW9uIH07XG4iLCAiLyoqXG4gKiBAcmVtaXgtcnVuL3JlYWN0IHYxLjIuM1xuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgeyBBY3Rpb24sIGNyZWF0ZVBhdGggfSBmcm9tICdoaXN0b3J5JztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlbWl4RW50cnkgfSBmcm9tICcuL2NvbXBvbmVudHMuanMnO1xuXG4vLyBUT0RPOiBXZSBldmVudHVhbGx5IG1pZ2h0IG5vdCB3YW50IHRvIGltcG9ydCBhbnl0aGluZyBkaXJlY3RseSBmcm9tIGBoaXN0b3J5YFxuXG4vKipcbiAqIFRoZSBlbnRyeSBwb2ludCBmb3IgYSBSZW1peCBhcHAgd2hlbiBpdCBpcyByZW5kZXJlZCBvbiB0aGUgc2VydmVyIChpblxuICogYGFwcC9lbnRyeS5zZXJ2ZXIuanNgKS4gVGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byBnZW5lcmF0ZSB0aGUgSFRNTCBpbiB0aGVcbiAqIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlci5cbiAqL1xuZnVuY3Rpb24gUmVtaXhTZXJ2ZXIoe1xuICBjb250ZXh0LFxuICB1cmxcbn0pIHtcbiAgaWYgKHR5cGVvZiB1cmwgPT09IFwic3RyaW5nXCIpIHtcbiAgICB1cmwgPSBuZXcgVVJMKHVybCk7XG4gIH1cblxuICBsZXQgbG9jYXRpb24gPSB7XG4gICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICBzZWFyY2g6IHVybC5zZWFyY2gsXG4gICAgaGFzaDogXCJcIixcbiAgICBzdGF0ZTogbnVsbCxcbiAgICBrZXk6IFwiZGVmYXVsdFwiXG4gIH07XG4gIGxldCBzdGF0aWNOYXZpZ2F0b3IgPSB7XG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gICAgfSxcblxuICAgIHB1c2godG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnB1c2goKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC4gVGhpcyBlcnJvciB3YXMgcHJvYmFibHkgdHJpZ2dlcmVkIHdoZW4geW91IGRpZCBhIGAgKyBgXFxgbmF2aWdhdGUoJHtKU09OLnN0cmluZ2lmeSh0byl9KVxcYCBzb21ld2hlcmUgaW4geW91ciBhcHAuYCk7XG4gICAgfSxcblxuICAgIHJlcGxhY2UodG8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLnJlcGxhY2UoKSBvbiB0aGUgc2VydmVyIGJlY2F1c2UgaXQgaXMgYSBzdGF0ZWxlc3MgYCArIGBlbnZpcm9ubWVudC4gVGhpcyBlcnJvciB3YXMgcHJvYmFibHkgdHJpZ2dlcmVkIHdoZW4geW91IGRpZCBhIGAgKyBgXFxgbmF2aWdhdGUoJHtKU09OLnN0cmluZ2lmeSh0byl9LCB7IHJlcGxhY2U6IHRydWUgfSlcXGAgc29tZXdoZXJlIGAgKyBgaW4geW91ciBhcHAuYCk7XG4gICAgfSxcblxuICAgIGdvKGRlbHRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBjYW5ub3QgdXNlIG5hdmlnYXRvci5nbygpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LiBUaGlzIGVycm9yIHdhcyBwcm9iYWJseSB0cmlnZ2VyZWQgd2hlbiB5b3UgZGlkIGEgYCArIGBcXGBuYXZpZ2F0ZSgke2RlbHRhfSlcXGAgc29tZXdoZXJlIGluIHlvdXIgYXBwLmApO1xuICAgIH0sXG5cbiAgICBiYWNrKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuYmFjaygpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LmApO1xuICAgIH0sXG5cbiAgICBmb3J3YXJkKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgY2Fubm90IHVzZSBuYXZpZ2F0b3IuZm9yd2FyZCgpIG9uIHRoZSBzZXJ2ZXIgYmVjYXVzZSBpdCBpcyBhIHN0YXRlbGVzcyBgICsgYGVudmlyb25tZW50LmApO1xuICAgIH0sXG5cbiAgICBibG9jaygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgWW91IGNhbm5vdCB1c2UgbmF2aWdhdG9yLmJsb2NrKCkgb24gdGhlIHNlcnZlciBiZWNhdXNlIGl0IGlzIGEgc3RhdGVsZXNzIGAgKyBgZW52aXJvbm1lbnQuYCk7XG4gICAgfVxuXG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZW1peEVudHJ5LCB7XG4gICAgY29udGV4dDogY29udGV4dCxcbiAgICBhY3Rpb246IEFjdGlvbi5Qb3AsXG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIG5hdmlnYXRvcjogc3RhdGljTmF2aWdhdG9yLFxuICAgIHN0YXRpYzogdHJ1ZVxuICB9KTtcbn1cblxuZXhwb3J0IHsgUmVtaXhTZXJ2ZXIgfTtcbiIsICIvLyBpbXBvcnQgZm9udGF3c29tZUJyYW5kc0NzcyBmcm9tIFwiLi9zdHlsZXMvZm9udGF3c29tZS9icmFuZHMubWluLmNzc1wiO1xuaW1wb3J0IGJvb3RzdHJhcENzcyBmcm9tICdib290c3RyYXAvZGlzdC9jc3MvYm9vdHN0cmFwLm1pbi5jc3MnO1xuaW1wb3J0IHsgTGlua3MsIExpbmtzRnVuY3Rpb24sIExpdmVSZWxvYWQsIE1ldGEsIE91dGxldCwgU2NyaXB0cywgU2Nyb2xsUmVzdG9yYXRpb24gfSBmcm9tICdyZW1peCc7XG5cbi8vIGltcG9ydCBmb250YXdzb21lQ3NzIGZyb20gJy4vc3R5bGVzL2ZvbnRhd3NvbWUvYWxsLm1pbi5jc3MnO1xuaW1wb3J0IGluZGV4Q3NzIGZyb20gJy4vc3R5bGVzL2luZGV4LmNzcyc7XG5cbmltcG9ydCB0eXBlIHsgTWV0YUZ1bmN0aW9uIH0gZnJvbSBcInJlbWl4XCI7XG5cbmV4cG9ydCBjb25zdCBtZXRhOiBNZXRhRnVuY3Rpb24gPSAoKSA9PiB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gXCJIZXkhIFdlbGNvbWUgdG8gbXkgd2Vic2l0ZSB3aGVyZSBJIHNoYXJlIG15IGV4cGVyaWVuY2UgYW5kIHByb2plY3RzIFx1RDgzRFx1REM0QlwiO1xuICByZXR1cm4ge1xuICAgIGNoYXJzZXQ6IFwidXRmLThcIixcbiAgICBkZXNjcmlwdGlvbixcbiAgICBrZXl3b3JkczogXCJEZW5pcyBGZXRpbmluLEdvbGFuZyBkZXZlbG9wZXIsU29mdHdhcmUgRGV2ZWxvcGVyXCIsXG4gICAgdGl0bGU6IFwiRGVuaXMgRmV0aW5pbiB8IFNvZnR3YXJlIGRldmVsb3BlclwiLFxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbGlua3M6IExpbmtzRnVuY3Rpb24gPSAoKSA9PiB7XG4gIHJldHVybiBbXG4gICAge1xuICAgICAgcmVsOiBcInN0eWxlc2hlZXRcIixcbiAgICAgIGhyZWY6IFwiZm9udGF3c29tZS9hbGwubWluLmNzc1wiLFxuICAgIH0sXG4gICAge1xuICAgICAgcmVsOiBcInN0eWxlc2hlZXRcIixcbiAgICAgIGhyZWY6IFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2Rldmljb25zL2Rldmljb25AdjIuMTQuMC9kZXZpY29uLm1pbi5jc3NcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlbDogXCJzdHlsZXNoZWV0XCIsXG4gICAgICBocmVmOiBpbmRleENzcyxcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlbDogXCJzdHlsZXNoZWV0XCIsXG4gICAgICBocmVmOiBib290c3RyYXBDc3MsXG4gICAgfSxcbiAgXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFwcCgpIHtcbiAgcmV0dXJuIChcbiAgICA8aHRtbCBsYW5nPVwiZW5cIj5cbiAgICAgIDxoZWFkPlxuICAgICAgICA8bWV0YSBjaGFyU2V0PVwidXRmLThcIiAvPlxuICAgICAgICA8bWV0YSBuYW1lPVwidmlld3BvcnRcIiBjb250ZW50PVwid2lkdGg9ZGV2aWNlLXdpZHRoLGluaXRpYWwtc2NhbGU9MVwiIC8+XG4gICAgICAgIDxNZXRhIC8+XG4gICAgICAgIDxMaW5rcyAvPlxuICAgICAgPC9oZWFkPlxuICAgICAgPGJvZHk+XG4gICAgICAgIDxPdXRsZXQgLz5cbiAgICAgICAgPFNjcm9sbFJlc3RvcmF0aW9uIC8+XG4gICAgICAgIDxTY3JpcHRzIC8+XG4gICAgICAgIDxMaXZlUmVsb2FkIC8+XG4gICAgICAgIDxzY3JpcHQgc3JjPVwiaHR0cHM6Ly9jb2RlLmljb25pZnkuZGVzaWduLzEvMS4wLjcvaWNvbmlmeS5taW4uanNcIj48L3NjcmlwdD5cbiAgICAgIDwvYm9keT5cbiAgICA8L2h0bWw+XG4gICk7XG59XG4iLCAiaW1wb3J0IHJlYWN0VGltZWxpbmVDc3MgZnJvbSAncmVhY3QtdmVydGljYWwtdGltZWxpbmUtY29tcG9uZW50L3N0eWxlLm1pbi5jc3MnO1xuaW1wb3J0IHsgTGlua3NGdW5jdGlvbiB9IGZyb20gJ3JlbWl4JztcbmltcG9ydCBBYm91dCBmcm9tICd+L2NvbXBvbmVudHMvYWJvdXQnO1xuaW1wb3J0IEV4cGVyaWVuY2UgZnJvbSAnfi9jb21wb25lbnRzL2V4cGVyaWVuY2UnO1xuaW1wb3J0IEZvb3RlciBmcm9tICd+L2NvbXBvbmVudHMvZm9vdGVyJztcbmltcG9ydCBIZWFkZXIgZnJvbSAnfi9jb21wb25lbnRzL2hlYWRlcic7XG5pbXBvcnQgU2tpbGxzIGZyb20gJ34vY29tcG9uZW50cy9za2lsbHMnO1xuaW1wb3J0IGV4cGVyaWVuY2VEYXRhIGZyb20gJ34vcmVzdW1lX2NvbnRlbnQvZXhwZXJpZW5jZSc7XG5pbXBvcnQgeyBza2lsbHMgfSBmcm9tICd+L3Jlc3VtZV9jb250ZW50L3NraWxscyc7XG5pbXBvcnQgc29jaWFsRGF0YSBmcm9tICd+L3Jlc3VtZV9jb250ZW50L3NvY2lhbCc7XG5pbXBvcnQgYXBwQ3NzIGZyb20gJ34vc3R5bGVzL2FwcC5jc3MnO1xuXG5leHBvcnQgY29uc3QgbGlua3M6IExpbmtzRnVuY3Rpb24gPSAoKSA9PiB7XG4gIHJldHVybiBbXG4gICAgeyByZWw6IFwic3R5bGVzaGVldFwiLCBocmVmOiByZWFjdFRpbWVsaW5lQ3NzIH0sXG4gICAgeyByZWw6IFwic3R5bGVzaGVldFwiLCBocmVmOiBhcHBDc3MgfSxcbiAgXTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEluZGV4KCkge1xuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICA8SGVhZGVyIC8+XG4gICAgICA8QWJvdXQvPlxuICAgICAgey8qIDxQcm9qZWN0cyBwcm9qZWN0cz17cHJvamVjdHNEYXRhfSAvPiAqL31cbiAgICAgIDxTa2lsbHMgc2tpbGxzPXtza2lsbHN9IC8+XG4gICAgICA8RXhwZXJpZW5jZSBleHBpcmllbmNlPXtleHBlcmllbmNlRGF0YX0gLz5cbiAgICAgIDxGb290ZXIgc29jaWFsPXtzb2NpYWxEYXRhfS8+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCAiaW1wb3J0IGdvbGFuZ0ljb24gZnJvbSAnQGljb25pZnkvaWNvbnMtZmE2LWJyYW5kcy9nb2xhbmcnO1xuaW1wb3J0IGt1YmVybmV0ZXNJY29uIGZyb20gJ0BpY29uaWZ5L2ljb25zLWxvZ29zL2t1YmVybmV0ZXMnO1xuaW1wb3J0IHB5dGhvbkljb24gZnJvbSAnQGljb25pZnkvaWNvbnMtbG9nb3MvcHl0aG9uJztcbmltcG9ydCB7IEljb24gfSBmcm9tICdAaWNvbmlmeS9yZWFjdCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFib3V0KCkge1xuICByZXR1cm4gKFxuICAgIDxzZWN0aW9uIGlkPVwiYWJvdXRcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLW1kLTEyXCI+XG4gICAgICAgIDxoMSBzdHlsZT17eyBjb2xvcjogXCJibGFja1wiIH19PlxuICAgICAgICAgIDxzcGFuPkFib3V0IG1lPC9zcGFuPlxuICAgICAgICA8L2gxPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvdyBjZW50ZXIgbXgtYXV0byBtYi01XCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtbWQtNCBtYi01IGNlbnRlclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwb2xhcm9pZFwiPlxuICAgICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBjdXJzb3I6IFwiYXV0b1wiIH19PlxuICAgICAgICAgICAgICAgIDxpbWcgc3JjPVwiaW1hZ2VzL215UHJvZmlsZS53ZWJwXCIgYWx0PVwiTXkgcHJvZmlsZSBwaWN0dXJlXCIgLz5cbiAgICAgICAgICAgICAgICA8SWNvbiBpY29uPXtnb2xhbmdJY29ufSBzdHlsZT17eyBmb250U2l6ZTogXCI0MDAlXCIsIG1hcmdpbjogXCI5JSA1JSAwIDUlXCIsIGNvbG9yOiBcIiMwMEFERDhcIiB9fSAvPlxuICAgICAgICAgICAgICAgIDxJY29uIGljb249e3B5dGhvbkljb259IHN0eWxlPXt7IGZvbnRTaXplOiBcIjQwMCVcIiwgbWFyZ2luOiBcIjklIDUlIDAgNSVcIiB9fSAvPlxuICAgICAgICAgICAgICAgIDxJY29uIGljb249e2t1YmVybmV0ZXNJY29ufSBzdHlsZT17eyBmb250U2l6ZTogXCI0MDAlXCIsIG1hcmdpbjogXCI5JSA1JSAwIDUlXCIgfX0gLz5cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1tZC04IGNlbnRlclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtbWQtMTBcIj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cImVtb2ppb25lOnJlZC1jaXJjbGVcIiBkYXRhLWlubGluZT1cImZhbHNlXCI+PC9zcGFuPiAmbmJzcDt7XCIgXCJ9XG4gICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJpY29uaWZ5XCIgZGF0YS1pY29uPVwidHdlbW9qaTp5ZWxsb3ctY2lyY2xlXCIgZGF0YS1pbmxpbmU9XCJmYWxzZVwiPjwvc3Bhbj4gJm5ic3A7e1wiIFwifVxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaWNvbmlmeVwiIGRhdGEtaWNvbj1cInR3ZW1vamk6Z3JlZW4tY2lyY2xlXCIgZGF0YS1pbmxpbmU9XCJmYWxzZVwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjYXJkLWJvZHkgZm9udC10cmVidWNoZXQgdGV4dC1qdXN0aWZ5IG1sLTMgbXItM1wiXG4gICAgICAgICAgICAgICAgICBzdHlsZT17e1xuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgICAgICBmb250U2l6ZTogXCIxMzIlXCIsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IFwiMjAwJVwiLFxuICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cIndhdmVcIj5IaSBcdUQ4M0RcdURDNEI8L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8YnIgLz5cbiAgICAgICAgICAgICAgICAgIDxiciAvPlxuICAgICAgICAgICAgICAgICAgPHA+SSdtIERlbmlzIEZldGluaW4uIEdvbGFuZyBhbmQgUHl0aG9uIGRldmVsb3BlciB0aGF0IGxvdmVzIGJ1aWxkaW5nIHNvZnR3YXJlLiA6KTwvcD5cbiAgICAgICAgICAgICAgICAgIDxwPlNlY3JldGx5IGxvdmUgZnJvbnRlbmQgYnV0IG1vc3Qgb2YgdGhlIHRpbWUgd29yayBhcyBhIGJhY2tlbmQgZGV2ZWxvcGVyLiBJIGhhdmUgZXhwaXJpZW5jZSB3aXRoIG1pY3Jvc2VydmljZXMgYW5kIGV2ZW50LWRyaXZlbiBhcmNoaXRlY3R1cmUuIFdvcmtlZCBpbiBFLWNvbW1lcmNlIG9uIGFwcHMgYW5kIHdlYnNpdGUgYmFja2VuZCwgZGlzY291bnRzLCBjYXRhbG9nLCBwcmljaW5nLCBjaGVja291dCwgY2FydCBhbmQgb3RoZXIgc3lzdGVtcy48L3A+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9zZWN0aW9uPlxuICApO1xufVxuIiwgImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbi8vIHNyYy9pY29uL2luZGV4LnRzXG52YXIgbWF0Y2hOYW1lID0gL15bYS16MC05XSsoLVthLXowLTldKykqJC87XG52YXIgaWNvbkRlZmF1bHRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGxlZnQ6IDAsXG4gIHRvcDogMCxcbiAgd2lkdGg6IDE2LFxuICBoZWlnaHQ6IDE2LFxuICByb3RhdGU6IDAsXG4gIHZGbGlwOiBmYWxzZSxcbiAgaEZsaXA6IGZhbHNlXG59KTtcbmZ1bmN0aW9uIGZ1bGxJY29uKGRhdGEpIHtcbiAgcmV0dXJuIHsgLi4uaWNvbkRlZmF1bHRzLCAuLi5kYXRhIH07XG59XG5cbi8vIHNyYy9pY29uL25hbWUudHNcbnZhciBzdHJpbmdUb0ljb24gPSAodmFsdWUsIHZhbGlkYXRlLCBhbGxvd1NpbXBsZU5hbWUsIHByb3ZpZGVyID0gXCJcIikgPT4ge1xuICBjb25zdCBjb2xvblNlcGFyYXRlZCA9IHZhbHVlLnNwbGl0KFwiOlwiKTtcbiAgaWYgKHZhbHVlLnNsaWNlKDAsIDEpID09PSBcIkBcIikge1xuICAgIGlmIChjb2xvblNlcGFyYXRlZC5sZW5ndGggPCAyIHx8IGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBwcm92aWRlciA9IGNvbG9uU2VwYXJhdGVkLnNoaWZ0KCkuc2xpY2UoMSk7XG4gIH1cbiAgaWYgKGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDMgfHwgIWNvbG9uU2VwYXJhdGVkLmxlbmd0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjb2xvblNlcGFyYXRlZC5sZW5ndGggPiAxKSB7XG4gICAgY29uc3QgbmFtZTIgPSBjb2xvblNlcGFyYXRlZC5wb3AoKTtcbiAgICBjb25zdCBwcmVmaXggPSBjb2xvblNlcGFyYXRlZC5wb3AoKTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwcm92aWRlcjogY29sb25TZXBhcmF0ZWQubGVuZ3RoID4gMCA/IGNvbG9uU2VwYXJhdGVkWzBdIDogcHJvdmlkZXIsXG4gICAgICBwcmVmaXgsXG4gICAgICBuYW1lOiBuYW1lMlxuICAgIH07XG4gICAgcmV0dXJuIHZhbGlkYXRlICYmICF2YWxpZGF0ZUljb24ocmVzdWx0KSA/IG51bGwgOiByZXN1bHQ7XG4gIH1cbiAgY29uc3QgbmFtZSA9IGNvbG9uU2VwYXJhdGVkWzBdO1xuICBjb25zdCBkYXNoU2VwYXJhdGVkID0gbmFtZS5zcGxpdChcIi1cIik7XG4gIGlmIChkYXNoU2VwYXJhdGVkLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBwcm92aWRlcixcbiAgICAgIHByZWZpeDogZGFzaFNlcGFyYXRlZC5zaGlmdCgpLFxuICAgICAgbmFtZTogZGFzaFNlcGFyYXRlZC5qb2luKFwiLVwiKVxuICAgIH07XG4gICAgcmV0dXJuIHZhbGlkYXRlICYmICF2YWxpZGF0ZUljb24ocmVzdWx0KSA/IG51bGwgOiByZXN1bHQ7XG4gIH1cbiAgaWYgKGFsbG93U2ltcGxlTmFtZSAmJiBwcm92aWRlciA9PT0gXCJcIikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgbmFtZVxuICAgIH07XG4gICAgcmV0dXJuIHZhbGlkYXRlICYmICF2YWxpZGF0ZUljb24ocmVzdWx0LCBhbGxvd1NpbXBsZU5hbWUpID8gbnVsbCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG52YXIgdmFsaWRhdGVJY29uID0gKGljb24sIGFsbG93U2ltcGxlTmFtZSkgPT4ge1xuICBpZiAoIWljb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuICEhKChpY29uLnByb3ZpZGVyID09PSBcIlwiIHx8IGljb24ucHJvdmlkZXIubWF0Y2gobWF0Y2hOYW1lKSkgJiYgKGFsbG93U2ltcGxlTmFtZSAmJiBpY29uLnByZWZpeCA9PT0gXCJcIiB8fCBpY29uLnByZWZpeC5tYXRjaChtYXRjaE5hbWUpKSAmJiBpY29uLm5hbWUubWF0Y2gobWF0Y2hOYW1lKSk7XG59O1xuXG4vLyBzcmMvaWNvbi9tZXJnZS50c1xuZnVuY3Rpb24gbWVyZ2VJY29uRGF0YShpY29uLCBhbGlhcykge1xuICBjb25zdCByZXN1bHQgPSB7IC4uLmljb24gfTtcbiAgZm9yIChjb25zdCBrZXkgaW4gaWNvbkRlZmF1bHRzKSB7XG4gICAgY29uc3QgcHJvcCA9IGtleTtcbiAgICBpZiAoYWxpYXNbcHJvcF0gIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBhbGlhc1twcm9wXTtcbiAgICAgIGlmIChyZXN1bHRbcHJvcF0gPT09IHZvaWQgMCkge1xuICAgICAgICByZXN1bHRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHByb3ApIHtcbiAgICAgICAgY2FzZSBcInJvdGF0ZVwiOlxuICAgICAgICAgIHJlc3VsdFtwcm9wXSA9IChyZXN1bHRbcHJvcF0gKyB2YWx1ZSkgJSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaEZsaXBcIjpcbiAgICAgICAgY2FzZSBcInZGbGlwXCI6XG4gICAgICAgICAgcmVzdWx0W3Byb3BdID0gdmFsdWUgIT09IHJlc3VsdFtwcm9wXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXN1bHRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL2ljb24tc2V0L2dldC1pY29uLnRzXG5mdW5jdGlvbiBnZXRJY29uRGF0YSQxKGRhdGEsIG5hbWUsIGZ1bGwgPSBmYWxzZSkge1xuICBmdW5jdGlvbiBnZXRJY29uKG5hbWUyLCBpdGVyYXRpb24pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKGRhdGEuaWNvbnNbbmFtZTJdICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkYXRhLmljb25zW25hbWUyXSk7XG4gICAgfVxuICAgIGlmIChpdGVyYXRpb24gPiA1KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCgoX2EgPSBkYXRhLmFsaWFzZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYVtuYW1lMl0pICE9PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSAoX2IgPSBkYXRhLmFsaWFzZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYltuYW1lMl07XG4gICAgICBjb25zdCByZXN1bHQyID0gZ2V0SWNvbihpdGVtLnBhcmVudCwgaXRlcmF0aW9uICsgMSk7XG4gICAgICBpZiAocmVzdWx0Mikge1xuICAgICAgICByZXR1cm4gbWVyZ2VJY29uRGF0YShyZXN1bHQyLCBpdGVtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQyO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0aW9uID09PSAwICYmICgoX2MgPSBkYXRhLmNoYXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2NbbmFtZTJdKSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZ2V0SWNvbigoX2QgPSBkYXRhLmNoYXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2RbbmFtZTJdLCBpdGVyYXRpb24gKyAxKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gZ2V0SWNvbihuYW1lLCAwKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGljb25EZWZhdWx0cykge1xuICAgICAgaWYgKHJlc3VsdFtrZXldID09PSB2b2lkIDAgJiYgZGF0YVtrZXldICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBkYXRhW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQgJiYgZnVsbCA/IGZ1bGxJY29uKHJlc3VsdCkgOiByZXN1bHQ7XG59XG5cbi8vIHNyYy9pY29uLXNldC92YWxpZGF0ZS50c1xudmFyIG1hdGNoQ2hhciA9IC9eW2EtZjAtOV0rKC1bYS1mMC05XSspKiQvO1xuZnVuY3Rpb24gdmFsaWRhdGVJY29uUHJvcHMoaXRlbSwgZml4KSB7XG4gIGZvciAoY29uc3Qga2V5IGluIGl0ZW0pIHtcbiAgICBjb25zdCBhdHRyID0ga2V5O1xuICAgIGNvbnN0IHZhbHVlID0gaXRlbVthdHRyXTtcbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIGlmICh0eXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBkZWxldGUgaXRlbVthdHRyXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSBcImJvZHlcIjpcbiAgICAgIGNhc2UgXCJwYXJlbnRcIjpcbiAgICAgICAgaWYgKHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImhGbGlwXCI6XG4gICAgICBjYXNlIFwidkZsaXBcIjpcbiAgICAgIGNhc2UgXCJoaWRkZW5cIjpcbiAgICAgICAgaWYgKHR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgaWYgKGZpeCkge1xuICAgICAgICAgICAgZGVsZXRlIGl0ZW1bYXR0cl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIndpZHRoXCI6XG4gICAgICBjYXNlIFwiaGVpZ2h0XCI6XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgY2FzZSBcInJvdGF0ZVwiOlxuICAgICAgY2FzZSBcImlubGluZUhlaWdodFwiOlxuICAgICAgY2FzZSBcImlubGluZVRvcFwiOlxuICAgICAgY2FzZSBcInZlcnRpY2FsQWxpZ25cIjpcbiAgICAgICAgaWYgKHR5cGUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBpZiAoZml4KSB7XG4gICAgICAgICAgICBkZWxldGUgaXRlbVthdHRyXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmIChmaXgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBpdGVtW2F0dHJdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlSWNvblNldChvYmosIG9wdGlvbnMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCBmaXggPSAhIShvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmZpeCk7XG4gIGlmICh0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiIHx8IG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqLmljb25zICE9PSBcIm9iamVjdFwiIHx8ICFvYmouaWNvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgaWNvbiBzZXRcIik7XG4gIH1cbiAgY29uc3QgZGF0YSA9IG9iajtcbiAgaWYgKHR5cGVvZiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5wcmVmaXgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgZGF0YS5wcmVmaXggPSBvcHRpb25zLnByZWZpeDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YS5wcmVmaXggIT09IFwic3RyaW5nXCIgfHwgIWRhdGEucHJlZml4Lm1hdGNoKG1hdGNoTmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHByZWZpeFwiKTtcbiAgfVxuICBpZiAodHlwZW9mIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnByb3ZpZGVyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGRhdGEucHJvdmlkZXIgPSBvcHRpb25zLnByb3ZpZGVyO1xuICB9IGVsc2UgaWYgKGRhdGEucHJvdmlkZXIgIT09IHZvaWQgMCkge1xuICAgIGNvbnN0IHZhbHVlID0gZGF0YS5wcm92aWRlcjtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlICE9PSBcIlwiICYmICF2YWx1ZS5tYXRjaChtYXRjaE5hbWUpKSB7XG4gICAgICBpZiAoZml4KSB7XG4gICAgICAgIGRlbGV0ZSBkYXRhLnByb3ZpZGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcm92aWRlclwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgaWNvbnMgPSBkYXRhLmljb25zO1xuICBPYmplY3Qua2V5cyhpY29ucykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGlmICghbmFtZS5tYXRjaChtYXRjaE5hbWUpKSB7XG4gICAgICBpZiAoZml4KSB7XG4gICAgICAgIGRlbGV0ZSBpY29uc1tuYW1lXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGljb24gbmFtZTogXCIke25hbWV9XCJgKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IGljb25zW25hbWVdO1xuICAgIGlmICh0eXBlb2YgaXRlbSAhPT0gXCJvYmplY3RcIiB8fCBpdGVtID09PSBudWxsIHx8IHR5cGVvZiBpdGVtLmJvZHkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmIChmaXgpIHtcbiAgICAgICAgZGVsZXRlIGljb25zW25hbWVdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgaWNvbjogXCIke25hbWV9XCJgKTtcbiAgICB9XG4gICAgY29uc3Qga2V5ID0gdHlwZW9mIGl0ZW0ucGFyZW50ID09PSBcInN0cmluZ1wiID8gXCJwYXJlbnRcIiA6IHZhbGlkYXRlSWNvblByb3BzKGl0ZW0sIGZpeCk7XG4gICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGZpeCkge1xuICAgICAgICBkZWxldGUgaWNvbnNbbmFtZV07XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGluIGljb24gXCIke25hbWV9XCJgKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoZGF0YS5ub3RfZm91bmQgIT09IHZvaWQgMCAmJiAhKGRhdGEubm90X2ZvdW5kIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgaWYgKGZpeCkge1xuICAgICAgZGVsZXRlIGRhdGEubm90X2ZvdW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5vdF9mb3VuZCBsaXN0XCIpO1xuICAgIH1cbiAgfVxuICBpZiAoIU9iamVjdC5rZXlzKGRhdGEuaWNvbnMpLmxlbmd0aCAmJiAhKChfYSA9IGRhdGEubm90X2ZvdW5kKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkljb24gc2V0IGlzIGVtcHR5XCIpO1xuICB9XG4gIGlmIChkYXRhLmFsaWFzZXMgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgZGF0YS5hbGlhc2VzICE9PSBcIm9iamVjdFwiIHx8IGRhdGEuYWxpYXNlcyA9PT0gbnVsbCkge1xuICAgICAgaWYgKGZpeCkge1xuICAgICAgICBkZWxldGUgZGF0YS5hbGlhc2VzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhbGlhc2VzIGxpc3RcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2YgZGF0YS5hbGlhc2VzID09PSBcIm9iamVjdFwiKSB7XG4gICAgbGV0IHZhbGlkYXRlQWxpYXMgPSBmdW5jdGlvbihuYW1lLCBpdGVyYXRpb24pIHtcbiAgICAgIGlmICh2YWxpZGF0ZWRBbGlhc2VzLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gIWZhaWxlZEFsaWFzZXMuaGFzKG5hbWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgaXRlbSA9IGFsaWFzZXNbbmFtZV07XG4gICAgICBpZiAoaXRlcmF0aW9uID4gNSB8fCB0eXBlb2YgaXRlbSAhPT0gXCJvYmplY3RcIiB8fCBpdGVtID09PSBudWxsIHx8IHR5cGVvZiBpdGVtLnBhcmVudCAhPT0gXCJzdHJpbmdcIiB8fCAhbmFtZS5tYXRjaChtYXRjaE5hbWUpKSB7XG4gICAgICAgIGlmIChmaXgpIHtcbiAgICAgICAgICBkZWxldGUgYWxpYXNlc1tuYW1lXTtcbiAgICAgICAgICBmYWlsZWRBbGlhc2VzLmFkZChuYW1lKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGljb24gYWxpYXM6IFwiJHtuYW1lfVwiYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwYXJlbnQgPSBpdGVtLnBhcmVudDtcbiAgICAgIGlmIChkYXRhLmljb25zW3BhcmVudF0gPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoYWxpYXNlc1twYXJlbnRdID09PSB2b2lkIDAgfHwgIXZhbGlkYXRlQWxpYXMocGFyZW50LCBpdGVyYXRpb24gKyAxKSkge1xuICAgICAgICAgIGlmIChmaXgpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBhbGlhc2VzW25hbWVdO1xuICAgICAgICAgICAgZmFpbGVkQWxpYXNlcy5hZGQobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBwYXJlbnQgaWNvbiBmb3IgYWxpYXMgXCIke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaXggJiYgaXRlbS5ib2R5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgZGVsZXRlIGl0ZW0uYm9keTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IGl0ZW0uYm9keSAhPT0gdm9pZCAwID8gXCJib2R5XCIgOiB2YWxpZGF0ZUljb25Qcm9wcyhpdGVtLCBmaXgpO1xuICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoZml4KSB7XG4gICAgICAgICAgZGVsZXRlIGFsaWFzZXNbbmFtZV07XG4gICAgICAgICAgZmFpbGVkQWxpYXNlcy5hZGQobmFtZSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcm9wZXJ0eSBcIiR7a2V5fVwiIGluIGFsaWFzIFwiJHtuYW1lfVwiYCk7XG4gICAgICB9XG4gICAgICB2YWxpZGF0ZWRBbGlhc2VzLmFkZChuYW1lKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgY29uc3QgYWxpYXNlcyA9IGRhdGEuYWxpYXNlcztcbiAgICBjb25zdCB2YWxpZGF0ZWRBbGlhc2VzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGZhaWxlZEFsaWFzZXMgPSBuZXcgU2V0KCk7XG4gICAgT2JqZWN0LmtleXMoYWxpYXNlcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgdmFsaWRhdGVBbGlhcyhuYW1lLCAwKTtcbiAgICB9KTtcbiAgICBpZiAoZml4ICYmICFPYmplY3Qua2V5cyhkYXRhLmFsaWFzZXMpLmxlbmd0aCkge1xuICAgICAgZGVsZXRlIGRhdGEuYWxpYXNlcztcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmtleXMoaWNvbkRlZmF1bHRzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgY29uc3QgZXhwZWN0ZWRUeXBlID0gdHlwZW9mIGljb25EZWZhdWx0c1twcm9wXTtcbiAgICBjb25zdCBhY3R1YWxUeXBlID0gdHlwZW9mIGRhdGFbcHJvcF07XG4gICAgaWYgKGFjdHVhbFR5cGUgIT09IFwidW5kZWZpbmVkXCIgJiYgYWN0dWFsVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgdHlwZSBmb3IgXCIke3Byb3B9XCJgKTtcbiAgICB9XG4gIH0pO1xuICBpZiAoZGF0YS5jaGFycyAhPT0gdm9pZCAwKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhLmNoYXJzICE9PSBcIm9iamVjdFwiIHx8IGRhdGEuY2hhcnMgPT09IG51bGwpIHtcbiAgICAgIGlmIChmaXgpIHtcbiAgICAgICAgZGVsZXRlIGRhdGEuY2hhcnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNoYXJhY3RlcnMgbWFwXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIGRhdGEuY2hhcnMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBjaGFycyA9IGRhdGEuY2hhcnM7XG4gICAgT2JqZWN0LmtleXMoY2hhcnMpLmZvckVhY2goKGNoYXIpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICBpZiAoIWNoYXIubWF0Y2gobWF0Y2hDaGFyKSB8fCB0eXBlb2YgY2hhcnNbY2hhcl0gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGZpeCkge1xuICAgICAgICAgIGRlbGV0ZSBjaGFyc1tjaGFyXTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNoYXJhY3RlciBcIiR7Y2hhcn1cImApO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0ID0gY2hhcnNbY2hhcl07XG4gICAgICBpZiAoZGF0YS5pY29uc1t0YXJnZXRdID09PSB2b2lkIDAgJiYgKChfYTIgPSBkYXRhLmFsaWFzZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYTJbdGFyZ2V0XSkgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoZml4KSB7XG4gICAgICAgICAgZGVsZXRlIGNoYXJzW2NoYXJdO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENoYXJhY3RlciBcIiR7Y2hhcn1cIiBwb2ludHMgdG8gbWlzc2luZyBpY29uIFwiJHt0YXJnZXR9XCJgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZml4ICYmICFPYmplY3Qua2V5cyhkYXRhLmNoYXJzKS5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSBkYXRhLmNoYXJzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gc3JjL2ljb24tc2V0L3BhcnNlLnRzXG5mdW5jdGlvbiBpc1ZhcmlhdGlvbihpdGVtKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIGljb25EZWZhdWx0cykge1xuICAgIGlmIChpdGVtW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlSWNvblNldChkYXRhLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgbmFtZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBkYXRhLmljb25zICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIG5hbWVzO1xuICB9XG4gIGNvbnN0IHZhbGlkYXRlID0gb3B0aW9ucy52YWxpZGF0ZTtcbiAgaWYgKHZhbGlkYXRlICE9PSBmYWxzZSkge1xuICAgIHRyeSB7XG4gICAgICB2YWxpZGF0ZUljb25TZXQoZGF0YSwgdHlwZW9mIHZhbGlkYXRlID09PSBcIm9iamVjdFwiID8gdmFsaWRhdGUgOiB7IGZpeDogdHJ1ZSB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBuYW1lcztcbiAgICB9XG4gIH1cbiAgaWYgKGRhdGEubm90X2ZvdW5kIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBkYXRhLm5vdF9mb3VuZC5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBjYWxsYmFjayhuYW1lLCBudWxsKTtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgaWNvbnMgPSBkYXRhLmljb25zO1xuICBPYmplY3Qua2V5cyhpY29ucykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGNvbnN0IGljb25EYXRhID0gZ2V0SWNvbkRhdGEkMShkYXRhLCBuYW1lLCB0cnVlKTtcbiAgICBpZiAoaWNvbkRhdGEpIHtcbiAgICAgIGNhbGxiYWNrKG5hbWUsIGljb25EYXRhKTtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgcGFyc2VBbGlhc2VzID0gb3B0aW9ucy5hbGlhc2VzIHx8IFwiYWxsXCI7XG4gIGlmIChwYXJzZUFsaWFzZXMgIT09IFwibm9uZVwiICYmIHR5cGVvZiBkYXRhLmFsaWFzZXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBhbGlhc2VzID0gZGF0YS5hbGlhc2VzO1xuICAgIE9iamVjdC5rZXlzKGFsaWFzZXMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgIGlmIChwYXJzZUFsaWFzZXMgPT09IFwidmFyaWF0aW9uc1wiICYmIGlzVmFyaWF0aW9uKGFsaWFzZXNbbmFtZV0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGljb25EYXRhID0gZ2V0SWNvbkRhdGEkMShkYXRhLCBuYW1lLCB0cnVlKTtcbiAgICAgIGlmIChpY29uRGF0YSkge1xuICAgICAgICBjYWxsYmFjayhuYW1lLCBpY29uRGF0YSk7XG4gICAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5hbWVzO1xufVxuXG4vLyBzcmMvc3RvcmFnZS9zdG9yYWdlLnRzXG52YXIgc3RvcmFnZVZlcnNpb24gPSAxO1xudmFyIHN0b3JhZ2UkMSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG50cnkge1xuICBjb25zdCB3ID0gd2luZG93IHx8IHNlbGY7XG4gIGlmICgodyA9PSBudWxsID8gdm9pZCAwIDogdy5faWNvbmlmeVN0b3JhZ2UudmVyc2lvbikgPT09IHN0b3JhZ2VWZXJzaW9uKSB7XG4gICAgc3RvcmFnZSQxID0gdy5faWNvbmlmeVN0b3JhZ2Uuc3RvcmFnZTtcbiAgfVxufSBjYXRjaCAoZXJyKSB7XG59XG5mdW5jdGlvbiBzaGFyZVN0b3JhZ2UoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdyA9IHdpbmRvdyB8fCBzZWxmO1xuICAgIGlmICh3ICYmICF3Ll9pY29uaWZ5U3RvcmFnZSkge1xuICAgICAgdy5faWNvbmlmeVN0b3JhZ2UgPSB7XG4gICAgICAgIHZlcnNpb246IHN0b3JhZ2VWZXJzaW9uLFxuICAgICAgICBzdG9yYWdlOiBzdG9yYWdlJDFcbiAgICAgIH07XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxufVxuZnVuY3Rpb24gbmV3U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSB7XG4gIHJldHVybiB7XG4gICAgcHJvdmlkZXIsXG4gICAgcHJlZml4LFxuICAgIGljb25zOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIG1pc3Npbmc6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCkge1xuICBpZiAoc3RvcmFnZSQxW3Byb3ZpZGVyXSA9PT0gdm9pZCAwKSB7XG4gICAgc3RvcmFnZSQxW3Byb3ZpZGVyXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgY29uc3QgcHJvdmlkZXJTdG9yYWdlID0gc3RvcmFnZSQxW3Byb3ZpZGVyXTtcbiAgaWYgKHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdID09PSB2b2lkIDApIHtcbiAgICBwcm92aWRlclN0b3JhZ2VbcHJlZml4XSA9IG5ld1N0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCk7XG4gIH1cbiAgcmV0dXJuIHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdO1xufVxuZnVuY3Rpb24gYWRkSWNvblNldChzdG9yYWdlMiwgZGF0YSkge1xuICBjb25zdCB0ID0gRGF0ZS5ub3coKTtcbiAgcmV0dXJuIHBhcnNlSWNvblNldChkYXRhLCAobmFtZSwgaWNvbikgPT4ge1xuICAgIGlmIChpY29uKSB7XG4gICAgICBzdG9yYWdlMi5pY29uc1tuYW1lXSA9IGljb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JhZ2UyLm1pc3NpbmdbbmFtZV0gPSB0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRJY29uVG9TdG9yYWdlKHN0b3JhZ2UyLCBuYW1lLCBpY29uKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBpY29uLmJvZHkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN0b3JhZ2UyLmljb25zW25hbWVdID0gT2JqZWN0LmZyZWV6ZShmdWxsSWNvbihpY29uKSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldEljb25Gcm9tU3RvcmFnZShzdG9yYWdlMiwgbmFtZSkge1xuICBjb25zdCB2YWx1ZSA9IHN0b3JhZ2UyLmljb25zW25hbWVdO1xuICByZXR1cm4gdmFsdWUgPT09IHZvaWQgMCA/IG51bGwgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGxpc3RJY29ucyhwcm92aWRlciwgcHJlZml4KSB7XG4gIGxldCBhbGxJY29ucyA9IFtdO1xuICBsZXQgcHJvdmlkZXJzO1xuICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgcHJvdmlkZXJzID0gW3Byb3ZpZGVyXTtcbiAgfSBlbHNlIHtcbiAgICBwcm92aWRlcnMgPSBPYmplY3Qua2V5cyhzdG9yYWdlJDEpO1xuICB9XG4gIHByb3ZpZGVycy5mb3JFYWNoKChwcm92aWRlcjIpID0+IHtcbiAgICBsZXQgcHJlZml4ZXM7XG4gICAgaWYgKHR5cGVvZiBwcm92aWRlcjIgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHByZWZpeCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcHJlZml4ZXMgPSBbcHJlZml4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJlZml4ZXMgPSBzdG9yYWdlJDFbcHJvdmlkZXIyXSA9PT0gdm9pZCAwID8gW10gOiBPYmplY3Qua2V5cyhzdG9yYWdlJDFbcHJvdmlkZXIyXSk7XG4gICAgfVxuICAgIHByZWZpeGVzLmZvckVhY2goKHByZWZpeDIpID0+IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2UyID0gZ2V0U3RvcmFnZShwcm92aWRlcjIsIHByZWZpeDIpO1xuICAgICAgY29uc3QgaWNvbnMgPSBPYmplY3Qua2V5cyhzdG9yYWdlMi5pY29ucykubWFwKChuYW1lKSA9PiAocHJvdmlkZXIyICE9PSBcIlwiID8gXCJAXCIgKyBwcm92aWRlcjIgKyBcIjpcIiA6IFwiXCIpICsgcHJlZml4MiArIFwiOlwiICsgbmFtZSk7XG4gICAgICBhbGxJY29ucyA9IGFsbEljb25zLmNvbmNhdChpY29ucyk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gYWxsSWNvbnM7XG59XG5cbi8vIHNyYy9zdG9yYWdlL2Z1bmN0aW9ucy50c1xudmFyIHNpbXBsZU5hbWVzID0gZmFsc2U7XG5mdW5jdGlvbiBhbGxvd1NpbXBsZU5hbWVzKGFsbG93KSB7XG4gIGlmICh0eXBlb2YgYWxsb3cgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgc2ltcGxlTmFtZXMgPSBhbGxvdztcbiAgfVxuICByZXR1cm4gc2ltcGxlTmFtZXM7XG59XG5mdW5jdGlvbiBnZXRJY29uRGF0YShuYW1lKSB7XG4gIGNvbnN0IGljb24gPSB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIiA/IHN0cmluZ1RvSWNvbihuYW1lLCB0cnVlLCBzaW1wbGVOYW1lcykgOiBuYW1lO1xuICByZXR1cm4gaWNvbiA/IGdldEljb25Gcm9tU3RvcmFnZShnZXRTdG9yYWdlKGljb24ucHJvdmlkZXIsIGljb24ucHJlZml4KSwgaWNvbi5uYW1lKSA6IG51bGw7XG59XG5mdW5jdGlvbiBhZGRJY29uKG5hbWUsIGRhdGEpIHtcbiAgY29uc3QgaWNvbiA9IHN0cmluZ1RvSWNvbihuYW1lLCB0cnVlLCBzaW1wbGVOYW1lcyk7XG4gIGlmICghaWNvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShpY29uLnByb3ZpZGVyLCBpY29uLnByZWZpeCk7XG4gIHJldHVybiBhZGRJY29uVG9TdG9yYWdlKHN0b3JhZ2UsIGljb24ubmFtZSwgZGF0YSk7XG59XG5mdW5jdGlvbiBhZGRDb2xsZWN0aW9uKGRhdGEsIHByb3ZpZGVyKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIHByb3ZpZGVyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcHJvdmlkZXIgPSB0eXBlb2YgZGF0YS5wcm92aWRlciA9PT0gXCJzdHJpbmdcIiA/IGRhdGEucHJvdmlkZXIgOiBcIlwiO1xuICB9XG4gIGlmIChzaW1wbGVOYW1lcyAmJiBwcm92aWRlciA9PT0gXCJcIiAmJiAodHlwZW9mIGRhdGEucHJlZml4ICE9PSBcInN0cmluZ1wiIHx8IGRhdGEucHJlZml4ID09PSBcIlwiKSkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIHBhcnNlSWNvblNldChkYXRhLCAobmFtZSwgaWNvbikgPT4ge1xuICAgICAgaWYgKGljb24gJiYgYWRkSWNvbihuYW1lLCBpY29uKSkge1xuICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgZml4OiB0cnVlLFxuICAgICAgICBwcmVmaXg6IFwiXCJcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWRkZWQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBkYXRhLnByZWZpeCAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsaWRhdGVJY29uKHtcbiAgICBwcm92aWRlcixcbiAgICBwcmVmaXg6IGRhdGEucHJlZml4LFxuICAgIG5hbWU6IFwiYVwiXG4gIH0pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyLCBkYXRhLnByZWZpeCk7XG4gIHJldHVybiAhIWFkZEljb25TZXQoc3RvcmFnZSwgZGF0YSk7XG59XG5mdW5jdGlvbiBpY29uRXhpc3RzKG5hbWUpIHtcbiAgcmV0dXJuIGdldEljb25EYXRhKG5hbWUpICE9PSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0SWNvbihuYW1lKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGdldEljb25EYXRhKG5hbWUpO1xuICByZXR1cm4gcmVzdWx0ID8geyAuLi5yZXN1bHQgfSA6IG51bGw7XG59XG5cbi8vIHNyYy9jdXN0b21pc2F0aW9ucy9pbmRleC50c1xudmFyIGRlZmF1bHRzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGlubGluZTogZmFsc2UsXG4gIHdpZHRoOiBudWxsLFxuICBoZWlnaHQ6IG51bGwsXG4gIGhBbGlnbjogXCJjZW50ZXJcIixcbiAgdkFsaWduOiBcIm1pZGRsZVwiLFxuICBzbGljZTogZmFsc2UsXG4gIGhGbGlwOiBmYWxzZSxcbiAgdkZsaXA6IGZhbHNlLFxuICByb3RhdGU6IDBcbn0pO1xuZnVuY3Rpb24gbWVyZ2VDdXN0b21pc2F0aW9ucyhkZWZhdWx0czIsIGl0ZW0pIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzMikge1xuICAgIGNvbnN0IGF0dHIgPSBrZXk7XG4gICAgcmVzdWx0W2F0dHJdID0gZGVmYXVsdHMyW2F0dHJdO1xuICAgIGlmIChpdGVtW2F0dHJdID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IGl0ZW1bYXR0cl07XG4gICAgc3dpdGNoIChhdHRyKSB7XG4gICAgICBjYXNlIFwiaW5saW5lXCI6XG4gICAgICBjYXNlIFwic2xpY2VcIjpcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICByZXN1bHRbYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJoRmxpcFwiOlxuICAgICAgY2FzZSBcInZGbGlwXCI6XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJlc3VsdFthdHRyXSA9ICFyZXN1bHRbYXR0cl07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaEFsaWduXCI6XG4gICAgICBjYXNlIFwidkFsaWduXCI6XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgIT09IFwiXCIpIHtcbiAgICAgICAgICByZXN1bHRbYXR0cl0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ3aWR0aFwiOlxuICAgICAgY2FzZSBcImhlaWdodFwiOlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmIHZhbHVlICE9PSBcIlwiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiAmJiB2YWx1ZSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdFthdHRyXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInJvdGF0ZVwiOlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgcmVzdWx0W2F0dHJdICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvc3ZnL3NpemUudHNcbnZhciB1bml0c1NwbGl0ID0gLygtP1swLTkuXSpbMC05XStbMC05Ll0qKS9nO1xudmFyIHVuaXRzVGVzdCA9IC9eLT9bMC05Ll0qWzAtOV0rWzAtOS5dKiQvZztcbmZ1bmN0aW9uIGNhbGN1bGF0ZVNpemUoc2l6ZSwgcmF0aW8sIHByZWNpc2lvbikge1xuICBpZiAocmF0aW8gPT09IDEpIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT09IHZvaWQgMCA/IDEwMCA6IHByZWNpc2lvbjtcbiAgaWYgKHR5cGVvZiBzaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChzaXplICogcmF0aW8gKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGNvbnN0IG9sZFBhcnRzID0gc2l6ZS5zcGxpdCh1bml0c1NwbGl0KTtcbiAgaWYgKG9sZFBhcnRzID09PSBudWxsIHx8ICFvbGRQYXJ0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBjb25zdCBuZXdQYXJ0cyA9IFtdO1xuICBsZXQgY29kZSA9IG9sZFBhcnRzLnNoaWZ0KCk7XG4gIGxldCBpc051bWJlciA9IHVuaXRzVGVzdC50ZXN0KGNvZGUpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChpc051bWJlcikge1xuICAgICAgY29uc3QgbnVtID0gcGFyc2VGbG9hdChjb2RlKTtcbiAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgIG5ld1BhcnRzLnB1c2goY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdQYXJ0cy5wdXNoKE1hdGguY2VpbChudW0gKiByYXRpbyAqIHByZWNpc2lvbikgLyBwcmVjaXNpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQYXJ0cy5wdXNoKGNvZGUpO1xuICAgIH1cbiAgICBjb2RlID0gb2xkUGFydHMuc2hpZnQoKTtcbiAgICBpZiAoY29kZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbmV3UGFydHMuam9pbihcIlwiKTtcbiAgICB9XG4gICAgaXNOdW1iZXIgPSAhaXNOdW1iZXI7XG4gIH1cbn1cblxuLy8gc3JjL3N2Zy9idWlsZC50c1xuZnVuY3Rpb24gcHJlc2VydmVBc3BlY3RSYXRpbyhwcm9wcykge1xuICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgc3dpdGNoIChwcm9wcy5oQWxpZ24pIHtcbiAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgcmVzdWx0ICs9IFwieE1pblwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICByZXN1bHQgKz0gXCJ4TWF4XCI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVzdWx0ICs9IFwieE1pZFwiO1xuICB9XG4gIHN3aXRjaCAocHJvcHMudkFsaWduKSB7XG4gICAgY2FzZSBcInRvcFwiOlxuICAgICAgcmVzdWx0ICs9IFwiWU1pblwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgcmVzdWx0ICs9IFwiWU1heFwiO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJlc3VsdCArPSBcIllNaWRcIjtcbiAgfVxuICByZXN1bHQgKz0gcHJvcHMuc2xpY2UgPyBcIiBzbGljZVwiIDogXCIgbWVldFwiO1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaWNvblRvU1ZHKGljb24sIGN1c3RvbWlzYXRpb25zKSB7XG4gIGNvbnN0IGJveCA9IHtcbiAgICBsZWZ0OiBpY29uLmxlZnQsXG4gICAgdG9wOiBpY29uLnRvcCxcbiAgICB3aWR0aDogaWNvbi53aWR0aCxcbiAgICBoZWlnaHQ6IGljb24uaGVpZ2h0XG4gIH07XG4gIGxldCBib2R5ID0gaWNvbi5ib2R5O1xuICBbaWNvbiwgY3VzdG9taXNhdGlvbnNdLmZvckVhY2goKHByb3BzKSA9PiB7XG4gICAgY29uc3QgdHJhbnNmb3JtYXRpb25zID0gW107XG4gICAgY29uc3QgaEZsaXAgPSBwcm9wcy5oRmxpcDtcbiAgICBjb25zdCB2RmxpcCA9IHByb3BzLnZGbGlwO1xuICAgIGxldCByb3RhdGlvbiA9IHByb3BzLnJvdGF0ZTtcbiAgICBpZiAoaEZsaXApIHtcbiAgICAgIGlmICh2RmxpcCkge1xuICAgICAgICByb3RhdGlvbiArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnB1c2goXCJ0cmFuc2xhdGUoXCIgKyAoYm94LndpZHRoICsgYm94LmxlZnQpICsgXCIgXCIgKyAoMCAtIGJveC50b3ApICsgXCIpXCIpO1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChcInNjYWxlKC0xIDEpXCIpO1xuICAgICAgICBib3gudG9wID0gYm94LmxlZnQgPSAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodkZsaXApIHtcbiAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKFwidHJhbnNsYXRlKFwiICsgKDAgLSBib3gubGVmdCkgKyBcIiBcIiArIChib3guaGVpZ2h0ICsgYm94LnRvcCkgKyBcIilcIik7XG4gICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChcInNjYWxlKDEgLTEpXCIpO1xuICAgICAgYm94LnRvcCA9IGJveC5sZWZ0ID0gMDtcbiAgICB9XG4gICAgbGV0IHRlbXBWYWx1ZTtcbiAgICBpZiAocm90YXRpb24gPCAwKSB7XG4gICAgICByb3RhdGlvbiAtPSBNYXRoLmZsb29yKHJvdGF0aW9uIC8gNCkgKiA0O1xuICAgIH1cbiAgICByb3RhdGlvbiA9IHJvdGF0aW9uICUgNDtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHRlbXBWYWx1ZSA9IGJveC5oZWlnaHQgLyAyICsgYm94LnRvcDtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnVuc2hpZnQoXCJyb3RhdGUoOTAgXCIgKyB0ZW1wVmFsdWUgKyBcIiBcIiArIHRlbXBWYWx1ZSArIFwiKVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRyYW5zZm9ybWF0aW9ucy51bnNoaWZ0KFwicm90YXRlKDE4MCBcIiArIChib3gud2lkdGggLyAyICsgYm94LmxlZnQpICsgXCIgXCIgKyAoYm94LmhlaWdodCAvIDIgKyBib3gudG9wKSArIFwiKVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRlbXBWYWx1ZSA9IGJveC53aWR0aCAvIDIgKyBib3gubGVmdDtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnVuc2hpZnQoXCJyb3RhdGUoLTkwIFwiICsgdGVtcFZhbHVlICsgXCIgXCIgKyB0ZW1wVmFsdWUgKyBcIilcIik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAocm90YXRpb24gJSAyID09PSAxKSB7XG4gICAgICBpZiAoYm94LmxlZnQgIT09IDAgfHwgYm94LnRvcCAhPT0gMCkge1xuICAgICAgICB0ZW1wVmFsdWUgPSBib3gubGVmdDtcbiAgICAgICAgYm94LmxlZnQgPSBib3gudG9wO1xuICAgICAgICBib3gudG9wID0gdGVtcFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGJveC53aWR0aCAhPT0gYm94LmhlaWdodCkge1xuICAgICAgICB0ZW1wVmFsdWUgPSBib3gud2lkdGg7XG4gICAgICAgIGJveC53aWR0aCA9IGJveC5oZWlnaHQ7XG4gICAgICAgIGJveC5oZWlnaHQgPSB0ZW1wVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBib2R5ID0gJzxnIHRyYW5zZm9ybT1cIicgKyB0cmFuc2Zvcm1hdGlvbnMuam9pbihcIiBcIikgKyAnXCI+JyArIGJvZHkgKyBcIjwvZz5cIjtcbiAgICB9XG4gIH0pO1xuICBsZXQgd2lkdGgsIGhlaWdodDtcbiAgaWYgKGN1c3RvbWlzYXRpb25zLndpZHRoID09PSBudWxsICYmIGN1c3RvbWlzYXRpb25zLmhlaWdodCA9PT0gbnVsbCkge1xuICAgIGhlaWdodCA9IFwiMWVtXCI7XG4gICAgd2lkdGggPSBjYWxjdWxhdGVTaXplKGhlaWdodCwgYm94LndpZHRoIC8gYm94LmhlaWdodCk7XG4gIH0gZWxzZSBpZiAoY3VzdG9taXNhdGlvbnMud2lkdGggIT09IG51bGwgJiYgY3VzdG9taXNhdGlvbnMuaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgd2lkdGggPSBjdXN0b21pc2F0aW9ucy53aWR0aDtcbiAgICBoZWlnaHQgPSBjdXN0b21pc2F0aW9ucy5oZWlnaHQ7XG4gIH0gZWxzZSBpZiAoY3VzdG9taXNhdGlvbnMuaGVpZ2h0ICE9PSBudWxsKSB7XG4gICAgaGVpZ2h0ID0gY3VzdG9taXNhdGlvbnMuaGVpZ2h0O1xuICAgIHdpZHRoID0gY2FsY3VsYXRlU2l6ZShoZWlnaHQsIGJveC53aWR0aCAvIGJveC5oZWlnaHQpO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gY3VzdG9taXNhdGlvbnMud2lkdGg7XG4gICAgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZSh3aWR0aCwgYm94LmhlaWdodCAvIGJveC53aWR0aCk7XG4gIH1cbiAgaWYgKHdpZHRoID09PSBcImF1dG9cIikge1xuICAgIHdpZHRoID0gYm94LndpZHRoO1xuICB9XG4gIGlmIChoZWlnaHQgPT09IFwiYXV0b1wiKSB7XG4gICAgaGVpZ2h0ID0gYm94LmhlaWdodDtcbiAgfVxuICB3aWR0aCA9IHR5cGVvZiB3aWR0aCA9PT0gXCJzdHJpbmdcIiA/IHdpZHRoIDogd2lkdGggKyBcIlwiO1xuICBoZWlnaHQgPSB0eXBlb2YgaGVpZ2h0ID09PSBcInN0cmluZ1wiID8gaGVpZ2h0IDogaGVpZ2h0ICsgXCJcIjtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogcHJlc2VydmVBc3BlY3RSYXRpbyhjdXN0b21pc2F0aW9ucyksXG4gICAgICB2aWV3Qm94OiBib3gubGVmdCArIFwiIFwiICsgYm94LnRvcCArIFwiIFwiICsgYm94LndpZHRoICsgXCIgXCIgKyBib3guaGVpZ2h0XG4gICAgfSxcbiAgICBib2R5XG4gIH07XG4gIGlmIChjdXN0b21pc2F0aW9ucy5pbmxpbmUpIHtcbiAgICByZXN1bHQuaW5saW5lID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvYnVpbGRlci9mdW5jdGlvbnMudHNcbmZ1bmN0aW9uIGJ1aWxkSWNvbihpY29uLCBjdXN0b21pc2F0aW9ucykge1xuICByZXR1cm4gaWNvblRvU1ZHKGZ1bGxJY29uKGljb24pLCBjdXN0b21pc2F0aW9ucyA/IG1lcmdlQ3VzdG9taXNhdGlvbnMoZGVmYXVsdHMsIGN1c3RvbWlzYXRpb25zKSA6IGRlZmF1bHRzKTtcbn1cblxuLy8gc3JjL3N2Zy9pZC50c1xudmFyIHJlZ2V4ID0gL1xcc2lkPVwiKFxcUyspXCIvZztcbnZhciByYW5kb21QcmVmaXggPSBcIkljb25pZnlJZFwiICsgRGF0ZS5ub3coKS50b1N0cmluZygxNikgKyAoTWF0aC5yYW5kb20oKSAqIDE2Nzc3MjE2IHwgMCkudG9TdHJpbmcoMTYpO1xudmFyIGNvdW50ZXIgPSAwO1xuZnVuY3Rpb24gcmVwbGFjZUlEcyhib2R5LCBwcmVmaXggPSByYW5kb21QcmVmaXgpIHtcbiAgY29uc3QgaWRzID0gW107XG4gIGxldCBtYXRjaDtcbiAgd2hpbGUgKG1hdGNoID0gcmVnZXguZXhlYyhib2R5KSkge1xuICAgIGlkcy5wdXNoKG1hdGNoWzFdKTtcbiAgfVxuICBpZiAoIWlkcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gYm9keTtcbiAgfVxuICBpZHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICBjb25zdCBuZXdJRCA9IHR5cGVvZiBwcmVmaXggPT09IFwiZnVuY3Rpb25cIiA/IHByZWZpeChpZCkgOiBwcmVmaXggKyBjb3VudGVyKys7XG4gICAgY29uc3QgZXNjYXBlZElEID0gaWQucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xuICAgIGJvZHkgPSBib2R5LnJlcGxhY2UobmV3IFJlZ0V4cCgnKFsjO1wiXSkoJyArIGVzY2FwZWRJRCArICcpKFtcIildfFxcXFwuW2Etel0pJywgXCJnXCIpLCBcIiQxXCIgKyBuZXdJRCArIFwiJDNcIik7XG4gIH0pO1xuICByZXR1cm4gYm9keTtcbn1cblxuLy8gc3JjL2FwaS9tb2R1bGVzLnRzXG52YXIgc3RvcmFnZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBzZXRBUElNb2R1bGUocHJvdmlkZXIsIGl0ZW0pIHtcbiAgc3RvcmFnZVtwcm92aWRlcl0gPSBpdGVtO1xufVxuZnVuY3Rpb24gZ2V0QVBJTW9kdWxlKHByb3ZpZGVyKSB7XG4gIHJldHVybiBzdG9yYWdlW3Byb3ZpZGVyXSB8fCBzdG9yYWdlW1wiXCJdO1xufVxuXG4vLyBzcmMvYXBpL2NvbmZpZy50c1xuZnVuY3Rpb24gY3JlYXRlQVBJQ29uZmlnKHNvdXJjZSkge1xuICBsZXQgcmVzb3VyY2VzO1xuICBpZiAodHlwZW9mIHNvdXJjZS5yZXNvdXJjZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXNvdXJjZXMgPSBbc291cmNlLnJlc291cmNlc107XG4gIH0gZWxzZSB7XG4gICAgcmVzb3VyY2VzID0gc291cmNlLnJlc291cmNlcztcbiAgICBpZiAoIShyZXNvdXJjZXMgaW5zdGFuY2VvZiBBcnJheSkgfHwgIXJlc291cmNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgcmVzb3VyY2VzLFxuICAgIHBhdGg6IHNvdXJjZS5wYXRoID09PSB2b2lkIDAgPyBcIi9cIiA6IHNvdXJjZS5wYXRoLFxuICAgIG1heFVSTDogc291cmNlLm1heFVSTCA/IHNvdXJjZS5tYXhVUkwgOiA1MDAsXG4gICAgcm90YXRlOiBzb3VyY2Uucm90YXRlID8gc291cmNlLnJvdGF0ZSA6IDc1MCxcbiAgICB0aW1lb3V0OiBzb3VyY2UudGltZW91dCA/IHNvdXJjZS50aW1lb3V0IDogNWUzLFxuICAgIHJhbmRvbTogc291cmNlLnJhbmRvbSA9PT0gdHJ1ZSxcbiAgICBpbmRleDogc291cmNlLmluZGV4ID8gc291cmNlLmluZGV4IDogMCxcbiAgICBkYXRhQWZ0ZXJUaW1lb3V0OiBzb3VyY2UuZGF0YUFmdGVyVGltZW91dCAhPT0gZmFsc2VcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbnZhciBjb25maWdTdG9yYWdlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBmYWxsQmFja0FQSVNvdXJjZXMgPSBbXG4gIFwiaHR0cHM6Ly9hcGkuc2ltcGxlc3ZnLmNvbVwiLFxuICBcImh0dHBzOi8vYXBpLnVuaXN2Zy5jb21cIlxuXTtcbnZhciBmYWxsQmFja0FQSSA9IFtdO1xud2hpbGUgKGZhbGxCYWNrQVBJU291cmNlcy5sZW5ndGggPiAwKSB7XG4gIGlmIChmYWxsQmFja0FQSVNvdXJjZXMubGVuZ3RoID09PSAxKSB7XG4gICAgZmFsbEJhY2tBUEkucHVzaChmYWxsQmFja0FQSVNvdXJjZXMuc2hpZnQoKSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgIGZhbGxCYWNrQVBJLnB1c2goZmFsbEJhY2tBUElTb3VyY2VzLnNoaWZ0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmYWxsQmFja0FQSS5wdXNoKGZhbGxCYWNrQVBJU291cmNlcy5wb3AoKSk7XG4gICAgfVxuICB9XG59XG5jb25maWdTdG9yYWdlW1wiXCJdID0gY3JlYXRlQVBJQ29uZmlnKHtcbiAgcmVzb3VyY2VzOiBbXCJodHRwczovL2FwaS5pY29uaWZ5LmRlc2lnblwiXS5jb25jYXQoZmFsbEJhY2tBUEkpXG59KTtcbmZ1bmN0aW9uIGFkZEFQSVByb3ZpZGVyKHByb3ZpZGVyLCBjdXN0b21Db25maWcpIHtcbiAgY29uc3QgY29uZmlnID0gY3JlYXRlQVBJQ29uZmlnKGN1c3RvbUNvbmZpZyk7XG4gIGlmIChjb25maWcgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uZmlnU3RvcmFnZVtwcm92aWRlcl0gPSBjb25maWc7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKSB7XG4gIHJldHVybiBjb25maWdTdG9yYWdlW3Byb3ZpZGVyXTtcbn1cbmZ1bmN0aW9uIGxpc3RBUElQcm92aWRlcnMoKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhjb25maWdTdG9yYWdlKTtcbn1cblxuLy8gc3JjL2FwaS9wYXJhbXMudHNcbnZhciBtZXJnZVBhcmFtcyA9IChiYXNlLCBwYXJhbXMpID0+IHtcbiAgbGV0IHJlc3VsdCA9IGJhc2UsIGhhc1BhcmFtcyA9IHJlc3VsdC5pbmRleE9mKFwiP1wiKSAhPT0gLTE7XG4gIGZ1bmN0aW9uIHBhcmFtVG9TdHJpbmcodmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgcmV0dXJuIHZhbHVlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFyYW1ldGVyXCIpO1xuICAgIH1cbiAgfVxuICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGxldCB2YWx1ZTtcbiAgICB0cnkge1xuICAgICAgdmFsdWUgPSBwYXJhbVRvU3RyaW5nKHBhcmFtc1trZXldKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzdWx0ICs9IChoYXNQYXJhbXMgPyBcIiZcIiA6IFwiP1wiKSArIGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyB2YWx1ZTtcbiAgICBoYXNQYXJhbXMgPSB0cnVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIHNyYy9hcGkvbW9kdWxlcy9mZXRjaC50c1xudmFyIG1heExlbmd0aENhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBwYXRoQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xudmFyIGRldGVjdEZldGNoID0gKCkgPT4ge1xuICBsZXQgY2FsbGJhY2s7XG4gIHRyeSB7XG4gICAgY2FsbGJhY2sgPSBmZXRjaDtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbnZhciBmZXRjaE1vZHVsZSA9IGRldGVjdEZldGNoKCk7XG5mdW5jdGlvbiBzZXRGZXRjaChmZXRjaDIpIHtcbiAgZmV0Y2hNb2R1bGUgPSBmZXRjaDI7XG59XG5mdW5jdGlvbiBnZXRGZXRjaCgpIHtcbiAgcmV0dXJuIGZldGNoTW9kdWxlO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTWF4TGVuZ3RoKHByb3ZpZGVyLCBwcmVmaXgpIHtcbiAgY29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcbiAgaWYgKCFjb25maWcpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgcmVzdWx0O1xuICBpZiAoIWNvbmZpZy5tYXhVUkwpIHtcbiAgICByZXN1bHQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxldCBtYXhIb3N0TGVuZ3RoID0gMDtcbiAgICBjb25maWcucmVzb3VyY2VzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IGhvc3QgPSBpdGVtO1xuICAgICAgbWF4SG9zdExlbmd0aCA9IE1hdGgubWF4KG1heEhvc3RMZW5ndGgsIGhvc3QubGVuZ3RoKTtcbiAgICB9KTtcbiAgICBjb25zdCB1cmwgPSBtZXJnZVBhcmFtcyhwcmVmaXggKyBcIi5qc29uXCIsIHtcbiAgICAgIGljb25zOiBcIlwiXG4gICAgfSk7XG4gICAgcmVzdWx0ID0gY29uZmlnLm1heFVSTCAtIG1heEhvc3RMZW5ndGggLSBjb25maWcucGF0aC5sZW5ndGggLSB1cmwubGVuZ3RoO1xuICB9XG4gIGNvbnN0IGNhY2hlS2V5ID0gcHJvdmlkZXIgKyBcIjpcIiArIHByZWZpeDtcbiAgcGF0aENhY2hlW3Byb3ZpZGVyXSA9IGNvbmZpZy5wYXRoO1xuICBtYXhMZW5ndGhDYWNoZVtjYWNoZUtleV0gPSByZXN1bHQ7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzaG91bGRBYm9ydChzdGF0dXMpIHtcbiAgcmV0dXJuIHN0YXR1cyA9PT0gNDA0O1xufVxudmFyIHByZXBhcmUgPSAocHJvdmlkZXIsIHByZWZpeCwgaWNvbnMpID0+IHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBsZXQgbWF4TGVuZ3RoID0gbWF4TGVuZ3RoQ2FjaGVbcHJlZml4XTtcbiAgaWYgKG1heExlbmd0aCA9PT0gdm9pZCAwKSB7XG4gICAgbWF4TGVuZ3RoID0gY2FsY3VsYXRlTWF4TGVuZ3RoKHByb3ZpZGVyLCBwcmVmaXgpO1xuICB9XG4gIGNvbnN0IHR5cGUgPSBcImljb25zXCI7XG4gIGxldCBpdGVtID0ge1xuICAgIHR5cGUsXG4gICAgcHJvdmlkZXIsXG4gICAgcHJlZml4LFxuICAgIGljb25zOiBbXVxuICB9O1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgaWNvbnMuZm9yRWFjaCgobmFtZSwgaW5kZXgpID0+IHtcbiAgICBsZW5ndGggKz0gbmFtZS5sZW5ndGggKyAxO1xuICAgIGlmIChsZW5ndGggPj0gbWF4TGVuZ3RoICYmIGluZGV4ID4gMCkge1xuICAgICAgcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgaWNvbnM6IFtdXG4gICAgICB9O1xuICAgICAgbGVuZ3RoID0gbmFtZS5sZW5ndGg7XG4gICAgfVxuICAgIGl0ZW0uaWNvbnMucHVzaChuYW1lKTtcbiAgfSk7XG4gIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuZnVuY3Rpb24gZ2V0UGF0aChwcm92aWRlcikge1xuICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKHBhdGhDYWNoZVtwcm92aWRlcl0gPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcbiAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBcIi9cIjtcbiAgICAgIH1cbiAgICAgIHBhdGhDYWNoZVtwcm92aWRlcl0gPSBjb25maWcucGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGhDYWNoZVtwcm92aWRlcl07XG4gIH1cbiAgcmV0dXJuIFwiL1wiO1xufVxudmFyIHNlbmQgPSAoaG9zdCwgcGFyYW1zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAoIWZldGNoTW9kdWxlKSB7XG4gICAgY2FsbGJhY2soXCJhYm9ydFwiLCA0MjQpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgcGF0aCA9IGdldFBhdGgocGFyYW1zLnByb3ZpZGVyKTtcbiAgc3dpdGNoIChwYXJhbXMudHlwZSkge1xuICAgIGNhc2UgXCJpY29uc1wiOiB7XG4gICAgICBjb25zdCBwcmVmaXggPSBwYXJhbXMucHJlZml4O1xuICAgICAgY29uc3QgaWNvbnMgPSBwYXJhbXMuaWNvbnM7XG4gICAgICBjb25zdCBpY29uc0xpc3QgPSBpY29ucy5qb2luKFwiLFwiKTtcbiAgICAgIHBhdGggKz0gbWVyZ2VQYXJhbXMocHJlZml4ICsgXCIuanNvblwiLCB7XG4gICAgICAgIGljb25zOiBpY29uc0xpc3RcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJjdXN0b21cIjoge1xuICAgICAgY29uc3QgdXJpID0gcGFyYW1zLnVyaTtcbiAgICAgIHBhdGggKz0gdXJpLnNsaWNlKDAsIDEpID09PSBcIi9cIiA/IHVyaS5zbGljZSgxKSA6IHVyaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgY2FsbGJhY2soXCJhYm9ydFwiLCA0MDApO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIGxldCBkZWZhdWx0RXJyb3IgPSA1MDM7XG4gIGZldGNoTW9kdWxlKGhvc3QgKyBwYXRoKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICBpZiAoc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhzaG91bGRBYm9ydChzdGF0dXMpID8gXCJhYm9ydFwiIDogXCJuZXh0XCIsIHN0YXR1cyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVmYXVsdEVycm9yID0gNTAxO1xuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0pLnRoZW4oKGRhdGEpID0+IHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNhbGxiYWNrKFwibmV4dFwiLCBkZWZhdWx0RXJyb3IpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY2FsbGJhY2soXCJzdWNjZXNzXCIsIGRhdGEpO1xuICAgIH0pO1xuICB9KS5jYXRjaCgoKSA9PiB7XG4gICAgY2FsbGJhY2soXCJuZXh0XCIsIGRlZmF1bHRFcnJvcik7XG4gIH0pO1xufTtcbnZhciBmZXRjaEFQSU1vZHVsZSA9IHtcbiAgcHJlcGFyZSxcbiAgc2VuZFxufTtcblxuLy8gc3JjL2ljb24vc29ydC50c1xuZnVuY3Rpb24gc29ydEljb25zKGljb25zKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBsb2FkZWQ6IFtdLFxuICAgIG1pc3Npbmc6IFtdLFxuICAgIHBlbmRpbmc6IFtdXG4gIH07XG4gIGNvbnN0IHN0b3JhZ2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpY29ucy5zb3J0KChhLCBiKSA9PiB7XG4gICAgaWYgKGEucHJvdmlkZXIgIT09IGIucHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiBhLnByb3ZpZGVyLmxvY2FsZUNvbXBhcmUoYi5wcm92aWRlcik7XG4gICAgfVxuICAgIGlmIChhLnByZWZpeCAhPT0gYi5wcmVmaXgpIHtcbiAgICAgIHJldHVybiBhLnByZWZpeC5sb2NhbGVDb21wYXJlKGIucHJlZml4KTtcbiAgICB9XG4gICAgcmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSk7XG4gIH0pO1xuICBsZXQgbGFzdEljb24gPSB7XG4gICAgcHJvdmlkZXI6IFwiXCIsXG4gICAgcHJlZml4OiBcIlwiLFxuICAgIG5hbWU6IFwiXCJcbiAgfTtcbiAgaWNvbnMuZm9yRWFjaCgoaWNvbikgPT4ge1xuICAgIGlmIChsYXN0SWNvbi5uYW1lID09PSBpY29uLm5hbWUgJiYgbGFzdEljb24ucHJlZml4ID09PSBpY29uLnByZWZpeCAmJiBsYXN0SWNvbi5wcm92aWRlciA9PT0gaWNvbi5wcm92aWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXN0SWNvbiA9IGljb247XG4gICAgY29uc3QgcHJvdmlkZXIgPSBpY29uLnByb3ZpZGVyO1xuICAgIGNvbnN0IHByZWZpeCA9IGljb24ucHJlZml4O1xuICAgIGNvbnN0IG5hbWUgPSBpY29uLm5hbWU7XG4gICAgaWYgKHN0b3JhZ2VbcHJvdmlkZXJdID09PSB2b2lkIDApIHtcbiAgICAgIHN0b3JhZ2VbcHJvdmlkZXJdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXJTdG9yYWdlID0gc3RvcmFnZVtwcm92aWRlcl07XG4gICAgaWYgKHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdID09PSB2b2lkIDApIHtcbiAgICAgIHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdID0gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KTtcbiAgICB9XG4gICAgY29uc3QgbG9jYWxTdG9yYWdlID0gcHJvdmlkZXJTdG9yYWdlW3ByZWZpeF07XG4gICAgbGV0IGxpc3Q7XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5pY29uc1tuYW1lXSAhPT0gdm9pZCAwKSB7XG4gICAgICBsaXN0ID0gcmVzdWx0LmxvYWRlZDtcbiAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gXCJcIiB8fCBsb2NhbFN0b3JhZ2UubWlzc2luZ1tuYW1lXSAhPT0gdm9pZCAwKSB7XG4gICAgICBsaXN0ID0gcmVzdWx0Lm1pc3Npbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3QgPSByZXN1bHQucGVuZGluZztcbiAgICB9XG4gICAgY29uc3QgaXRlbSA9IHtcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgcHJlZml4LFxuICAgICAgbmFtZVxuICAgIH07XG4gICAgbGlzdC5wdXNoKGl0ZW0pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL2FwaS9jYWxsYmFja3MudHNcbnZhciBjYWxsYmFja3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xudmFyIHBlbmRpbmdVcGRhdGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIHJlbW92ZUNhbGxiYWNrKHNvdXJjZXMsIGlkKSB7XG4gIHNvdXJjZXMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBzb3VyY2UucHJvdmlkZXI7XG4gICAgaWYgKGNhbGxiYWNrc1twcm92aWRlcl0gPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlckNhbGxiYWNrcyA9IGNhbGxiYWNrc1twcm92aWRlcl07XG4gICAgY29uc3QgcHJlZml4ID0gc291cmNlLnByZWZpeDtcbiAgICBjb25zdCBpdGVtcyA9IHByb3ZpZGVyQ2FsbGJhY2tzW3ByZWZpeF07XG4gICAgaWYgKGl0ZW1zKSB7XG4gICAgICBwcm92aWRlckNhbGxiYWNrc1twcmVmaXhdID0gaXRlbXMuZmlsdGVyKChyb3cpID0+IHJvdy5pZCAhPT0gaWQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWxsYmFja3MocHJvdmlkZXIsIHByZWZpeCkge1xuICBpZiAocGVuZGluZ1VwZGF0ZXNbcHJvdmlkZXJdID09PSB2b2lkIDApIHtcbiAgICBwZW5kaW5nVXBkYXRlc1twcm92aWRlcl0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGNvbnN0IHByb3ZpZGVyUGVuZGluZ1VwZGF0ZXMgPSBwZW5kaW5nVXBkYXRlc1twcm92aWRlcl07XG4gIGlmICghcHJvdmlkZXJQZW5kaW5nVXBkYXRlc1twcmVmaXhdKSB7XG4gICAgcHJvdmlkZXJQZW5kaW5nVXBkYXRlc1twcmVmaXhdID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHByb3ZpZGVyUGVuZGluZ1VwZGF0ZXNbcHJlZml4XSA9IGZhbHNlO1xuICAgICAgaWYgKGNhbGxiYWNrc1twcm92aWRlcl0gPT09IHZvaWQgMCB8fCBjYWxsYmFja3NbcHJvdmlkZXJdW3ByZWZpeF0gPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpdGVtcyA9IGNhbGxiYWNrc1twcm92aWRlcl1bcHJlZml4XS5zbGljZSgwKTtcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpO1xuICAgICAgbGV0IGhhc1BlbmRpbmcgPSBmYWxzZTtcbiAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWNvbnMgPSBpdGVtLmljb25zO1xuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSBpY29ucy5wZW5kaW5nLmxlbmd0aDtcbiAgICAgICAgaWNvbnMucGVuZGluZyA9IGljb25zLnBlbmRpbmcuZmlsdGVyKChpY29uKSA9PiB7XG4gICAgICAgICAgaWYgKGljb24ucHJlZml4ICE9PSBwcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuYW1lID0gaWNvbi5uYW1lO1xuICAgICAgICAgIGlmIChzdG9yYWdlLmljb25zW25hbWVdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGljb25zLmxvYWRlZC5wdXNoKHtcbiAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yYWdlLm1pc3NpbmdbbmFtZV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWNvbnMubWlzc2luZy5wdXNoKHtcbiAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhc1BlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpY29ucy5wZW5kaW5nLmxlbmd0aCAhPT0gb2xkTGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFoYXNQZW5kaW5nKSB7XG4gICAgICAgICAgICByZW1vdmVDYWxsYmFjayhbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgICAgICBwcmVmaXhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSwgaXRlbS5pZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGl0ZW0uY2FsbGJhY2soaWNvbnMubG9hZGVkLnNsaWNlKDApLCBpY29ucy5taXNzaW5nLnNsaWNlKDApLCBpY29ucy5wZW5kaW5nLnNsaWNlKDApLCBpdGVtLmFib3J0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbnZhciBpZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gc3RvcmVDYWxsYmFjayhjYWxsYmFjaywgaWNvbnMsIHBlbmRpbmdTb3VyY2VzKSB7XG4gIGNvbnN0IGlkID0gaWRDb3VudGVyKys7XG4gIGNvbnN0IGFib3J0ID0gcmVtb3ZlQ2FsbGJhY2suYmluZChudWxsLCBwZW5kaW5nU291cmNlcywgaWQpO1xuICBpZiAoIWljb25zLnBlbmRpbmcubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFib3J0O1xuICB9XG4gIGNvbnN0IGl0ZW0gPSB7XG4gICAgaWQsXG4gICAgaWNvbnMsXG4gICAgY2FsbGJhY2ssXG4gICAgYWJvcnRcbiAgfTtcbiAgcGVuZGluZ1NvdXJjZXMuZm9yRWFjaCgoc291cmNlKSA9PiB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBzb3VyY2UucHJvdmlkZXI7XG4gICAgY29uc3QgcHJlZml4ID0gc291cmNlLnByZWZpeDtcbiAgICBpZiAoY2FsbGJhY2tzW3Byb3ZpZGVyXSA9PT0gdm9pZCAwKSB7XG4gICAgICBjYWxsYmFja3NbcHJvdmlkZXJdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXJDYWxsYmFja3MgPSBjYWxsYmFja3NbcHJvdmlkZXJdO1xuICAgIGlmIChwcm92aWRlckNhbGxiYWNrc1twcmVmaXhdID09PSB2b2lkIDApIHtcbiAgICAgIHByb3ZpZGVyQ2FsbGJhY2tzW3ByZWZpeF0gPSBbXTtcbiAgICB9XG4gICAgcHJvdmlkZXJDYWxsYmFja3NbcHJlZml4XS5wdXNoKGl0ZW0pO1xuICB9KTtcbiAgcmV0dXJuIGFib3J0O1xufVxuXG4vLyBzcmMvaWNvbi9saXN0LnRzXG5mdW5jdGlvbiBsaXN0VG9JY29ucyhsaXN0LCB2YWxpZGF0ZSA9IHRydWUsIHNpbXBsZU5hbWVzID0gZmFsc2UpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxpc3QuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgIGNvbnN0IGljb24gPSB0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIiA/IHN0cmluZ1RvSWNvbihpdGVtLCBmYWxzZSwgc2ltcGxlTmFtZXMpIDogaXRlbTtcbiAgICBpZiAoIXZhbGlkYXRlIHx8IHZhbGlkYXRlSWNvbihpY29uLCBzaW1wbGVOYW1lcykpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgcHJvdmlkZXI6IGljb24ucHJvdmlkZXIsXG4gICAgICAgIHByZWZpeDogaWNvbi5wcmVmaXgsXG4gICAgICAgIG5hbWU6IGljb24ubmFtZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL2NvbmZpZy50c1xudmFyIGRlZmF1bHRDb25maWcgPSB7XG4gIHJlc291cmNlczogW10sXG4gIGluZGV4OiAwLFxuICB0aW1lb3V0OiAyZTMsXG4gIHJvdGF0ZTogNzUwLFxuICByYW5kb206IGZhbHNlLFxuICBkYXRhQWZ0ZXJUaW1lb3V0OiBmYWxzZVxufTtcblxuLy8gc3JjL3F1ZXJ5LnRzXG5mdW5jdGlvbiBzZW5kUXVlcnkoY29uZmlnLCBwYXlsb2FkLCBxdWVyeSwgZG9uZSkge1xuICBjb25zdCByZXNvdXJjZXNDb3VudCA9IGNvbmZpZy5yZXNvdXJjZXMubGVuZ3RoO1xuICBjb25zdCBzdGFydEluZGV4ID0gY29uZmlnLnJhbmRvbSA/IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJlc291cmNlc0NvdW50KSA6IGNvbmZpZy5pbmRleDtcbiAgbGV0IHJlc291cmNlcztcbiAgaWYgKGNvbmZpZy5yYW5kb20pIHtcbiAgICBsZXQgbGlzdCA9IGNvbmZpZy5yZXNvdXJjZXMuc2xpY2UoMCk7XG4gICAgcmVzb3VyY2VzID0gW107XG4gICAgd2hpbGUgKGxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgY29uc3QgbmV4dEluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbGlzdC5sZW5ndGgpO1xuICAgICAgcmVzb3VyY2VzLnB1c2gobGlzdFtuZXh0SW5kZXhdKTtcbiAgICAgIGxpc3QgPSBsaXN0LnNsaWNlKDAsIG5leHRJbmRleCkuY29uY2F0KGxpc3Quc2xpY2UobmV4dEluZGV4ICsgMSkpO1xuICAgIH1cbiAgICByZXNvdXJjZXMgPSByZXNvdXJjZXMuY29uY2F0KGxpc3QpO1xuICB9IGVsc2Uge1xuICAgIHJlc291cmNlcyA9IGNvbmZpZy5yZXNvdXJjZXMuc2xpY2Uoc3RhcnRJbmRleCkuY29uY2F0KGNvbmZpZy5yZXNvdXJjZXMuc2xpY2UoMCwgc3RhcnRJbmRleCkpO1xuICB9XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gIGxldCBzdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgbGV0IHF1ZXJpZXNTZW50ID0gMDtcbiAgbGV0IGxhc3RFcnJvcjtcbiAgbGV0IHRpbWVyID0gbnVsbDtcbiAgbGV0IHF1ZXVlID0gW107XG4gIGxldCBkb25lQ2FsbGJhY2tzID0gW107XG4gIGlmICh0eXBlb2YgZG9uZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZG9uZUNhbGxiYWNrcy5wdXNoKGRvbmUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0VGltZXIoKSB7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBhYm9ydCgpIHtcbiAgICBpZiAoc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgc3RhdHVzID0gXCJhYm9ydGVkXCI7XG4gICAgfVxuICAgIHJlc2V0VGltZXIoKTtcbiAgICBxdWV1ZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIGl0ZW0uc3RhdHVzID0gXCJhYm9ydGVkXCI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcXVldWUgPSBbXTtcbiAgfVxuICBmdW5jdGlvbiBzdWJzY3JpYmUoY2FsbGJhY2ssIG92ZXJ3cml0ZSkge1xuICAgIGlmIChvdmVyd3JpdGUpIHtcbiAgICAgIGRvbmVDYWxsYmFja3MgPSBbXTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBkb25lQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRRdWVyeVN0YXR1cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRUaW1lLFxuICAgICAgcGF5bG9hZCxcbiAgICAgIHN0YXR1cyxcbiAgICAgIHF1ZXJpZXNTZW50LFxuICAgICAgcXVlcmllc1BlbmRpbmc6IHF1ZXVlLmxlbmd0aCxcbiAgICAgIHN1YnNjcmliZSxcbiAgICAgIGFib3J0XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBmYWlsUXVlcnkoKSB7XG4gICAgc3RhdHVzID0gXCJmYWlsZWRcIjtcbiAgICBkb25lQ2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjYWxsYmFjayh2b2lkIDAsIGxhc3RFcnJvcik7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgICBxdWV1ZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICBpZiAoaXRlbS5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgIGl0ZW0uc3RhdHVzID0gXCJhYm9ydGVkXCI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcXVldWUgPSBbXTtcbiAgfVxuICBmdW5jdGlvbiBtb2R1bGVSZXNwb25zZShpdGVtLCByZXNwb25zZSwgZGF0YSkge1xuICAgIGNvbnN0IGlzRXJyb3IgPSByZXNwb25zZSAhPT0gXCJzdWNjZXNzXCI7XG4gICAgcXVldWUgPSBxdWV1ZS5maWx0ZXIoKHF1ZXVlZCkgPT4gcXVldWVkICE9PSBpdGVtKTtcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZmFpbGVkXCI6XG4gICAgICAgIGlmIChpc0Vycm9yIHx8ICFjb25maWcuZGF0YUFmdGVyVGltZW91dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlID09PSBcImFib3J0XCIpIHtcbiAgICAgIGxhc3RFcnJvciA9IGRhdGE7XG4gICAgICBmYWlsUXVlcnkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgIGxhc3RFcnJvciA9IGRhdGE7XG4gICAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBpZiAoIXJlc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICBmYWlsUXVlcnkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBleGVjTmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2V0VGltZXIoKTtcbiAgICBjbGVhclF1ZXVlKCk7XG4gICAgaWYgKCFjb25maWcucmFuZG9tKSB7XG4gICAgICBjb25zdCBpbmRleCA9IGNvbmZpZy5yZXNvdXJjZXMuaW5kZXhPZihpdGVtLnJlc291cmNlKTtcbiAgICAgIGlmIChpbmRleCAhPT0gLTEgJiYgaW5kZXggIT09IGNvbmZpZy5pbmRleCkge1xuICAgICAgICBjb25maWcuaW5kZXggPSBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdHVzID0gXCJjb21wbGV0ZWRcIjtcbiAgICBkb25lQ2FsbGJhY2tzLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICBjYWxsYmFjayhkYXRhKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBleGVjTmV4dCgpIHtcbiAgICBpZiAoc3RhdHVzICE9PSBcInBlbmRpbmdcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXNldFRpbWVyKCk7XG4gICAgY29uc3QgcmVzb3VyY2UgPSByZXNvdXJjZXMuc2hpZnQoKTtcbiAgICBpZiAocmVzb3VyY2UgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlc2V0VGltZXIoKTtcbiAgICAgICAgICBpZiAoc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgY2xlYXJRdWV1ZSgpO1xuICAgICAgICAgICAgZmFpbFF1ZXJ5KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBjb25maWcudGltZW91dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZhaWxRdWVyeSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0ge1xuICAgICAgc3RhdHVzOiBcInBlbmRpbmdcIixcbiAgICAgIHJlc291cmNlLFxuICAgICAgY2FsbGJhY2s6IChzdGF0dXMyLCBkYXRhKSA9PiB7XG4gICAgICAgIG1vZHVsZVJlc3BvbnNlKGl0ZW0sIHN0YXR1czIsIGRhdGEpO1xuICAgICAgfVxuICAgIH07XG4gICAgcXVldWUucHVzaChpdGVtKTtcbiAgICBxdWVyaWVzU2VudCsrO1xuICAgIHRpbWVyID0gc2V0VGltZW91dChleGVjTmV4dCwgY29uZmlnLnJvdGF0ZSk7XG4gICAgcXVlcnkocmVzb3VyY2UsIHBheWxvYWQsIGl0ZW0uY2FsbGJhY2spO1xuICB9XG4gIHNldFRpbWVvdXQoZXhlY05leHQpO1xuICByZXR1cm4gZ2V0UXVlcnlTdGF0dXM7XG59XG5cbi8vIHNyYy9pbmRleC50c1xuZnVuY3Rpb24gc2V0Q29uZmlnKGNvbmZpZykge1xuICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY29uZmlnLnJlc291cmNlcyAhPT0gXCJvYmplY3RcIiB8fCAhKGNvbmZpZy5yZXNvdXJjZXMgaW5zdGFuY2VvZiBBcnJheSkgfHwgIWNvbmZpZy5yZXNvdXJjZXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSZWR1bmNhbmN5IGNvbmZpZ3VyYXRpb25cIik7XG4gIH1cbiAgY29uc3QgbmV3Q29uZmlnID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBrZXk7XG4gIGZvciAoa2V5IGluIGRlZmF1bHRDb25maWcpIHtcbiAgICBpZiAoY29uZmlnW2tleV0gIT09IHZvaWQgMCkge1xuICAgICAgbmV3Q29uZmlnW2tleV0gPSBjb25maWdba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3Q29uZmlnW2tleV0gPSBkZWZhdWx0Q29uZmlnW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBuZXdDb25maWc7XG59XG5mdW5jdGlvbiBpbml0UmVkdW5kYW5jeShjZmcpIHtcbiAgY29uc3QgY29uZmlnID0gc2V0Q29uZmlnKGNmZyk7XG4gIGxldCBxdWVyaWVzID0gW107XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgcXVlcmllcyA9IHF1ZXJpZXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtKCkuc3RhdHVzID09PSBcInBlbmRpbmdcIik7XG4gIH1cbiAgZnVuY3Rpb24gcXVlcnkocGF5bG9hZCwgcXVlcnlDYWxsYmFjaywgZG9uZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcXVlcnkyID0gc2VuZFF1ZXJ5KGNvbmZpZywgcGF5bG9hZCwgcXVlcnlDYWxsYmFjaywgKGRhdGEsIGVycm9yKSA9PiB7XG4gICAgICBjbGVhbnVwKCk7XG4gICAgICBpZiAoZG9uZUNhbGxiYWNrKSB7XG4gICAgICAgIGRvbmVDYWxsYmFjayhkYXRhLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcXVlcmllcy5wdXNoKHF1ZXJ5Mik7XG4gICAgcmV0dXJuIHF1ZXJ5MjtcbiAgfVxuICBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcXVlcmllcy5maW5kKCh2YWx1ZSkgPT4ge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0ICE9PSB2b2lkIDAgPyByZXN1bHQgOiBudWxsO1xuICB9XG4gIGNvbnN0IGluc3RhbmNlID0ge1xuICAgIHF1ZXJ5LFxuICAgIGZpbmQsXG4gICAgc2V0SW5kZXg6IChpbmRleCkgPT4ge1xuICAgICAgY29uZmlnLmluZGV4ID0gaW5kZXg7XG4gICAgfSxcbiAgICBnZXRJbmRleDogKCkgPT4gY29uZmlnLmluZGV4LFxuICAgIGNsZWFudXBcbiAgfTtcbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBzcmMvYXBpL3F1ZXJ5LnRzXG5mdW5jdGlvbiBlbXB0eUNhbGxiYWNrJDEoKSB7XG59XG52YXIgcmVkdW5kYW5jeUNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGdldFJlZHVuZGFuY3lDYWNoZShwcm92aWRlcikge1xuICBpZiAocmVkdW5kYW5jeUNhY2hlW3Byb3ZpZGVyXSA9PT0gdm9pZCAwKSB7XG4gICAgY29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZWR1bmRhbmN5ID0gaW5pdFJlZHVuZGFuY3koY29uZmlnKTtcbiAgICBjb25zdCBjYWNoZWRSZXVuZGFuY3kgPSB7XG4gICAgICBjb25maWcsXG4gICAgICByZWR1bmRhbmN5XG4gICAgfTtcbiAgICByZWR1bmRhbmN5Q2FjaGVbcHJvdmlkZXJdID0gY2FjaGVkUmV1bmRhbmN5O1xuICB9XG4gIHJldHVybiByZWR1bmRhbmN5Q2FjaGVbcHJvdmlkZXJdO1xufVxuZnVuY3Rpb24gc2VuZEFQSVF1ZXJ5KHRhcmdldCwgcXVlcnksIGNhbGxiYWNrKSB7XG4gIGxldCByZWR1bmRhbmN5O1xuICBsZXQgc2VuZDtcbiAgaWYgKHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBhcGkgPSBnZXRBUElNb2R1bGUodGFyZ2V0KTtcbiAgICBpZiAoIWFwaSkge1xuICAgICAgY2FsbGJhY2sodm9pZCAwLCA0MjQpO1xuICAgICAgcmV0dXJuIGVtcHR5Q2FsbGJhY2skMTtcbiAgICB9XG4gICAgc2VuZCA9IGFwaS5zZW5kO1xuICAgIGNvbnN0IGNhY2hlZCA9IGdldFJlZHVuZGFuY3lDYWNoZSh0YXJnZXQpO1xuICAgIGlmIChjYWNoZWQpIHtcbiAgICAgIHJlZHVuZGFuY3kgPSBjYWNoZWQucmVkdW5kYW5jeTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY29uZmlnID0gY3JlYXRlQVBJQ29uZmlnKHRhcmdldCk7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgcmVkdW5kYW5jeSA9IGluaXRSZWR1bmRhbmN5KGNvbmZpZyk7XG4gICAgICBjb25zdCBtb2R1bGVLZXkgPSB0YXJnZXQucmVzb3VyY2VzID8gdGFyZ2V0LnJlc291cmNlc1swXSA6IFwiXCI7XG4gICAgICBjb25zdCBhcGkgPSBnZXRBUElNb2R1bGUobW9kdWxlS2V5KTtcbiAgICAgIGlmIChhcGkpIHtcbiAgICAgICAgc2VuZCA9IGFwaS5zZW5kO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoIXJlZHVuZGFuY3kgfHwgIXNlbmQpIHtcbiAgICBjYWxsYmFjayh2b2lkIDAsIDQyNCk7XG4gICAgcmV0dXJuIGVtcHR5Q2FsbGJhY2skMTtcbiAgfVxuICByZXR1cm4gcmVkdW5kYW5jeS5xdWVyeShxdWVyeSwgc2VuZCwgY2FsbGJhY2spKCkuYWJvcnQ7XG59XG5cbi8vIHNyYy9jYWNoZS50c1xudmFyIGNhY2hlID0ge307XG5cbi8vIHNyYy9hcGkvaWNvbnMudHNcbmZ1bmN0aW9uIGVtcHR5Q2FsbGJhY2soKSB7XG59XG52YXIgcGVuZGluZ0ljb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBpY29uc1RvTG9hZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG52YXIgbG9hZGVyRmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xudmFyIHF1ZXVlRmxhZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gbG9hZGVkTmV3SWNvbnMocHJvdmlkZXIsIHByZWZpeCkge1xuICBpZiAobG9hZGVyRmxhZ3NbcHJvdmlkZXJdID09PSB2b2lkIDApIHtcbiAgICBsb2FkZXJGbGFnc1twcm92aWRlcl0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG4gIGNvbnN0IHByb3ZpZGVyTG9hZGVyRmxhZ3MgPSBsb2FkZXJGbGFnc1twcm92aWRlcl07XG4gIGlmICghcHJvdmlkZXJMb2FkZXJGbGFnc1twcmVmaXhdKSB7XG4gICAgcHJvdmlkZXJMb2FkZXJGbGFnc1twcmVmaXhdID0gdHJ1ZTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHByb3ZpZGVyTG9hZGVyRmxhZ3NbcHJlZml4XSA9IGZhbHNlO1xuICAgICAgdXBkYXRlQ2FsbGJhY2tzKHByb3ZpZGVyLCBwcmVmaXgpO1xuICAgIH0pO1xuICB9XG59XG52YXIgZXJyb3JzQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gbG9hZE5ld0ljb25zKHByb3ZpZGVyLCBwcmVmaXgsIGljb25zKSB7XG4gIGZ1bmN0aW9uIGVycigpIHtcbiAgICBjb25zdCBrZXkgPSAocHJvdmlkZXIgPT09IFwiXCIgPyBcIlwiIDogXCJAXCIgKyBwcm92aWRlciArIFwiOlwiKSArIHByZWZpeDtcbiAgICBjb25zdCB0aW1lID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gNmU0KTtcbiAgICBpZiAoZXJyb3JzQ2FjaGVba2V5XSA8IHRpbWUpIHtcbiAgICAgIGVycm9yc0NhY2hlW2tleV0gPSB0aW1lO1xuICAgICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIHJldHJpZXZlIGljb25zIGZvciBcIicgKyBrZXkgKyAnXCIgYmVjYXVzZSBBUEkgaXMgbm90IGNvbmZpZ3VyZWQgcHJvcGVybHkuJyk7XG4gICAgfVxuICB9XG4gIGlmIChpY29uc1RvTG9hZFtwcm92aWRlcl0gPT09IHZvaWQgMCkge1xuICAgIGljb25zVG9Mb2FkW3Byb3ZpZGVyXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgY29uc3QgcHJvdmlkZXJJY29uc1RvTG9hZCA9IGljb25zVG9Mb2FkW3Byb3ZpZGVyXTtcbiAgaWYgKHF1ZXVlRmxhZ3NbcHJvdmlkZXJdID09PSB2b2lkIDApIHtcbiAgICBxdWV1ZUZsYWdzW3Byb3ZpZGVyXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgY29uc3QgcHJvdmlkZXJRdWV1ZUZsYWdzID0gcXVldWVGbGFnc1twcm92aWRlcl07XG4gIGlmIChwZW5kaW5nSWNvbnNbcHJvdmlkZXJdID09PSB2b2lkIDApIHtcbiAgICBwZW5kaW5nSWNvbnNbcHJvdmlkZXJdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuICBjb25zdCBwcm92aWRlclBlbmRpbmdJY29ucyA9IHBlbmRpbmdJY29uc1twcm92aWRlcl07XG4gIGlmIChwcm92aWRlckljb25zVG9Mb2FkW3ByZWZpeF0gPT09IHZvaWQgMCkge1xuICAgIHByb3ZpZGVySWNvbnNUb0xvYWRbcHJlZml4XSA9IGljb25zO1xuICB9IGVsc2Uge1xuICAgIHByb3ZpZGVySWNvbnNUb0xvYWRbcHJlZml4XSA9IHByb3ZpZGVySWNvbnNUb0xvYWRbcHJlZml4XS5jb25jYXQoaWNvbnMpLnNvcnQoKTtcbiAgfVxuICBpZiAoIXByb3ZpZGVyUXVldWVGbGFnc1twcmVmaXhdKSB7XG4gICAgcHJvdmlkZXJRdWV1ZUZsYWdzW3ByZWZpeF0gPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcHJvdmlkZXJRdWV1ZUZsYWdzW3ByZWZpeF0gPSBmYWxzZTtcbiAgICAgIGNvbnN0IGljb25zMiA9IHByb3ZpZGVySWNvbnNUb0xvYWRbcHJlZml4XTtcbiAgICAgIGRlbGV0ZSBwcm92aWRlckljb25zVG9Mb2FkW3ByZWZpeF07XG4gICAgICBjb25zdCBhcGkgPSBnZXRBUElNb2R1bGUocHJvdmlkZXIpO1xuICAgICAgaWYgKCFhcGkpIHtcbiAgICAgICAgZXJyKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmFtcyA9IGFwaS5wcmVwYXJlKHByb3ZpZGVyLCBwcmVmaXgsIGljb25zMik7XG4gICAgICBwYXJhbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICBzZW5kQVBJUXVlcnkocHJvdmlkZXIsIGl0ZW0sIChkYXRhLCBlcnJvcikgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpO1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKGVycm9yICE9PSA0MDQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdCA9IERhdGUubm93KCk7XG4gICAgICAgICAgICBpdGVtLmljb25zLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgc3RvcmFnZS5taXNzaW5nW25hbWVdID0gdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBhZGRJY29uU2V0KHN0b3JhZ2UsIGRhdGEpO1xuICAgICAgICAgICAgICBpZiAoIXBhcnNlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgcGVuZGluZyA9IHByb3ZpZGVyUGVuZGluZ0ljb25zW3ByZWZpeF07XG4gICAgICAgICAgICAgIHBhcnNlZC5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBlbmRpbmdbbmFtZV07XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoY2FjaGUuc3RvcmUpIHtcbiAgICAgICAgICAgICAgICBjYWNoZS5zdG9yZShwcm92aWRlciwgZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycjIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbG9hZGVkTmV3SWNvbnMocHJvdmlkZXIsIHByZWZpeCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbnZhciBsb2FkSWNvbnMgPSAoaWNvbnMsIGNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGNsZWFuZWRJY29ucyA9IGxpc3RUb0ljb25zKGljb25zLCB0cnVlLCBhbGxvd1NpbXBsZU5hbWVzKCkpO1xuICBjb25zdCBzb3J0ZWRJY29ucyA9IHNvcnRJY29ucyhjbGVhbmVkSWNvbnMpO1xuICBpZiAoIXNvcnRlZEljb25zLnBlbmRpbmcubGVuZ3RoKSB7XG4gICAgbGV0IGNhbGxDYWxsYmFjayA9IHRydWU7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKGNhbGxDYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKHNvcnRlZEljb25zLmxvYWRlZCwgc29ydGVkSWNvbnMubWlzc2luZywgc29ydGVkSWNvbnMucGVuZGluZywgZW1wdHlDYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FsbENhbGxiYWNrID0gZmFsc2U7XG4gICAgfTtcbiAgfVxuICBjb25zdCBuZXdJY29ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHNvdXJjZXMgPSBbXTtcbiAgbGV0IGxhc3RQcm92aWRlciwgbGFzdFByZWZpeDtcbiAgc29ydGVkSWNvbnMucGVuZGluZy5mb3JFYWNoKChpY29uKSA9PiB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBpY29uLnByb3ZpZGVyO1xuICAgIGNvbnN0IHByZWZpeCA9IGljb24ucHJlZml4O1xuICAgIGlmIChwcmVmaXggPT09IGxhc3RQcmVmaXggJiYgcHJvdmlkZXIgPT09IGxhc3RQcm92aWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsYXN0UHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICBsYXN0UHJlZml4ID0gcHJlZml4O1xuICAgIHNvdXJjZXMucHVzaCh7XG4gICAgICBwcm92aWRlcixcbiAgICAgIHByZWZpeFxuICAgIH0pO1xuICAgIGlmIChwZW5kaW5nSWNvbnNbcHJvdmlkZXJdID09PSB2b2lkIDApIHtcbiAgICAgIHBlbmRpbmdJY29uc1twcm92aWRlcl0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlclBlbmRpbmdJY29ucyA9IHBlbmRpbmdJY29uc1twcm92aWRlcl07XG4gICAgaWYgKHByb3ZpZGVyUGVuZGluZ0ljb25zW3ByZWZpeF0gPT09IHZvaWQgMCkge1xuICAgICAgcHJvdmlkZXJQZW5kaW5nSWNvbnNbcHJlZml4XSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIGlmIChuZXdJY29uc1twcm92aWRlcl0gPT09IHZvaWQgMCkge1xuICAgICAgbmV3SWNvbnNbcHJvdmlkZXJdID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXJOZXdJY29ucyA9IG5ld0ljb25zW3Byb3ZpZGVyXTtcbiAgICBpZiAocHJvdmlkZXJOZXdJY29uc1twcmVmaXhdID09PSB2b2lkIDApIHtcbiAgICAgIHByb3ZpZGVyTmV3SWNvbnNbcHJlZml4XSA9IFtdO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpO1xuICBzb3J0ZWRJY29ucy5wZW5kaW5nLmZvckVhY2goKGljb24pID0+IHtcbiAgICBjb25zdCBwcm92aWRlciA9IGljb24ucHJvdmlkZXI7XG4gICAgY29uc3QgcHJlZml4ID0gaWNvbi5wcmVmaXg7XG4gICAgY29uc3QgbmFtZSA9IGljb24ubmFtZTtcbiAgICBjb25zdCBwZW5kaW5nUXVldWUgPSBwZW5kaW5nSWNvbnNbcHJvdmlkZXJdW3ByZWZpeF07XG4gICAgaWYgKHBlbmRpbmdRdWV1ZVtuYW1lXSA9PT0gdm9pZCAwKSB7XG4gICAgICBwZW5kaW5nUXVldWVbbmFtZV0gPSB0aW1lO1xuICAgICAgbmV3SWNvbnNbcHJvdmlkZXJdW3ByZWZpeF0ucHVzaChuYW1lKTtcbiAgICB9XG4gIH0pO1xuICBzb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gc291cmNlLnByb3ZpZGVyO1xuICAgIGNvbnN0IHByZWZpeCA9IHNvdXJjZS5wcmVmaXg7XG4gICAgaWYgKG5ld0ljb25zW3Byb3ZpZGVyXVtwcmVmaXhdLmxlbmd0aCkge1xuICAgICAgbG9hZE5ld0ljb25zKHByb3ZpZGVyLCBwcmVmaXgsIG5ld0ljb25zW3Byb3ZpZGVyXVtwcmVmaXhdKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gY2FsbGJhY2sgPyBzdG9yZUNhbGxiYWNrKGNhbGxiYWNrLCBzb3J0ZWRJY29ucywgc291cmNlcykgOiBlbXB0eUNhbGxiYWNrO1xufTtcbnZhciBpY29uc1F1ZXVlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbnZhciBsb2FkSWNvbiA9IChpY29uKSA9PiB7XG4gIGlmICh0eXBlb2YgaWNvbiA9PT0gXCJzdHJpbmdcIiAmJiBpY29uc1F1ZXVlW2ljb25dKSB7XG4gICAgcmV0dXJuIGljb25zUXVldWVbaWNvbl07XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gbmV3IFByb21pc2UoKGZ1bGZpbGwsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGljb25PYmogPSB0eXBlb2YgaWNvbiA9PT0gXCJzdHJpbmdcIiA/IHN0cmluZ1RvSWNvbihpY29uKSA6IGljb247XG4gICAgbG9hZEljb25zKFtpY29uT2JqIHx8IGljb25dLCAobG9hZGVkKSA9PiB7XG4gICAgICBpZiAobG9hZGVkLmxlbmd0aCAmJiBpY29uT2JqKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKGljb25PYmoucHJvdmlkZXIsIGljb25PYmoucHJlZml4KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGdldEljb25Gcm9tU3RvcmFnZShzdG9yYWdlLCBpY29uT2JqLm5hbWUpO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIGZ1bGZpbGwoZGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWplY3QoaWNvbik7XG4gICAgfSk7XG4gIH0pO1xuICBpZiAodHlwZW9mIGljb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICBpY29uc1F1ZXVlW2ljb25dID0gcmVzdWx0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBzcmMvYnJvd3Nlci1zdG9yYWdlL2luZGV4LnRzXG52YXIgY2FjaGVWZXJzaW9uID0gXCJpY29uaWZ5MlwiO1xudmFyIGNhY2hlUHJlZml4ID0gXCJpY29uaWZ5XCI7XG52YXIgY291bnRLZXkgPSBjYWNoZVByZWZpeCArIFwiLWNvdW50XCI7XG52YXIgdmVyc2lvbktleSA9IGNhY2hlUHJlZml4ICsgXCItdmVyc2lvblwiO1xudmFyIGhvdXIgPSAzNmU1O1xudmFyIGNhY2hlRXhwaXJhdGlvbiA9IDE2ODtcbnZhciBjb25maWcgPSB7XG4gIGxvY2FsOiB0cnVlLFxuICBzZXNzaW9uOiB0cnVlXG59O1xudmFyIGxvYWRlZCA9IGZhbHNlO1xudmFyIGNvdW50ID0ge1xuICBsb2NhbDogMCxcbiAgc2Vzc2lvbjogMFxufTtcbnZhciBlbXB0eUxpc3QgPSB7XG4gIGxvY2FsOiBbXSxcbiAgc2Vzc2lvbjogW11cbn07XG52YXIgX3dpbmRvdyA9IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyB7fSA6IHdpbmRvdztcbmZ1bmN0aW9uIGdldEdsb2JhbChrZXkpIHtcbiAgY29uc3QgYXR0ciA9IGtleSArIFwiU3RvcmFnZVwiO1xuICB0cnkge1xuICAgIGlmIChfd2luZG93ICYmIF93aW5kb3dbYXR0cl0gJiYgdHlwZW9mIF93aW5kb3dbYXR0cl0ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gX3dpbmRvd1thdHRyXTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG4gIGNvbmZpZ1trZXldID0gZmFsc2U7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2V0Q291bnQoc3RvcmFnZSwga2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHN0b3JhZ2Uuc2V0SXRlbShjb3VudEtleSwgdmFsdWUgKyBcIlwiKTtcbiAgICBjb3VudFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q291bnQoc3RvcmFnZSkge1xuICBjb25zdCBjb3VudDIgPSBzdG9yYWdlLmdldEl0ZW0oY291bnRLZXkpO1xuICBpZiAoY291bnQyKSB7XG4gICAgY29uc3QgdG90YWwgPSBwYXJzZUludChjb3VudDIpO1xuICAgIHJldHVybiB0b3RhbCA/IHRvdGFsIDogMDtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGluaXRDYWNoZShzdG9yYWdlLCBrZXkpIHtcbiAgdHJ5IHtcbiAgICBzdG9yYWdlLnNldEl0ZW0odmVyc2lvbktleSwgY2FjaGVWZXJzaW9uKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbiAgc2V0Q291bnQoc3RvcmFnZSwga2V5LCAwKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lDYWNoZShzdG9yYWdlKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdG90YWwgPSBnZXRDb3VudChzdG9yYWdlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvdGFsOyBpKyspIHtcbiAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShjYWNoZVByZWZpeCArIGkpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gIH1cbn1cbnZhciBsb2FkQ2FjaGUgPSAoKSA9PiB7XG4gIGlmIChsb2FkZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbG9hZGVkID0gdHJ1ZTtcbiAgY29uc3QgbWluVGltZSA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIGhvdXIpIC0gY2FjaGVFeHBpcmF0aW9uO1xuICBmdW5jdGlvbiBsb2FkKGtleSkge1xuICAgIGNvbnN0IGZ1bmMgPSBnZXRHbG9iYWwoa2V5KTtcbiAgICBpZiAoIWZ1bmMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ2V0SXRlbSA9IChpbmRleCkgPT4ge1xuICAgICAgY29uc3QgbmFtZSA9IGNhY2hlUHJlZml4ICsgaW5kZXg7XG4gICAgICBjb25zdCBpdGVtID0gZnVuYy5nZXRJdGVtKG5hbWUpO1xuICAgICAgaWYgKHR5cGVvZiBpdGVtICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCB2YWxpZCA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShpdGVtKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBkYXRhLmNhY2hlZCAhPT0gXCJudW1iZXJcIiB8fCBkYXRhLmNhY2hlZCA8IG1pblRpbWUgfHwgdHlwZW9mIGRhdGEucHJvdmlkZXIgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGRhdGEuZGF0YSAhPT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZGF0YS5kYXRhLnByZWZpeCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBkYXRhLnByb3ZpZGVyO1xuICAgICAgICAgIGNvbnN0IHByZWZpeCA9IGRhdGEuZGF0YS5wcmVmaXg7XG4gICAgICAgICAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCk7XG4gICAgICAgICAgdmFsaWQgPSBhZGRJY29uU2V0KHN0b3JhZ2UsIGRhdGEuZGF0YSkubGVuZ3RoID4gMDtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIGZ1bmMucmVtb3ZlSXRlbShuYW1lKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2ZXJzaW9uID0gZnVuYy5nZXRJdGVtKHZlcnNpb25LZXkpO1xuICAgICAgaWYgKHZlcnNpb24gIT09IGNhY2hlVmVyc2lvbikge1xuICAgICAgICBpZiAodmVyc2lvbikge1xuICAgICAgICAgIGRlc3Ryb3lDYWNoZShmdW5jKTtcbiAgICAgICAgfVxuICAgICAgICBpbml0Q2FjaGUoZnVuYywga2V5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHRvdGFsID0gZ2V0Q291bnQoZnVuYyk7XG4gICAgICBmb3IgKGxldCBpID0gdG90YWwgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoIWdldEl0ZW0oaSkpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gdG90YWwgLSAxKSB7XG4gICAgICAgICAgICB0b3RhbC0tO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbXB0eUxpc3Rba2V5XS5wdXNoKGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2V0Q291bnQoZnVuYywga2V5LCB0b3RhbCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGNvbmZpZykge1xuICAgIGxvYWQoa2V5KTtcbiAgfVxufTtcbnZhciBzdG9yZUNhY2hlID0gKHByb3ZpZGVyLCBkYXRhKSA9PiB7XG4gIGlmICghbG9hZGVkKSB7XG4gICAgbG9hZENhY2hlKCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcmUoa2V5KSB7XG4gICAgaWYgKCFjb25maWdba2V5XSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBmdW5jID0gZ2V0R2xvYmFsKGtleSk7XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpbmRleCA9IGVtcHR5TGlzdFtrZXldLnNoaWZ0KCk7XG4gICAgaWYgKGluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgIGluZGV4ID0gY291bnRba2V5XTtcbiAgICAgIGlmICghc2V0Q291bnQoZnVuYywga2V5LCBpbmRleCArIDEpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICAgIGNhY2hlZDogTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gaG91ciksXG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBkYXRhXG4gICAgICB9O1xuICAgICAgZnVuYy5zZXRJdGVtKGNhY2hlUHJlZml4ICsgaW5kZXgsIEpTT04uc3RyaW5naWZ5KGl0ZW0pKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFPYmplY3Qua2V5cyhkYXRhLmljb25zKS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGRhdGEubm90X2ZvdW5kKSB7XG4gICAgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGEpO1xuICAgIGRlbGV0ZSBkYXRhLm5vdF9mb3VuZDtcbiAgfVxuICBpZiAoIXN0b3JlKFwibG9jYWxcIikpIHtcbiAgICBzdG9yZShcInNlc3Npb25cIik7XG4gIH1cbn07XG5cbi8vIHNyYy9icm93c2VyLXN0b3JhZ2UvZnVuY3Rpb25zLnRzXG5mdW5jdGlvbiB0b2dnbGVCcm93c2VyQ2FjaGUoc3RvcmFnZSwgdmFsdWUpIHtcbiAgc3dpdGNoIChzdG9yYWdlKSB7XG4gICAgY2FzZSBcImxvY2FsXCI6XG4gICAgY2FzZSBcInNlc3Npb25cIjpcbiAgICAgIGNvbmZpZ1tzdG9yYWdlXSA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImFsbFwiOlxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZ1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxufVxuXG4vLyBzcmMvY3VzdG9taXNhdGlvbnMvc2hvcnRoYW5kLnRzXG52YXIgc2VwYXJhdG9yID0gL1tcXHMsXSsvO1xuZnVuY3Rpb24gZmxpcEZyb21TdHJpbmcoY3VzdG9tLCBmbGlwKSB7XG4gIGZsaXAuc3BsaXQoc2VwYXJhdG9yKS5mb3JFYWNoKChzdHIpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0ci50cmltKCk7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgICAgY3VzdG9tLmhGbGlwID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidmVydGljYWxcIjpcbiAgICAgICAgY3VzdG9tLnZGbGlwID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFsaWdubWVudEZyb21TdHJpbmcoY3VzdG9tLCBhbGlnbikge1xuICBhbGlnbi5zcGxpdChzZXBhcmF0b3IpLmZvckVhY2goKHN0cikgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc3RyLnRyaW0oKTtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIGN1c3RvbS5oQWxpZ24gPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwidG9wXCI6XG4gICAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgIGN1c3RvbS52QWxpZ24gPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2xpY2VcIjpcbiAgICAgIGNhc2UgXCJjcm9wXCI6XG4gICAgICAgIGN1c3RvbS5zbGljZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1lZXRcIjpcbiAgICAgICAgY3VzdG9tLnNsaWNlID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2N1c3RvbWlzYXRpb25zL3JvdGF0ZS50c1xuZnVuY3Rpb24gcm90YXRlRnJvbVN0cmluZyh2YWx1ZSwgZGVmYXVsdFZhbHVlID0gMCkge1xuICBjb25zdCB1bml0cyA9IHZhbHVlLnJlcGxhY2UoL14tP1swLTkuXSovLCBcIlwiKTtcbiAgZnVuY3Rpb24gY2xlYW51cCh2YWx1ZTIpIHtcbiAgICB3aGlsZSAodmFsdWUyIDwgMCkge1xuICAgICAgdmFsdWUyICs9IDQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTIgJSA0O1xuICB9XG4gIGlmICh1bml0cyA9PT0gXCJcIikge1xuICAgIGNvbnN0IG51bSA9IHBhcnNlSW50KHZhbHVlKTtcbiAgICByZXR1cm4gaXNOYU4obnVtKSA/IDAgOiBjbGVhbnVwKG51bSk7XG4gIH0gZWxzZSBpZiAodW5pdHMgIT09IHZhbHVlKSB7XG4gICAgbGV0IHNwbGl0ID0gMDtcbiAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICBjYXNlIFwiJVwiOlxuICAgICAgICBzcGxpdCA9IDI1O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkZWdcIjpcbiAgICAgICAgc3BsaXQgPSA5MDtcbiAgICB9XG4gICAgaWYgKHNwbGl0KSB7XG4gICAgICBsZXQgbnVtID0gcGFyc2VGbG9hdCh2YWx1ZS5zbGljZSgwLCB2YWx1ZS5sZW5ndGggLSB1bml0cy5sZW5ndGgpKTtcbiAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgICAgbnVtID0gbnVtIC8gc3BsaXQ7XG4gICAgICByZXR1cm4gbnVtICUgMSA9PT0gMCA/IGNsZWFudXAobnVtKSA6IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogRGVmYXVsdCBTVkcgYXR0cmlidXRlc1xuICovXG5jb25zdCBzdmdEZWZhdWx0cyA9IHtcbiAgICAneG1sbnMnOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgICd4bWxuc1hsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAgICdhcmlhLWhpZGRlbic6IHRydWUsXG4gICAgJ3JvbGUnOiAnaW1nJyxcbiAgICAnc3R5bGUnOiB7fSwgLy8gSW5jbHVkZSBzdHlsZSBpZiBpdCBpc24ndCBzZXQgdG8gYWRkIHZlcnRpY2FsQWxpZ24gbGF0ZXJcbn07XG4vKipcbiAqIERlZmF1bHQgdmFsdWVzIGZvciBjdXN0b21pc2F0aW9ucyBmb3IgaW5saW5lIGljb25cbiAqL1xuY29uc3QgaW5saW5lRGVmYXVsdHMgPSB7IC4uLmRlZmF1bHRzLCBpbmxpbmU6IHRydWUgfTtcbi8qKlxuICogUmVuZGVyIGljb25cbiAqL1xuY29uc3QgcmVuZGVyID0gKFxuLy8gSWNvbiBtdXN0IGJlIHZhbGlkYXRlZCBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uXG5pY29uLCBcbi8vIFBhcnRpYWwgcHJvcGVydGllc1xucHJvcHMsIFxuLy8gVHJ1ZSBpZiBpY29uIHNob3VsZCBoYXZlIHZlcnRpY2FsLWFsaWduIGFkZGVkXG5pbmxpbmUsIFxuLy8gT3B0aW9uYWwgcmVmZXJlbmNlIGZvciBTVkcsIGV4dHJhY3RlZCBieSBSZWFjdC5mb3J3YXJkUmVmKClcbnJlZikgPT4ge1xuICAgIC8vIEdldCBkZWZhdWx0IHByb3BlcnRpZXNcbiAgICBjb25zdCBkZWZhdWx0UHJvcHMgPSBpbmxpbmUgPyBpbmxpbmVEZWZhdWx0cyA6IGRlZmF1bHRzO1xuICAgIC8vIEdldCBhbGwgY3VzdG9taXNhdGlvbnNcbiAgICBjb25zdCBjdXN0b21pc2F0aW9ucyA9IG1lcmdlQ3VzdG9taXNhdGlvbnMoZGVmYXVsdFByb3BzLCBwcm9wcyk7XG4gICAgLy8gQ3JlYXRlIHN0eWxlXG4gICAgY29uc3Qgc3R5bGUgPSB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnICYmIHByb3BzLnN0eWxlICE9PSBudWxsXG4gICAgICAgID8gcHJvcHMuc3R5bGVcbiAgICAgICAgOiB7fTtcbiAgICAvLyBDcmVhdGUgU1ZHIGNvbXBvbmVudCBwcm9wZXJ0aWVzXG4gICAgY29uc3QgY29tcG9uZW50UHJvcHMgPSB7IC4uLnN2Z0RlZmF1bHRzLCByZWYsIHN0eWxlIH07XG4gICAgLy8gR2V0IGVsZW1lbnQgcHJvcGVydGllc1xuICAgIGZvciAobGV0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BzW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgLy8gUHJvcGVydGllcyB0byBpZ25vcmVcbiAgICAgICAgICAgIGNhc2UgJ2ljb24nOlxuICAgICAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgICAgY2FzZSAnY2hpbGRyZW4nOlxuICAgICAgICAgICAgY2FzZSAnb25Mb2FkJzpcbiAgICAgICAgICAgIGNhc2UgJ19yZWYnOlxuICAgICAgICAgICAgY2FzZSAnX2lubGluZSc6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBCb29sZWFuIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIGNhc2UgJ2lubGluZSc6XG4gICAgICAgICAgICBjYXNlICdoRmxpcCc6XG4gICAgICAgICAgICBjYXNlICd2RmxpcCc6XG4gICAgICAgICAgICAgICAgY3VzdG9taXNhdGlvbnNba2V5XSA9XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBGbGlwIGFzIHN0cmluZzogJ2hvcml6b250YWwsdmVydGljYWwnXG4gICAgICAgICAgICBjYXNlICdmbGlwJzpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBmbGlwRnJvbVN0cmluZyhjdXN0b21pc2F0aW9ucywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIEFsaWdubWVudCBhcyBzdHJpbmdcbiAgICAgICAgICAgIGNhc2UgJ2FsaWduJzpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRGcm9tU3RyaW5nKGN1c3RvbWlzYXRpb25zLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQ29sb3I6IGNvcHkgdG8gc3R5bGVcbiAgICAgICAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgICAgICAgICAgICBzdHlsZS5jb2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gUm90YXRpb24gYXMgc3RyaW5nXG4gICAgICAgICAgICBjYXNlICdyb3RhdGUnOlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbWlzYXRpb25zW2tleV0gPSByb3RhdGVGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICBjdXN0b21pc2F0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGFyaWEtaGlkZGVuXG4gICAgICAgICAgICBjYXNlICdhcmlhSGlkZGVuJzpcbiAgICAgICAgICAgIGNhc2UgJ2FyaWEtaGlkZGVuJzpcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUgJiYgdmFsdWUgIT09ICd0cnVlJykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY29tcG9uZW50UHJvcHNbJ2FyaWEtaGlkZGVuJ107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gQ29weSBtaXNzaW5nIHByb3BlcnR5IGlmIGl0IGRvZXMgbm90IGV4aXN0IGluIGN1c3RvbWlzYXRpb25zXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0UHJvcHNba2V5XSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFByb3BzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gR2VuZXJhdGUgaWNvblxuICAgIGNvbnN0IGl0ZW0gPSBpY29uVG9TVkcoaWNvbiwgY3VzdG9taXNhdGlvbnMpO1xuICAgIC8vIENvdW50ZXIgZm9yIGlkcyBiYXNlZCBvbiBcImlkXCIgcHJvcGVydHkgdG8gcmVuZGVyIGljb25zIGNvbnNpc3RlbnRseSBvbiBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgIGxldCBsb2NhbENvdW50ZXIgPSAwO1xuICAgIGxldCBpZCA9IHByb3BzLmlkO1xuICAgIGlmICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIENvbnZlcnQgJy0nIHRvICdfJyB0byBhdm9pZCBlcnJvcnMgaW4gYW5pbWF0aW9uc1xuICAgICAgICBpZCA9IGlkLnJlcGxhY2UoLy0vZywgJ18nKTtcbiAgICB9XG4gICAgLy8gQWRkIGljb24gc3R1ZmZcbiAgICBjb21wb25lbnRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9IHtcbiAgICAgICAgX19odG1sOiByZXBsYWNlSURzKGl0ZW0uYm9keSwgaWQgPyAoKSA9PiBpZCArICdJRCcgKyBsb2NhbENvdW50ZXIrKyA6ICdpY29uaWZ5UmVhY3QnKSxcbiAgICB9O1xuICAgIGZvciAobGV0IGtleSBpbiBpdGVtLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgY29tcG9uZW50UHJvcHNba2V5XSA9IGl0ZW0uYXR0cmlidXRlc1trZXldO1xuICAgIH1cbiAgICBpZiAoaXRlbS5pbmxpbmUgJiYgc3R5bGUudmVydGljYWxBbGlnbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHN0eWxlLnZlcnRpY2FsQWxpZ24gPSAnLTAuMTI1ZW0nO1xuICAgIH1cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgnc3ZnJywgY29tcG9uZW50UHJvcHMpO1xufTtcblxuLyoqXG4gKiBFbmFibGUgY2FjaGVcbiAqL1xuZnVuY3Rpb24gZW5hYmxlQ2FjaGUoc3RvcmFnZSkge1xuICAgIHRvZ2dsZUJyb3dzZXJDYWNoZShzdG9yYWdlLCB0cnVlKTtcbn1cbi8qKlxuICogRGlzYWJsZSBjYWNoZVxuICovXG5mdW5jdGlvbiBkaXNhYmxlQ2FjaGUoc3RvcmFnZSkge1xuICAgIHRvZ2dsZUJyb3dzZXJDYWNoZShzdG9yYWdlLCBmYWxzZSk7XG59XG4vKipcbiAqIEluaXRpYWxpc2Ugc3R1ZmZcbiAqL1xuLy8gRW5hYmxlIHNob3J0IG5hbWVzXG5hbGxvd1NpbXBsZU5hbWVzKHRydWUpO1xuLy8gU2V0IEFQSSBtb2R1bGVcbnNldEFQSU1vZHVsZSgnJywgZmV0Y2hBUElNb2R1bGUpO1xuLyoqXG4gKiBCcm93c2VyIHN0dWZmXG4gKi9cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gU2V0IGNhY2hlIGFuZCBsb2FkIGV4aXN0aW5nIGNhY2hlXG4gICAgY2FjaGUuc3RvcmUgPSBzdG9yZUNhY2hlO1xuICAgIGxvYWRDYWNoZSgpO1xuICAgIGNvbnN0IF93aW5kb3cgPSB3aW5kb3c7XG4gICAgLy8gTG9hZCBpY29ucyBmcm9tIGdsb2JhbCBcIkljb25pZnlQcmVsb2FkXCJcbiAgICBpZiAoX3dpbmRvdy5JY29uaWZ5UHJlbG9hZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHByZWxvYWQgPSBfd2luZG93Lkljb25pZnlQcmVsb2FkO1xuICAgICAgICBjb25zdCBlcnIgPSAnSW52YWxpZCBJY29uaWZ5UHJlbG9hZCBzeW50YXguJztcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVsb2FkID09PSAnb2JqZWN0JyAmJiBwcmVsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAocHJlbG9hZCBpbnN0YW5jZW9mIEFycmF5ID8gcHJlbG9hZCA6IFtwcmVsb2FkXSkuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXRlbSBpcyBhbiBvYmplY3QgYW5kIG5vdCBudWxsL2FycmF5XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSBpbnN0YW5jZW9mIEFycmF5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgJ2ljb25zJyBhbmQgJ3ByZWZpeCdcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtLmljb25zICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGl0ZW0ucHJlZml4ICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGljb24gc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAhYWRkQ29sbGVjdGlvbihpdGVtKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXQgQVBJIGZyb20gZ2xvYmFsIFwiSWNvbmlmeVByb3ZpZGVyc1wiXG4gICAgaWYgKF93aW5kb3cuSWNvbmlmeVByb3ZpZGVycyAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVycyA9IF93aW5kb3cuSWNvbmlmeVByb3ZpZGVycztcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcnMgPT09ICdvYmplY3QnICYmIHByb3ZpZGVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChsZXQga2V5IGluIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9ICdJY29uaWZ5UHJvdmlkZXJzWycgKyBrZXkgKyAnXSBpcyBpbnZhbGlkLic7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm92aWRlcnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICF2YWx1ZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucmVzb3VyY2VzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWRkQVBJUHJvdmlkZXIoa2V5LCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgSWNvbkNvbXBvbmVudCBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHBsYWNlaG9sZGVyIGJlZm9yZSBjb21wb25lbnQgaXMgbW91bnRlZFxuICAgICAgICAgICAgaWNvbjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWJvcnQgbG9hZGluZyBpY29uXG4gICAgICovXG4gICAgX2Fib3J0TG9hZGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvYWRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmcuYWJvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBzdGF0ZVxuICAgICAqL1xuICAgIF9zZXREYXRhKGljb24pIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuaWNvbiAhPT0gaWNvbikge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgaWNvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGljb24gc2hvdWxkIGJlIGxvYWRlZFxuICAgICAqL1xuICAgIF9jaGVja0ljb24oY2hhbmdlZCkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGljb24gPSB0aGlzLnByb3BzLmljb247XG4gICAgICAgIC8vIEljb24gaXMgYW4gb2JqZWN0XG4gICAgICAgIGlmICh0eXBlb2YgaWNvbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIGljb24gIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBpY29uLmJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBTdG9wIGxvYWRpbmdcbiAgICAgICAgICAgIHRoaXMuX2ljb24gPSAnJztcbiAgICAgICAgICAgIHRoaXMuX2Fib3J0TG9hZGluZygpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQgfHwgc3RhdGUuaWNvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFNldCBkYXRhIGlmIGl0IHdhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGZ1bGxJY29uKGljb24pLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEludmFsaWQgaWNvbj9cbiAgICAgICAgbGV0IGljb25OYW1lO1xuICAgICAgICBpZiAodHlwZW9mIGljb24gIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAoaWNvbk5hbWUgPSBzdHJpbmdUb0ljb24oaWNvbiwgZmFsc2UsIHRydWUpKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXREYXRhKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvYWQgaWNvblxuICAgICAgICBjb25zdCBkYXRhID0gZ2V0SWNvbkRhdGEoaWNvbk5hbWUpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWNvbiBuZWVkcyB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgIGlmICghdGhpcy5fbG9hZGluZyB8fCB0aGlzLl9sb2FkaW5nLm5hbWUgIT09IGljb24pIHtcbiAgICAgICAgICAgICAgICAvLyBOZXcgaWNvbiB0byBsb2FkXG4gICAgICAgICAgICAgICAgdGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbiA9ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldERhdGEobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGluZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaWNvbixcbiAgICAgICAgICAgICAgICAgICAgYWJvcnQ6IGxvYWRJY29ucyhbaWNvbk5hbWVdLCB0aGlzLl9jaGVja0ljb24uYmluZCh0aGlzLCBmYWxzZSkpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWNvbiBkYXRhIGlzIGF2YWlsYWJsZVxuICAgICAgICBpZiAodGhpcy5faWNvbiAhPT0gaWNvbiB8fCBzdGF0ZS5pY29uID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBOZXcgaWNvbiBvciBpY29uIGhhcyBiZWVuIGxvYWRlZFxuICAgICAgICAgICAgdGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gICAgICAgICAgICB0aGlzLl9pY29uID0gaWNvbjtcbiAgICAgICAgICAgIC8vIEFkZCBjbGFzc2VzXG4gICAgICAgICAgICBjb25zdCBjbGFzc2VzID0gWydpY29uaWZ5J107XG4gICAgICAgICAgICBpZiAoaWNvbk5hbWUucHJlZml4ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnaWNvbmlmeS0tJyArIGljb25OYW1lLnByZWZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWNvbk5hbWUucHJvdmlkZXIgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdpY29uaWZ5LS0nICsgaWNvbk5hbWUucHJvdmlkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IGRhdGFcbiAgICAgICAgICAgIHRoaXMuX3NldERhdGEoe1xuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgY2xhc3NlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvcHMub25Mb2FkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkxvYWQoaWNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IG1vdW50ZWRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tJY29uKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IHVwZGF0ZWRcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRVcGRhdGUob2xkUHJvcHMpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzLmljb24gIT09IHRoaXMucHJvcHMuaWNvbikge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tJY29uKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFib3J0IGxvYWRpbmdcbiAgICAgKi9cbiAgICBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgICAgdGhpcy5fYWJvcnRMb2FkaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlclxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBpY29uID0gdGhpcy5zdGF0ZS5pY29uO1xuICAgICAgICBpZiAoaWNvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gUmVuZGVyIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW5cbiAgICAgICAgICAgICAgICA/IHByb3BzLmNoaWxkcmVuXG4gICAgICAgICAgICAgICAgOiBSZWFjdC5jcmVhdGVFbGVtZW50KCdzcGFuJywge30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBjbGFzc2VzXG4gICAgICAgIGxldCBuZXdQcm9wcyA9IHByb3BzO1xuICAgICAgICBpZiAoaWNvbi5jbGFzc2VzKSB7XG4gICAgICAgICAgICBuZXdQcm9wcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICh0eXBlb2YgcHJvcHMuY2xhc3NOYW1lID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHByb3BzLmNsYXNzTmFtZSArICcgJ1xuICAgICAgICAgICAgICAgICAgICA6ICcnKSArIGljb24uY2xhc3Nlcy5qb2luKCcgJyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmRlciBpY29uXG4gICAgICAgIHJldHVybiByZW5kZXIoaWNvbi5kYXRhLCBuZXdQcm9wcywgcHJvcHMuX2lubGluZSwgcHJvcHMuX3JlZik7XG4gICAgfVxufVxuLyoqXG4gKiBCbG9jayBpY29uXG4gKlxuICogQHBhcmFtIHByb3BzIC0gQ29tcG9uZW50IHByb3BlcnRpZXNcbiAqL1xuY29uc3QgSWNvbiA9IFJlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gSWNvbihwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBfcmVmOiByZWYsXG4gICAgICAgIF9pbmxpbmU6IGZhbHNlLFxuICAgIH07XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkNvbXBvbmVudCwgbmV3UHJvcHMpO1xufSk7XG4vKipcbiAqIElubGluZSBpY29uIChoYXMgbmVnYXRpdmUgdmVydGljYWxBbGlnbiB0aGF0IG1ha2VzIGl0IGJlaGF2ZSBsaWtlIGljb24gZm9udClcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBDb21wb25lbnQgcHJvcGVydGllc1xuICovXG5jb25zdCBJbmxpbmVJY29uID0gUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBJbmxpbmVJY29uKHByb3BzLCByZWYpIHtcbiAgICBjb25zdCBuZXdQcm9wcyA9IHsgLi4ucHJvcHMsIF9yZWY6IHJlZiwgX2lubGluZTogdHJ1ZSB9O1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KEljb25Db21wb25lbnQsIG5ld1Byb3BzKTtcbn0pO1xuLyoqXG4gKiBJbnRlcm5hbCBBUElcbiAqL1xuY29uc3QgX2FwaSA9IHtcbiAgICBnZXRBUElDb25maWcsXG4gICAgc2V0QVBJTW9kdWxlLFxuICAgIHNlbmRBUElRdWVyeSxcbiAgICBzZXRGZXRjaCxcbiAgICBnZXRGZXRjaCxcbiAgICBsaXN0QVBJUHJvdmlkZXJzLFxuICAgIG1lcmdlUGFyYW1zLFxufTtcblxuZXhwb3J0IHsgSWNvbiwgSW5saW5lSWNvbiwgX2FwaSwgYWRkQVBJUHJvdmlkZXIsIGFkZENvbGxlY3Rpb24sIGFkZEljb24sIGJ1aWxkSWNvbiwgY2FsY3VsYXRlU2l6ZSwgZGlzYWJsZUNhY2hlLCBlbmFibGVDYWNoZSwgZ2V0SWNvbiwgaWNvbkV4aXN0cywgbGlzdEljb25zLCBsb2FkSWNvbiwgbG9hZEljb25zLCByZXBsYWNlSURzLCBzaGFyZVN0b3JhZ2UgfTtcbiIsICJpbXBvcnQgQmFkZ2UgZnJvbSAncmVhY3QtYm9vdHN0cmFwL0JhZGdlJztcbmltcG9ydCB7IFZlcnRpY2FsVGltZWxpbmUsIFZlcnRpY2FsVGltZWxpbmVFbGVtZW50IH0gZnJvbSAncmVhY3QtdmVydGljYWwtdGltZWxpbmUtY29tcG9uZW50JztcbmltcG9ydCBleHBlcmllbmNlRGF0YSBmcm9tICd+L3Jlc3VtZV9jb250ZW50L2V4cGVyaWVuY2UnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBFeHBlcmllbmNlKHsgZXhwaXJpZW5jZSB9OiB7IGV4cGlyaWVuY2U6IHR5cGVvZiBleHBlcmllbmNlRGF0YSB9KSB7XG4gIGNvbnN0IHdvcmsgPSBleHBpcmllbmNlLm1hcChmdW5jdGlvbiAod29yaywgaSkge1xuXG4gICAgY29uc3QgbWFpblRlY2ggPSB3b3JrLm1haW5UZWNoLm1hcCgodGVjaG5vbG9neSwgaSkgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgPEJhZGdlIHBpbGwgY2xhc3NOYW1lPVwibWFpbi1iYWRnZSBtci0yIG1iLTJcIiBrZXk9e2l9PlxuICAgICAgICAgIHt0ZWNobm9sb2d5fVxuICAgICAgICA8L0JhZGdlPlxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHRlY2ggPSB3b3JrLnRlY2hub2xvZ2llcy5tYXAoKHRlY2hub2xvZ3ksIGkpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxCYWRnZSBwaWxsIGNsYXNzTmFtZT1cImV4cGVyaWVuY2UtYmFkZ2UgbXItMiBtYi0yXCIga2V5PXtpfT5cbiAgICAgICAgICB7dGVjaG5vbG9neX1cbiAgICAgICAgPC9CYWRnZT5cbiAgICAgICk7XG4gICAgfSk7XG4gICAgcmV0dXJuIChcbiAgICAgIDxWZXJ0aWNhbFRpbWVsaW5lRWxlbWVudFxuICAgICAgICBjbGFzc05hbWU9XCJ2ZXJ0aWNhbC10aW1lbGluZS1lbGVtZW50LS13b3JrXCJcbiAgICAgICAgZGF0ZT17d29yay55ZWFyc31cbiAgICAgICAgaWNvblN0eWxlPXt7XG4gICAgICAgICAgYmFja2dyb3VuZDogXCIjQUU5NDRGXCIsXG4gICAgICAgICAgY29sb3I6IFwiI2ZmZlwiLFxuICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgfX1cbiAgICAgICAgaWNvbj17PGkgY2xhc3NOYW1lPXtgZXhwZXJpZW5jZS1pY29uICR7d29yay5pY29uQ2xhc3N9YH0+PC9pPn1cbiAgICAgICAga2V5PXtpfVxuICAgICAgPlxuICAgICAgICA8ZGl2IHN0eWxlPXt7IHRleHRBbGlnbjogXCJsZWZ0XCIsIG1hcmdpbkJvdHRvbTogXCI0cHhcIiB9fT57bWFpblRlY2h9PC9kaXY+XG5cbiAgICAgICAgPGgzIGNsYXNzTmFtZT1cInZlcnRpY2FsLXRpbWVsaW5lLWVsZW1lbnQtdGl0bGVcIiBzdHlsZT17eyB0ZXh0QWxpZ246IFwibGVmdFwiIH19PlxuICAgICAgICAgIHt3b3JrLnRpdGxlfVxuICAgICAgICA8L2gzPlxuICAgICAgICA8aDQgY2xhc3NOYW1lPVwidmVydGljYWwtdGltZWxpbmUtZWxlbWVudC1zdWJ0aXRsZVwiIHN0eWxlPXt7IHRleHRBbGlnbjogXCJsZWZ0XCIgfX0+XG4gICAgICAgICAgPGEgaHJlZj17d29yay5jb21wYW55Lmxpbmt9PkB7d29yay5jb21wYW55LnRpdGxlfTwvYT5cbiAgICAgICAgPC9oND5cbiAgICAgICAgPGRpdiBzdHlsZT17eyB0ZXh0QWxpZ246IFwibGVmdFwiLCBtYXJnaW5Ub3A6IFwiMTVweFwiIH19Pnt0ZWNofTwvZGl2PlxuICAgICAgPC9WZXJ0aWNhbFRpbWVsaW5lRWxlbWVudD5cbiAgICApO1xuICB9KTtcblxuICByZXR1cm4gKFxuICAgIDxzZWN0aW9uIGlkPVwicmVzdW1lXCIgY2xhc3NOYW1lPVwicGItNVwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtbWQtMTIgbXgtYXV0b1wiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1tZC0xMlwiPlxuICAgICAgICAgIDxoMSBjbGFzc05hbWU9XCJzZWN0aW9uLXRpdGxlXCIgc3R5bGU9e3sgY29sb3I6IFwiYmxhY2tcIiB9fT5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtYmxhY2tcIiBzdHlsZT17eyB0ZXh0QWxpZ246IFwiY2VudGVyXCIgfX0+XG4gICAgICAgICAgICAgIEV4cGlyaWVuY2VcbiAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICA8L2gxPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtbWQtOCBteC1hdXRvXCI+XG4gICAgICAgIDxWZXJ0aWNhbFRpbWVsaW5lPlxuICAgICAgICAgIHt3b3JrfVxuICAgICAgICAgIDxWZXJ0aWNhbFRpbWVsaW5lRWxlbWVudFxuICAgICAgICAgICAgaWNvblN0eWxlPXt7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6IFwiI0FFOTQ0RlwiLFxuICAgICAgICAgICAgICBjb2xvcjogXCIjZmZmXCIsXG4gICAgICAgICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICBpY29uPXs8aSBjbGFzc05hbWU9XCJmYXMgZmEtaG91cmdsYXNzLXN0YXJ0IG14LWF1dG8gZXhwZXJpZW5jZS1pY29uXCI+PC9pPn1cbiAgICAgICAgICAvPlxuICAgICAgICA8L1ZlcnRpY2FsVGltZWxpbmU+XG4gICAgICA8L2Rpdj5cbiAgICA8L3NlY3Rpb24+XG4gICk7XG59XG4iLCAiaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VCb290c3RyYXBQcmVmaXggfSBmcm9tICcuL1RoZW1lUHJvdmlkZXInO1xuaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgYmc6ICdwcmltYXJ5JyxcbiAgcGlsbDogZmFsc2Vcbn07XG5jb25zdCBCYWRnZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIGJzUHJlZml4LFxuICBiZyxcbiAgcGlsbCxcbiAgdGV4dCxcbiAgY2xhc3NOYW1lLFxuICBhczogQ29tcG9uZW50ID0gJ3NwYW4nLFxuICAuLi5wcm9wc1xufSwgcmVmKSA9PiB7XG4gIGNvbnN0IHByZWZpeCA9IHVzZUJvb3RzdHJhcFByZWZpeChic1ByZWZpeCwgJ2JhZGdlJyk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeChDb21wb25lbnQsIHtcbiAgICByZWY6IHJlZixcbiAgICAuLi5wcm9wcyxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZXMoY2xhc3NOYW1lLCBwcmVmaXgsIHBpbGwgJiYgYHJvdW5kZWQtcGlsbGAsIHRleHQgJiYgYHRleHQtJHt0ZXh0fWAsIGJnICYmIGBiZy0ke2JnfWApXG4gIH0pO1xufSk7XG5CYWRnZS5kaXNwbGF5TmFtZSA9ICdCYWRnZSc7XG5CYWRnZS5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBCYWRnZTsiLCAiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5jb25zdCBUaGVtZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gIHByZWZpeGVzOiB7fVxufSk7XG5jb25zdCB7XG4gIENvbnN1bWVyLFxuICBQcm92aWRlclxufSA9IFRoZW1lQ29udGV4dDtcblxuZnVuY3Rpb24gVGhlbWVQcm92aWRlcih7XG4gIHByZWZpeGVzID0ge30sXG4gIGRpcixcbiAgY2hpbGRyZW5cbn0pIHtcbiAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIHByZWZpeGVzOiB7IC4uLnByZWZpeGVzXG4gICAgfSxcbiAgICBkaXJcbiAgfSksIFtwcmVmaXhlcywgZGlyXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeChQcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250ZXh0VmFsdWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQm9vdHN0cmFwUHJlZml4KHByZWZpeCwgZGVmYXVsdFByZWZpeCkge1xuICBjb25zdCB7XG4gICAgcHJlZml4ZXNcbiAgfSA9IHVzZUNvbnRleHQoVGhlbWVDb250ZXh0KTtcbiAgcmV0dXJuIHByZWZpeCB8fCBwcmVmaXhlc1tkZWZhdWx0UHJlZml4XSB8fCBkZWZhdWx0UHJlZml4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVzZUlzUlRMKCkge1xuICBjb25zdCB7XG4gICAgZGlyXG4gIH0gPSB1c2VDb250ZXh0KFRoZW1lQ29udGV4dCk7XG4gIHJldHVybiBkaXIgPT09ICdydGwnO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCb290c3RyYXBDb21wb25lbnQoQ29tcG9uZW50LCBvcHRzKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIG9wdHMgPSB7XG4gICAgcHJlZml4OiBvcHRzXG4gIH07XG4gIGNvbnN0IGlzQ2xhc3N5ID0gQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ7IC8vIElmIGl0J3MgYSBmdW5jdGlvbmFsIGNvbXBvbmVudCBtYWtlIHN1cmUgd2UgZG9uJ3QgYnJlYWsgaXQgd2l0aCBhIHJlZlxuXG4gIGNvbnN0IHtcbiAgICBwcmVmaXgsXG4gICAgZm9yd2FyZFJlZkFzID0gaXNDbGFzc3kgPyAncmVmJyA6ICdpbm5lclJlZidcbiAgfSA9IG9wdHM7XG4gIGNvbnN0IFdyYXBwZWQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoeyAuLi5wcm9wc1xuICB9LCByZWYpID0+IHtcbiAgICBwcm9wc1tmb3J3YXJkUmVmQXNdID0gcmVmO1xuICAgIGNvbnN0IGJzUHJlZml4ID0gdXNlQm9vdHN0cmFwUHJlZml4KHByb3BzLmJzUHJlZml4LCBwcmVmaXgpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeChDb21wb25lbnQsIHsgLi4ucHJvcHMsXG4gICAgICBic1ByZWZpeDogYnNQcmVmaXhcbiAgICB9KTtcbiAgfSk7XG4gIFdyYXBwZWQuZGlzcGxheU5hbWUgPSBgQm9vdHN0cmFwKCR7Q29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lfSlgO1xuICByZXR1cm4gV3JhcHBlZDtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQm9vdHN0cmFwQ29tcG9uZW50LCBDb25zdW1lciBhcyBUaGVtZUNvbnN1bWVyIH07XG5leHBvcnQgZGVmYXVsdCBUaGVtZVByb3ZpZGVyOyIsICJpbXBvcnQgc29jaWFsRGF0YSBmcm9tICd+L3Jlc3VtZV9jb250ZW50L3NvY2lhbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZvb3Rlcih7c29jaWFsfToge3NvY2lhbDogdHlwZW9mIHNvY2lhbERhdGF9KSB7XG4gIHZhciBuZXR3b3JrcyA9IHNvY2lhbC5tYXAoZnVuY3Rpb24gKG5ldHdvcmspIHtcbiAgICByZXR1cm4gKFxuICAgICAgPHNwYW4ga2V5PXtuZXR3b3JrLm5hbWV9IGNsYXNzTmFtZT1cIm0tNFwiPlxuICAgICAgICA8YSBocmVmPXtuZXR3b3JrLnVybH0gdGFyZ2V0PVwiX2JsYW5rXCIgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiPlxuICAgICAgICAgIDxpIGNsYXNzTmFtZT17bmV0d29yay5jbGFzc30+PC9pPlxuICAgICAgICA8L2E+XG4gICAgICA8L3NwYW4+XG4gICAgKTtcbiAgfSk7XG5cbiAgcmV0dXJuIChcbiAgICA8Zm9vdGVyPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtbWQtMTJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzb2NpYWwtbGlua3NcIj57bmV0d29ya3N9PC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb3B5cmlnaHQgcHktNCB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyXCI+XG4gICAgICAgICAgICA8c21hbGw+Q29weXJpZ2h0ICZjb3B5OyBEZW5pcyBGZXRpbmluPC9zbWFsbD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Zvb3Rlcj5cbiAgKTtcbn1cbiIsICJpbXBvcnQgVHlwaWNhbCBmcm9tICdyZWFjdC10eXBpY2FsJztcblxuLy8gY2xhc3MgSGVhZGVyIGV4dGVuZHMgQ29tcG9uZW50IHtcbi8vICAgdGl0bGVzID0gW107XG5cbi8vICAgY29uc3RydWN0b3IoKSB7XG4vLyAgICAgc3VwZXIoKTtcbi8vICAgICB0aGlzLnN0YXRlID0geyBjaGVja2VkOiBmYWxzZSB9O1xuLy8gICAgIHRoaXMub25UaGVtZVN3aXRjaENoYW5nZSA9IHRoaXMub25UaGVtZVN3aXRjaENoYW5nZS5iaW5kKHRoaXMpO1xuLy8gICB9XG5cbi8vIH1cblxuLy8gZnVuY3Rpb24gb25UaGVtZVN3aXRjaENoYW5nZShjaGVja2VkOiBib29sZWFuKSB7XG4vLyAgIHRoaXMuc2V0U3RhdGUoeyBjaGVja2VkIH0pO1xuLy8gICB0aGlzLnNldFRoZW1lKCk7XG4vLyB9XG5cbi8vIHNldFRoZW1lKCkge1xuLy8gICB2YXIgZGF0YVRoZW1lQXR0cmlidXRlID0gXCJkYXRhLXRoZW1lXCI7XG4vLyAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbi8vICAgdmFyIG5ld1RoZW1lID1cbi8vICAgICBib2R5LmdldEF0dHJpYnV0ZShkYXRhVGhlbWVBdHRyaWJ1dGUpID09PSBcImRhcmtcIiA/IFwibGlnaHRcIiA6IFwiZGFya1wiO1xuLy8gICBib2R5LnNldEF0dHJpYnV0ZShkYXRhVGhlbWVBdHRyaWJ1dGUsIG5ld1RoZW1lKTtcbi8vIH1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSGVhZGVyKCkge1xuICBjb25zdCB0aXRsZXMgPSBbXCJHb2xhbmcgRGV2ZWxvcGVyXCIsIFwiUHl0aG9uIGRldmVsb3BlclwiLCBcIlRlY2ggTGVhZFwiXTtcbiAgY29uc3QgYW5pbWF0aW9uU3BlZWQgPSA1MDA7XG4gIGNvbnN0IHRpdGxlc0Zvcm1hdHRlZCA9IHRpdGxlcy5tYXAoKHgpID0+IFt4LnRvVXBwZXJDYXNlKCksIGFuaW1hdGlvblNwZWVkXSkuZmxhdCgpO1xuXG4gIHJldHVybiAoXG4gICAgPGhlYWRlciBpZD1cImhvbWVcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93IGFsaWduZXJcIiBzdHlsZT17eyBoZWlnaHQ6IFwiMTAwJVwiIH19PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1tZC0xMlwiPlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJpY29uaWZ5IGhlYWRlci1pY29uXCIgZGF0YS1pY29uPVwibGE6bGFwdG9wLWNvZGVcIiBkYXRhLWlubGluZT1cImZhbHNlXCI+PC9zcGFuPlxuICAgICAgICAgICAgPGJyIC8+XG4gICAgICAgICAgICA8aDEgY2xhc3NOYW1lPVwibWItMFwiPlxuICAgICAgICAgICAgICA8VHlwaWNhbCBzdGVwcz17W1wiRGVuaXMgRmV0aW5pblwiXX0gd3JhcHBlcj1cInBcIiAvPlxuICAgICAgICAgICAgPC9oMT5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidGl0bGUtY29udGFpbmVyXCI+XG4gICAgICAgICAgICAgIDxUeXBpY2FsIGNsYXNzTmFtZT1cInRpdGxlLXN0eWxlc1wiIHN0ZXBzPXt0aXRsZXNGb3JtYXR0ZWR9IGxvb3A9e0luZmluaXR5fSAvPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICB7LyogPFN3aXRjaFxuICAgICAgICAgICAgICBjaGVja2VkPXtjaGVja2VkfVxuICAgICAgICAgICAgICAvLyBvbkNoYW5nZT17dGhpcy5vblRoZW1lU3dpdGNoQ2hhbmdlfVxuICAgICAgICAgICAgICBvZmZDb2xvcj1cIiNiYWFhODBcIlxuICAgICAgICAgICAgICBvbkNvbG9yPVwiIzM1MzUzNVwiXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cInJlYWN0LXN3aXRjaCBteC1hdXRvXCJcbiAgICAgICAgICAgICAgd2lkdGg9ezkwfVxuICAgICAgICAgICAgICBoZWlnaHQ9ezQwfVxuICAgICAgICAgICAgICB1bmNoZWNrZWRJY29uPXtcbiAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiaWNvbmlmeVwiXG4gICAgICAgICAgICAgICAgICBkYXRhLWljb249XCJ0d2Vtb2ppOm93bFwiXG4gICAgICAgICAgICAgICAgICBkYXRhLWlubGluZT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDI1LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IFwiZW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IFwiMjBweFwiLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIjMzUzMjM5XCIsXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID48L3NwYW4+XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2hlY2tlZEljb249e1xuICAgICAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJpY29uaWZ5XCJcbiAgICAgICAgICAgICAgICAgIGRhdGEtaWNvbj1cIm5vdG8tdjE6c3VuLXdpdGgtZmFjZVwiXG4gICAgICAgICAgICAgICAgICBkYXRhLWlubGluZT1cImZhbHNlXCJcbiAgICAgICAgICAgICAgICAgIHN0eWxlPXt7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICAgICAgZm9udFNpemU6IDI1LFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IFwiZW5kXCIsXG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IFwiMTBweFwiLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogXCIjMzUzMjM5XCIsXG4gICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgID48L3NwYW4+XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWQ9XCJpY29uLXN3aXRjaFwiXG4gICAgICAgICAgICAvPiAqL31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2hlYWRlcj5cbiAgKTtcbn1cbiIsICJleHBvcnQgYXN5bmMgZnVuY3Rpb24gdHlwZShub2RlLCAuLi5hcmdzKSB7XG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xuICAgICAgICBzd2l0Y2ggKHR5cGVvZiBhcmcpIHtcbiAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgYXdhaXQgZWRpdChub2RlLCBhcmcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICBhd2FpdCB3YWl0KGFyZyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgYXdhaXQgYXJnKG5vZGUsIC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBhd2FpdCBhcmc7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGVkaXQobm9kZSwgdGV4dCkge1xuICAgIGNvbnN0IG92ZXJsYXAgPSBnZXRPdmVybGFwKG5vZGUudGV4dENvbnRlbnQsIHRleHQpO1xuICAgIGF3YWl0IHBlcmZvcm0obm9kZSwgWy4uLmRlbGV0ZXIobm9kZS50ZXh0Q29udGVudCwgb3ZlcmxhcCksIC4uLndyaXRlcih0ZXh0LCBvdmVybGFwKV0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiB3YWl0KG1zKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHBlcmZvcm0obm9kZSwgZWRpdHMsIHNwZWVkID0gNjApIHtcbiAgICBmb3IgKGNvbnN0IG9wIG9mIGVkaXRvcihlZGl0cykpIHtcbiAgICAgICAgb3Aobm9kZSk7XG4gICAgICAgIGF3YWl0IHdhaXQoc3BlZWQgKyBzcGVlZCAqIChNYXRoLnJhbmRvbSgpIC0gMC41KSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24qIGVkaXRvcihlZGl0cykge1xuICAgIGZvciAoY29uc3QgZWRpdCBvZiBlZGl0cykge1xuICAgICAgICB5aWVsZCAobm9kZSkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IG5vZGUudGV4dENvbnRlbnQgPSBlZGl0KTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogd3JpdGVyKFsuLi50ZXh0XSwgc3RhcnRJbmRleCA9IDAsIGVuZEluZGV4ID0gdGV4dC5sZW5ndGgpIHtcbiAgICB3aGlsZSAoc3RhcnRJbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgIHlpZWxkIHRleHQuc2xpY2UoMCwgKytzdGFydEluZGV4KS5qb2luKCcnKTtcbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiogZGVsZXRlcihbLi4udGV4dF0sIHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCA9IHRleHQubGVuZ3RoKSB7XG4gICAgd2hpbGUgKGVuZEluZGV4ID4gc3RhcnRJbmRleCkge1xuICAgICAgICB5aWVsZCB0ZXh0LnNsaWNlKDAsIC0tZW5kSW5kZXgpLmpvaW4oJycpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE92ZXJsYXAoc3RhcnQsIFsuLi5lbmRdKSB7XG4gICAgcmV0dXJuIFsuLi5zdGFydCwgTmFOXS5maW5kSW5kZXgoKGNoYXIsIGkpID0+IGVuZFtpXSAhPT0gY2hhcik7XG59XG4iLCAiZnVuY3Rpb24gc3R5bGVJbmplY3QoY3NzLCByZWYpIHtcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICB2YXIgaW5zZXJ0QXQgPSByZWYuaW5zZXJ0QXQ7XG5cbiAgaWYgKCFjc3MgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykgeyByZXR1cm47IH1cblxuICB2YXIgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgc3R5bGUudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cbiAgaWYgKGluc2VydEF0ID09PSAndG9wJykge1xuICAgIGlmIChoZWFkLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgfSBlbHNlIHtcbiAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBzdHlsZUluamVjdDtcbiIsICJcbmltcG9ydCBSZWFjdCwgeyB1c2VSZWYsIHVzZUVmZmVjdCwgbWVtbyB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdHlwZSwgdHlwZSBhcyBsb29wZWRUeXBlIH0gZnJvbSBcIkBjYW13aWVnZXJ0L3R5cGljYWxcIjtcblxuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5jc3MnXG5cbmNvbnN0IFR5cGljYWwgPSAoeyBzdGVwcywgbG9vcCwgY2xhc3NOYW1lLCB3cmFwcGVyID0gXCJwXCIgfSkgPT4ge1xuICBjb25zdCB0eXBpY2FsUmVmID0gdXNlUmVmKG51bGwpO1xuICBjb25zdCBDb21wb25lbnQgPSB3cmFwcGVyO1xuICBjb25zdCBjbGFzc05hbWVzID0gW3N0eWxlcy50eXBpY2FsV3JhcHBlcl07XG4gIFxuICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgY2xhc3NOYW1lcy51bnNoaWZ0KGNsYXNzTmFtZSk7XG4gIH1cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChsb29wID09PSBJbmZpbml0eSkge1xuICAgICAgdHlwZSh0eXBpY2FsUmVmLmN1cnJlbnQsIC4uLnN0ZXBzLCBsb29wZWRUeXBlKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb29wID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0eXBlKFxuICAgICAgICB0eXBpY2FsUmVmLmN1cnJlbnQsXG4gICAgICAgIC4uLkFycmF5KGxvb3ApXG4gICAgICAgICAgLmZpbGwoc3RlcHMpXG4gICAgICAgICAgLmZsYXQoKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSh0eXBpY2FsUmVmLmN1cnJlbnQsIC4uLnN0ZXBzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiA8Q29tcG9uZW50IHJlZj17dHlwaWNhbFJlZn0gY2xhc3NOYW1lPXtjbGFzc05hbWVzLmpvaW4oJyAnKX0vPjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWVtbyhUeXBpY2FsKVxuIiwgImRlY2xhcmUgdHlwZSBTa2lsbCA9IHtcbiAgbmFtZTogc3RyaW5nO1xuICBjbGFzczogc3RyaW5nO1xuICBsZXZlbDogc3RyaW5nO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2tpbGxzKHtza2lsbHN9OiB7c2tpbGxzOiBTa2lsbFtdfSkge1xuICB2YXIgc2tpbGxzSHRtbCA9IHNraWxscy5mbGF0TWFwKChza2lsbCwgaSkgPT4ge1xuICAgIHJldHVybiAoXG4gICAgICA8bGkgY2xhc3NOYW1lPVwibGlzdC1pbmxpbmUtaXRlbSBteC0zXCIga2V5PXtpfT5cbiAgICAgICAgPHNwYW4+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LWNlbnRlciBza2lsbHMtdGlsZVwiPlxuICAgICAgICAgICAgPGkgY2xhc3NOYW1lPXtza2lsbC5jbGFzc30gc3R5bGU9e3sgZm9udFNpemU6IFwiMjIwJVwiIH19PlxuICAgICAgICAgICAgICA8cFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCJcbiAgICAgICAgICAgICAgICBzdHlsZT17eyBmb250U2l6ZTogXCIzMCVcIiwgbWFyZ2luVG9wOiBcIjRweFwiIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7c2tpbGwubmFtZX1cbiAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPC9pPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L2xpPlxuICAgICk7XG4gIH0pO1xuXG4gIHJldHVybiAoXG4gICAgPHNlY3Rpb24gaWQ9XCJza2lsbHNcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLW1kLTEyXCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLW1kLTEyXCI+XG4gICAgICAgICAgPGgxIGNsYXNzTmFtZT1cInNlY3Rpb24tdGl0bGVcIj5cbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtd2hpdGVcIj5Ta2lsbHM8L3NwYW4+XG4gICAgICAgICAgPC9oMT5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLW1kLTEyIHRleHQtY2VudGVyXCI+XG4gICAgICAgICAgPHVsIGNsYXNzTmFtZT1cImxpc3QtaW5saW5lIG14LWF1dG8gc2tpbGwtaWNvblwiPntza2lsbHNIdG1sfTwvdWw+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9zZWN0aW9uPlxuICApO1xufVxuIiwgImV4cG9ydCBkZWZhdWx0IFtcbiAge1xuICAgIHRpdGxlOiBcIlNlbmlvciBTb2Z0d2FyZSBEZXZlbG9wZXJcIixcbiAgICBjb21wYW55OiB7IHRpdGxlOiBcIkxhbW9kYVwiLCBsaW5rOiBcImh0dHBzOi8vbGFtb2RhLnJ1L1wiIH0sXG4gICAgeWVhcnM6IFwiMTAuMjAxOSAtIHByZXNlbnRcIixcbiAgICBtYWluVGVjaDogW1wiR29sYW5nXCJdLFxuICAgIHRlY2hub2xvZ2llczogW1wiS2Fma2FcIiwgXCJQb3N0Z3JlU1FMXCIsIFwiS3ViZXJuZXRlc1wiLCBcIlB5dGhvbiAzLjYrXCIsIFwiVnVlLmpzXCIsIFwiRGphbmdvXCIsIFwiUmVkZGlzXCIsIFwiUmFiYml0TVFcIl0sXG4gICAgaWNvbkNsYXNzOiBcImZhLWJyYW5kcyBmYS1nb2xhbmdcIixcbiAgfSxcbiAge1xuICAgIHRpdGxlOiBcIlB5dGhvbiBEZXZlbG9wZXJcIixcbiAgICBjb21wYW55OiB7IHRpdGxlOiBcIlRpb25peFwiLCBsaW5rOiBcImh0dHBzOi8vd3d3LnRpb25peC5ydVwiIH0sXG4gICAgeWVhcnM6IFwiMDkuMjAxNiAtIDA4LjIwMThcIixcbiAgICBtYWluVGVjaDogW1wiUHl0aG9uIDIuNy8zXCJdLFxuICAgIHRlY2hub2xvZ2llczogW1wiUHl0aG9uXCIsIFwiRGphbmdvXCIsIFwiUmFiYml0TVFcIiwgXCJNeVNRTFwiLCBcIkNlbnRPU1wiLCBcIlJlc3QgQVBJXCIsIFwiU1FMQWxjaGVteVwiXSxcbiAgICBpY29uQ2xhc3M6IFwiZmFiIGZhLXB5dGhvblwiLFxuICB9LFxuXTtcbiIsICJleHBvcnQgY29uc3Qgc2tpbGxzID0gW1xuICAgIHtcbiAgICAgIG5hbWU6IFwiR29sYW5nXCIsXG4gICAgICBjbGFzczogXCJkZXZpY29uLWdvLXBsYWluXCIsXG4gICAgICBsZXZlbDogXCI5NVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJQeXRob25cIixcbiAgICAgIGNsYXNzOiBcImRldmljb24tcHl0aG9uLXBsYWluXCIsXG4gICAgICBsZXZlbDogXCI4MFwiLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJQb3N0Z3Jlc1wiLFxuICAgICAgY2xhc3M6IFwiZGV2aWNvbi1wb3N0Z3Jlc3FsLXBsYWluXCIsXG4gICAgICBsZXZlbDogXCI3NVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJLYWZrYVwiLFxuICAgICAgY2xhc3M6IFwiZGV2aWNvbi1hcGFjaGVrYWZrYS1wbGFpblwiLFxuICAgICAgbGV2ZWw6IFwiNzBcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwiS3ViZXJuZXRlc1wiLFxuICAgICAgY2xhc3M6IFwiZGV2aWNvbi1rdWJlcm5ldGVzLXBsYWluXCIsXG4gICAgICBsZXZlbDogXCI5NVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogXCJWdWVKU1wiLFxuICAgICAgY2xhc3M6IFwiZGV2aWNvbi12dWVqcy1wbGFpblwiLFxuICAgICAgbGV2ZWw6IFwiODVcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFwiTXlTcWxcIixcbiAgICAgIGNsYXNzOiBcImRldmljb24tbXlzcWwtcGxhaW5cIixcbiAgICAgIGxldmVsOiBcIjYwXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBcIlR5cGVTY3JpcHRcIixcbiAgICAgIGNsYXNzOiBcImRldmljb24tdHlwZXNjcmlwdC1wbGFpblwiLFxuICAgICAgbGV2ZWw6IFwiOTBcIixcbiAgICB9LFxuICBdOyIsICJleHBvcnQgZGVmYXVsdCBbXG4gIHtcbiAgICBuYW1lOiBcImxpbmtlZGluXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vd3d3LmxpbmtlZGluLmNvbS9pbi9kZW5pcy1mZXRpbmluXCIsXG4gICAgY2xhc3M6IFwiZmFiIGZhLWxpbmtlZGluXCIsXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcImdpdGh1YlwiLFxuICAgIHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vV2hhdC1JZi1JXCIsXG4gICAgY2xhc3M6IFwiZmFiIGZhLWdpdGh1YlwiLFxuICB9LFxuICB7XG4gICAgbmFtZTogXCJ0ZWxlZ3JhbVwiLFxuICAgIHVybDogXCJodHRwczovL3d3dy50Lm1lL2ZldGluaW5cIixcbiAgICBjbGFzczogXCJmYWIgZmEtdGVsZWdyYW1cIixcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiaW5zdGFncmFtXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vd3d3Lmluc3RhZ3JhbS5jb20vZC5mZXRpbmluXCIsXG4gICAgY2xhc3M6IFwiZmFiIGZhLWluc3RhZ3JhbVwiLFxuICB9LFxuXTtcbiIsICJleHBvcnQgZGVmYXVsdCB7J3ZlcnNpb24nOidkYjQyY2YxMicsJ2VudHJ5Jzp7J21vZHVsZSc6Jy9idWlsZC9lbnRyeS5jbGllbnQtS1hXSE9WV0cuanMnLCdpbXBvcnRzJzpbJy9idWlsZC9fc2hhcmVkL2NodW5rLU9VVkVHVVhKLmpzJywnL2J1aWxkL19zaGFyZWQvY2h1bmstMzI1RDM3TVMuanMnXX0sJ3JvdXRlcyc6eydyb290Jzp7J2lkJzoncm9vdCcsJ3BhcmVudElkJzp1bmRlZmluZWQsJ3BhdGgnOicnLCdpbmRleCc6dW5kZWZpbmVkLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb290LUEzWkdYM0VBLmpzJywnaW1wb3J0cyc6dW5kZWZpbmVkLCdoYXNBY3Rpb24nOmZhbHNlLCdoYXNMb2FkZXInOmZhbHNlLCdoYXNDYXRjaEJvdW5kYXJ5JzpmYWxzZSwnaGFzRXJyb3JCb3VuZGFyeSc6ZmFsc2V9LCdyb3V0ZXMvaW5kZXgnOnsnaWQnOidyb3V0ZXMvaW5kZXgnLCdwYXJlbnRJZCc6J3Jvb3QnLCdwYXRoJzp1bmRlZmluZWQsJ2luZGV4Jzp0cnVlLCdjYXNlU2Vuc2l0aXZlJzp1bmRlZmluZWQsJ21vZHVsZSc6Jy9idWlsZC9yb3V0ZXMvaW5kZXgtRUFEWFRRSTQuanMnLCdpbXBvcnRzJzp1bmRlZmluZWQsJ2hhc0FjdGlvbic6ZmFsc2UsJ2hhc0xvYWRlcic6ZmFsc2UsJ2hhc0NhdGNoQm91bmRhcnknOmZhbHNlLCdoYXNFcnJvckJvdW5kYXJ5JzpmYWxzZX19LCd1cmwnOicvYnVpbGQvbWFuaWZlc3QtREI0MkNGMTIuanMnfTsiXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFRQSxRQUFJLHdCQUF3QixPQUFPO0FBQ25DLFFBQUksa0JBQWlCLE9BQU8sVUFBVTtBQUN0QyxRQUFJLG1CQUFtQixPQUFPLFVBQVU7QUFFeEMsc0JBQWtCLEtBQUs7QUFDdEIsVUFBSSxRQUFRLFFBQVEsUUFBUSxRQUFXO0FBQ3RDLGNBQU0sSUFBSSxVQUFVO0FBQUE7QUFHckIsYUFBTyxPQUFPO0FBQUE7QUFHZiwrQkFBMkI7QUFDMUIsVUFBSTtBQUNILFlBQUksQ0FBQyxPQUFPLFFBQVE7QUFDbkIsaUJBQU87QUFBQTtBQU1SLFlBQUksUUFBUSxJQUFJLE9BQU87QUFDdkIsY0FBTSxLQUFLO0FBQ1gsWUFBSSxPQUFPLG9CQUFvQixPQUFPLE9BQU8sS0FBSztBQUNqRCxpQkFBTztBQUFBO0FBSVIsWUFBSSxRQUFRO0FBQ1osaUJBQVMsSUFBSSxHQUFHLElBQUksSUFBSSxLQUFLO0FBQzVCLGdCQUFNLE1BQU0sT0FBTyxhQUFhLE1BQU07QUFBQTtBQUV2QyxZQUFJLFNBQVMsT0FBTyxvQkFBb0IsT0FBTyxJQUFJLFNBQVUsR0FBRztBQUMvRCxpQkFBTyxNQUFNO0FBQUE7QUFFZCxZQUFJLE9BQU8sS0FBSyxRQUFRLGNBQWM7QUFDckMsaUJBQU87QUFBQTtBQUlSLFlBQUksUUFBUTtBQUNaLCtCQUF1QixNQUFNLElBQUksUUFBUSxTQUFVLFFBQVE7QUFDMUQsZ0JBQU0sVUFBVTtBQUFB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QUFjO0FBQUEsVUFDZCxRQUFRO0FBQUEsVUFDUixhQUFhO0FBQUEsVUFDYix5QkFBeUI7QUFBQSxVQUN6QixNQUFNO0FBQUEsVUFDTixVQUFVO0FBQUEsVUFDVixTQUFTO0FBQUEsVUFDVCxnQkFBZ0I7QUFBQSxVQUNoQixjQUFjO0FBQUEsVUFDZCxPQUFPO0FBQUEsVUFDUCxLQUFLO0FBQUEsVUFDTCxVQUFVO0FBQUEsVUFDVix5QkFBeUI7QUFBQSxVQUN6Qix1QkFBdUI7QUFBQSxVQUN2QixVQUFVO0FBQUEsVUFDVixXQUFXO0FBQUEsVUFDWCxTQUFTO0FBQUEsVUFDVCxjQUFjO0FBQUEsVUFDZCxLQUFLO0FBQUEsVUFDTCxNQUFNO0FBQUEsVUFDTixZQUFZO0FBQUEsVUFDWixZQUFZO0FBQUEsVUFDWixhQUFhO0FBQUEsVUFDYixnQkFBZ0I7QUFBQSxVQUNoQixZQUFZO0FBQUEsVUFDWixhQUFhO0FBQUEsVUFDYixTQUFTO0FBQUEsVUFDVCxRQUFRO0FBQUEsVUFDUixRQUFRO0FBQUEsVUFDUixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixVQUFVO0FBQUEsVUFDVixTQUFTO0FBQUEsVUFDVCxXQUFXO0FBQUEsVUFDWCxjQUFjO0FBQUEsVUFDZCxNQUFNO0FBQUEsVUFDTixJQUFJO0FBQUEsVUFDSixXQUFXO0FBQUEsVUFDWCxXQUFXO0FBQUEsVUFDWCxXQUFXO0FBQUEsVUFDWCxJQUFJO0FBQUEsVUFDSixRQUFRO0FBQUEsVUFDUixVQUFVO0FBQUEsVUFDVixTQUFTO0FBQUEsVUFDVCxXQUFXO0FBQUEsVUFDWCxVQUFVO0FBQUEsVUFDVixXQUFXO0FBQUEsVUFDWCxTQUFTO0FBQUEsVUFDVCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixLQUFLO0FBQUEsVUFDTCxVQUFVO0FBQUEsVUFDVixhQUFhO0FBQUEsVUFDYixjQUFjO0FBQUEsVUFDZCxLQUFLO0FBQUEsVUFDTCxXQUFXO0FBQUEsVUFDWCxPQUFPO0FBQUEsVUFDUCxZQUFZO0FBQUEsVUFDWixRQUFRO0FBQUEsVUFDUixLQUFLO0FBQUEsVUFDTCxXQUFXO0FBQUEsVUFDWCxVQUFVO0FBQUEsVUFDVixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixVQUFVO0FBQUEsVUFDVixPQUFPO0FBQUEsVUFDUCxZQUFZO0FBQUEsVUFDWixNQUFNO0FBQUEsVUFDTixTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUEsVUFDVCxhQUFhO0FBQUEsVUFDYixhQUFhO0FBQUEsVUFDYixRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUEsVUFDVCxZQUFZO0FBQUEsVUFDWixVQUFVO0FBQUEsVUFDVixnQkFBZ0I7QUFBQSxVQUNoQixLQUFLO0FBQUEsVUFDTCxVQUFVO0FBQUEsVUFDVixVQUFVO0FBQUEsVUFDVixNQUFNO0FBQUEsVUFDTixNQUFNO0FBQUEsVUFDTixTQUFTO0FBQUEsVUFDVCxTQUFTO0FBQUEsVUFDVCxPQUFPO0FBQUEsVUFDUCxRQUFRO0FBQUEsVUFDUixXQUFXO0FBQUEsVUFDWCxVQUFVO0FBQUEsVUFDVixVQUFVO0FBQUEsVUFDVixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixZQUFZO0FBQUEsVUFDWixLQUFLO0FBQUEsVUFDTCxRQUFRO0FBQUEsVUFDUixTQUFTO0FBQUEsVUFDVCxRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixPQUFPO0FBQUEsVUFDUCxTQUFTO0FBQUEsVUFDVCxVQUFVO0FBQUEsVUFDVixRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFDTixRQUFRO0FBQUEsVUFDUixPQUFPO0FBQUEsVUFDUCxPQUFPO0FBQUEsVUFDUCxPQUFPO0FBQUEsVUFDUCxNQUFNO0FBQUEsVUFFTixPQUFPO0FBQUEsVUFDUCxjQUFjO0FBQUEsVUFDZCxpQkFBaUI7QUFBQSxVQUNqQixZQUFZO0FBQUEs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
